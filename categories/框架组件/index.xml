<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>框架组件 on 飞光</title>
    <link>https://rjguanwen.cn/categories/%E6%A1%86%E6%9E%B6%E7%BB%84%E4%BB%B6/</link>
    <description>Recent content in 框架组件 on 飞光</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 08 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://rjguanwen.cn/categories/%E6%A1%86%E6%9E%B6%E7%BB%84%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gin 表单与文件上传</title>
      <link>https://rjguanwen.cn/posts/gin/gin_03/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/gin/gin_03/</guid>
      <description>
        
          
            表单参数 表单传输为 POST 请求，http 常见的传输格式为四种：
application/json application/x-www-form-urlencoded application/xml multipart/form-data 表单参数可以通过 PostForm() 方法获取，该方法默认解析的是 x-www-form-urlencoded 或 form-data 格式的参数。
简单的表单示例： &amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;&amp;lt;title&amp;gt;demo1&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form action=&amp;#34;http://localhost:8080/form&amp;#34; method=&amp;#34;post&amp;#34; enctype=&amp;#34;application/x-www-form-urlencoded&amp;#34;&amp;gt;用户名：&amp;lt;inpurt type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; placeholder=&amp;#34;请输入你的用户名&amp;#34;&amp;gt; &amp;lt;br&amp;gt;密&amp;amp;nbsp;&amp;amp;nbsp;码：&amp;lt;input type=&amp;#34;password&amp;#34; name=&amp;#34;password&amp;#34; placeholder=&amp;#34;请输入你的密码&amp;#34;&amp;gt; &amp;lt;br&amp;gt;&amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34;&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; package mainimport (&amp;#34;fmt&amp;#34;&amp;#34;github.com/gin-gonic/gin&amp;#34;&amp;#34;net/http&amp;#34;)//表单参数func main(){r:=gin.Default()r.POST(&amp;#34;/form&amp;#34;, func(c *gin.Context) {types:=c.DefaultPostForm(&amp;#34;type&amp;#34;,&amp;#34;post&amp;#34;)// 键名和html页面属性名对应username:=c.PostForm(&amp;#34;username&amp;#34;)password:=c.PostForm(&amp;#34;userpassword&amp;#34;)c.String(http.StatusOK,fmt.Sprintf(&amp;#34;username:%s,password:%s,types:%s&amp;#34;,username,password,types))})r.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Gin 路由</title>
      <link>https://rjguanwen.cn/posts/gin/gin_02/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/gin/gin_02/</guid>
      <description>
        
          
            路由 核心功能 路由系统可根据请求方法、请求路径和路径参数来识别转发 可设置一个或者多个中间件用于在请求处理器前后处理特殊的事件 可以分组设置，将一个或多个中间件作用在一组多个路由上 基本语法 //构建路由对象并注册请求路径对应的处理器r := gin.Default()r.GET(&amp;#34;/ping&amp;#34;, func(c *gin.Context) {c.JSON(200, gin.H{&amp;#34;message&amp;#34;: &amp;#34;ping&amp;#34;,})})// 监听并在 0.0.0.0：8080 上启动服务r.Run() 可以将路由的定义放在单独的文件中完成，如 /router/api.go :
// file: /router/api.gofunc APIRouter() *gin.Engine {r := gin.Default()r.GET(&amp;#34;/ping&amp;#34;, func(c *gin.Context) {c.JSON(200, gin.H{&amp;#34;message&amp;#34;: &amp;#34;ping&amp;#34;})})// 更多的注册// r.POST()// r.DELETE()// r.PUT()return r} 然后，在 main() 中完成调用和初始化，并启动监听：
// file /main.gofunc main() {// 初始化路由r := router.
          
          
        
      </description>
    </item>
    
    <item>
      <title>hugo 常用命令</title>
      <link>https://rjguanwen.cn/posts/tec_ot/hugo_cmd/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/tec_ot/hugo_cmd/</guid>
      <description>
        
          
            常用命令 #使用方法:hugohugo [flags]hugo [command]hugo [command] [flags]#查看版本hugo version#版本和环境详细信息hugo env#创建新站点hugo new site &amp;#34;$mysite&amp;#34;#创建文章hugo new index.md 在content/文件夹可以看到，此时多了一个markdown格式的文件index.md，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。#编译生成静态文件hugoHugo将编译所有文件并输出到public目录 #编译生成静态文件并启动web服务hugo server 常用参数 --bind=&amp;#34;127.0.0.1&amp;#34; 服务监听IP地址；-p, --port=1313 服务监听端口；-w, --watch[=true] 监听站点目录，发现文件变更自动编译；-D, --buildDrafts 包括被标记为draft的文章；-E, --buildExpired 包括已过期的文章；-F, --buildFuture 包括将在未来发布的文章；-b, --baseURL=&amp;#34;www.datals.com&amp;#34; 服务监听域名；--log[=false]: 开启日志；--logFile=&amp;#34;/var/log/hugo.log&amp;#34;: log输出路径；-t, --theme=&amp;#34;&amp;#34; 指定主题；-v, --verbose[=false]: 输出详细信息 
          
          
        
      </description>
    </item>
    
    <item>
      <title>rasa 入门</title>
      <link>https://rjguanwen.cn/posts/rasa/rasa-1/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/rasa/rasa-1/</guid>
      <description>
        
          
            **前言：没有比官网文档更好的资料了。**看这里https://rasa.com/docs/rasa/
rasa 安装 pip install -U rasa pip show rasa 注：我是用的 rasa 版本为 Version: 2.8.1
初始化项目 1、 在工作文件夹中执行
# 创建默认的初始化项目，加“--no-prompt”就避免了中间的问题提示rasa init --no-prompt 该命令会在工作文件夹中创建一系列的文件，关键文件如下：
config.yml : Rasa NLU 和 Rasa Core 的配置文件 credentials.yml : 定义和其他服务连接的一些细节，例如rasa api接口 data/nlu.yml : Rasa NLU 的训练数据 data/stories.yml : Rasa stories 数据 data/rule.yml : Rasa 规则数据 endpoints.yml : 和外部消息服务对接的配置 models/.tar.gz : 初始训练的模型数据 以上文件都打开看一下，基本能明白是啥意思。
2、 训练模型
如果添加了 NLU 或者 Core 数据，或者修改了domain和配置文件，需要重新训练模型：
rasa train 3、 对话应用
rasa shell 可能因训练数据的问题，bot 表现的挺傻的，呵呵~
          
          
        
      </description>
    </item>
    
    <item>
      <title>rasa 继续入门 - 语言模型与分词器</title>
      <link>https://rjguanwen.cn/posts/rasa/rasa-2/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/rasa/rasa-2/</guid>
      <description>
        
          
            rasa 支持多种语言模型与分词器，语言模型常用的有 MITIENLP 和 SpaCyNLP，分词器常用的有 WhitespaceTokenizer、JiebaTokenizer、MitieTokenizer、SpacyTokenizer 等。
WhitespaceTokenizer 空格分词器，每个空格间隔的文本，都将分为一个token，典型的英文句子的分词。该分词器不支持中文分词。配置方式如下：
pipeline:- name: &amp;#34;WhitespaceTokenizer&amp;#34;# Flag to check whether to split intents&amp;#34;intent_tokenization_flag&amp;#34;: False# Symbol on which intent should be split&amp;#34;intent_split_symbol&amp;#34;: &amp;#34;+&amp;#34;# Regular expression to detect tokens&amp;#34;token_pattern&amp;#34;: None intent_tokenization_flag和intent_split_symbol是在nlu返回多意图的时候使用。当intent_tokenization_flag设置为False，nlu只返回一个置信度最高的意图。但有些时候，一句话包含多个意图，例如：
## intent: affirm+ask_transport- Yes. How do I get there?- Sounds good. Do you know how I could get there from home? 用户的回答包含2层意思，首先是同意我的建议，另外是询问怎么去。这时候，需要将intent_tokenization_flag设置为True，然后在训练数据里面编写多意图对应的话术，多个意图中间用intent_split_symbol去分割。在运行的时候，用户说“Sounds good. Do you know how I could get there from home?
          
          
        
      </description>
    </item>
    
    <item>
      <title>Apache Superset 简介</title>
      <link>https://rjguanwen.cn/posts/superset/superset_01/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/superset/superset_01/</guid>
      <description>
        
          
            Apache Superset 简介 概要信息 项目 说明 官网 https://superset.apache.org/ 开源/闭源 开源 源码管理地址 https://github.com/apache/incubator-superset/wiki License类别 Mozilla Public License 2.0 开发语言 GO 操作系统支持 跨平台，支持多种操作系统 主要特性 Apache Superset是一款快速直观的轻量级工具，具有丰富的功能选项，各种用户都可以轻松地以可视化的方式浏览数据，从简单的折线图到高度详细的地理空间图，Apache Superset无所不能，提供了如下主要特性：
强大易用：可以快速容易地集成，从而浏览数据，而这一切通过SQL IDE或者无需编写代码，通过可视化构建器即可完成。
架构设计：Superset轻巧且极具可扩展性，它可以利用既存的数据基础框架而不需要另外一个接收层。
丰富的可视化方式与仪表盘：Superset提供了多种精美的可视化效果。可视化插件体系结构使得构建自定义的可视化变得更为容易。
支持多种数据库：可以通过SQL Alchemy连接到任何基于SQL的数据源，包括云原生的数据库以及PB级的数据引擎。比如：
基于 docker 部署使用 1、 下载 superset 镜像
docker search superset 选择 STARTS 最高的镜像
docker pull amancevice/superset 2、启动并初始化
创建挂载目录：
mkdir /opt/docker/superset/conf &amp;amp; mkdir /opt/docker/superset/data 启动镜像：
docker run --name superset -u 0 -d -p 8088:8088 -v /opt/docker/superset/conf:/etc/superset -v /opt/docker/superset/data:/var/lib/superset amancevice/superset 初始化 superset：
          
          
        
      </description>
    </item>
    
    <item>
      <title>Apache Ignite 实践记录</title>
      <link>https://rjguanwen.cn/posts/ignite/ignite_02/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/ignite/ignite_02/</guid>
      <description>
        
          
            Apache Ignite 实践记录 使用 Docker 安装 基于 win10 WSL2(Ubuntu)
创建本地目录 mkdir ignite_dir 使用本地目录启动持久化集群 docker run -d \ -v ${PWD}/ignite_dir:/storage \ -e IGNITE_WORK_DIR=/storage \ apacheignite/ignite:2.9.0 使用自定义配置文件 通过 URI 传递配置文件 docker run -d \ -e CONFIG_URI=http://myserver/config.xml \ apacheignite/ignite:2.9.0 使用本地配置文件 docker run -d \ -v /local/dir/config.xml:/config-file.xml \ -e CONFIG_URI=/config-file.xml \ apacheignite/ignite:2.9.0 启用模块 要启用特定模块，需要在 OPTION_LIBS 系统变量中指定。 sudo docker run -d \ -e &amp;#34;OPTION_LIBS=ignite-rest-http,ignite-aws&amp;#34; \ apacheignite/ignite:2.9.0 Ignite 的 Docker 镜像默认会启用 ignite-log4j、ignite-spring、ignite-indexing 等模块。
环境变量 名称 描述 默认 CONFIG_URI Ignite配置文件的URL，下载的配置文件会保存于.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Apache Ignite 简介</title>
      <link>https://rjguanwen.cn/posts/ignite/ignite_01/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/ignite/ignite_01/</guid>
      <description>
        
          
            Apache Ignite 简介 待完善
          
          
        
      </description>
    </item>
    
    <item>
      <title>Windows 更新 git 版本</title>
      <link>https://rjguanwen.cn/posts/git/git_04/</link>
      <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/git/git_04/</guid>
      <description>
        
          
            1、查看当前安装的 git 版本 git --version 2、更新 git 版本是 2.17.1 之前的：
git update git 版本是 2.17.1 之后的：
git update-git-for-windows 3、如出现错误 重新下载新版本安装包，覆盖安装即可：https://git-scm.com/download/win
          
          
        
      </description>
    </item>
    
    <item>
      <title>Gin Quickstart</title>
      <link>https://rjguanwen.cn/posts/gin/gin_01/</link>
      <pubDate>Sat, 13 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/gin/gin_01/</guid>
      <description>
        
          
            Gin 使基于 go 语言的一个 web 框架，接口简洁，封装比较优雅，性能表现很好。
Gin 特性 快速：路由不使用反射，基于Radix树，内存占用少。
中间件：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。中间件机制极大地提高了框架的可扩展性。
异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。
JSON：Gin可以解析并验证请求的JSON。这个特性对Restful API的开发尤其有用。
路由分组：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。
渲染内置：原生支持JSON，XML和HTML的渲染。
Quickstart 安装 Gin 前，首先要安装 Go，并做好各种设置。Go 版本要求 1.9 以上。 下载并安装 Gin。 $ go get -u github.com/gin-gonic/gin 在代码中引入： import &amp;#34;github.com/gin-gonic/gin&amp;#34; 如果需要使用类似 http.StatusOK 的常量，则需引入 net/http。 import &amp;#34;net/http&amp;#34; 示例代码： package mainimport &amp;#34;github.com/gin-gonic/gin&amp;#34;func main() {r := gin.Default()r.GET(&amp;#34;/ping&amp;#34;, func(c *gin.Context) {c.JSON(200, gin.H{&amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34;,})})r.Run() // listen and serve on 0.0.0.0:8080} 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Redis 常用命令</title>
      <link>https://rjguanwen.cn/posts/redis/redis_01/</link>
      <pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/redis/redis_01/</guid>
      <description>
        
          
            Redis 常用命令，备查！
&amp;lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！&amp;gt;
一、管理命令 1 启动 Redis &amp;gt; redis-server [--port 6379] 如果命令参数过多，建议通过配置文件来启动 Redis。
&amp;gt; redis-server [xx/xx/redis.conf] 2 连接 Redis &amp;gt; ./redis-cli [-h 127.0.0.1 -p 6379] 3 停止 Reids &amp;gt; redis-cli shutdown&amp;gt; kill redis-pid 以上两条命令，效果一样
4 发送命令 给 Redis 发送命令有两种方式： 1、redis-cli 带参数运行
&amp;gt; redis-cli &amp;lt;命令，如 shutdown&amp;gt; 2、redis-cli不带参数运行，先执行 redis-cli，进入命令行执行命令
5 测试连通性 &amp;gt; ping 二、key 操作命令 1 获取所有键 语法：keys pattern
&amp;gt; keys * 表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度O(n)，在生产环境不建议使用。 2 获取键总数 语法：dbsize
获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度O(1)。 3 查询键是否存在 语法：exists key [key &amp;hellip;]
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（九）使用 Redis 实现伸缩</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_09/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_09/</guid>
      <description>
        
          
            Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，我们将使用前面章节中讲到的 Redis engine。
首先，我们需要有一个处在运行状态的 Redis 服务器。然后，我们可以一次启动三个 Cetrifugofu 服务节点：
打开命令行窗口，启动第一个节点：
centrifugo --config=config.json --port=8000 --engine=redis --redis_host=127.0.0.1 --redis_port=6379 如果 Redis 和 Centrifugo 运行在同一台机器，并且使用了默认的端口号，上面命令中的 redis_host 与 redis_port 选项可以省略。
然后打开一个新的命令行窗口，启动第二个节点：
centrifugo --config=config.json --port=8001 --engine=redis --redis_host=127.0.0.1 --redis_port=6379 此命令中，我们指定了一个新的端口 8001，以防与节点一出现端口冲突。如果你的两个节点不在一台机器上，则不存在该问题。
接下来再次开启一个新的命令行窗口，启动第三个节点：
centrifugo --config=config.json --port=8002 --engine=redis --redis_host=127.0.0.1 --redis_port=6379 现在你已经拥有了三个 Centrifugo 实例，分别运行在 8000、8001、8002 端口，客户端可以选择连接任何一个实例。同样，你也可以发送 API 请求到任何一个节点。这三个节点通过 Redis 的 PUB/SUB 机制实现消息共享。
多个节点之间的负载均衡可以通过 Nginx 实现。要非常注意的一点是，如果你的客户端使用了 SockJS 连接到 Centrifugo 节点，那么接下来的该客户端的请求只能路由到同一节点，因为该节点保存了客户端的会话信息。而使用 websocket 则不存在该问题。
Redis 分片
从 V1.6.0 开始 Centrifugo 内置了对 Redis 分片的支持。
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（十）令牌和签名</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_10/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_10/</guid>
      <description>
        
          
            Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。
本文主要描述如何针对不同的动作（actions）生成令牌及签名。如果你使用 Python，那么所有所需的方法都已经封装到 Cent 库中，你直接使用即可。针对 PHP、GO、Ruby、NodeJs等常用开发语言，同样有官方 HTTP API clients 提供，可以直接使用。
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（八）连接检查</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_08/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_08/</guid>
      <description>
        
          
            当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从他已订阅的频道中读取消息。在有些时候，这不是我们想要的。因此，我们需要连接检查机制。
Centrifugo 有一个选项 connection_lifetime。其默认值为 0，此时，连接检查机制处于关闭状态。当该选项设置的数值大于 0 时，连接检查机制开启，并且这个数值表示成功连接后，连接保持的时长（以秒为单位）。例如，将 connection_lifetime 设置为 60，表示连接保持时长为 60 秒。当连接时长到期时，Javascript 浏览器客户端将向应用程序后端发送 AJAX POST 请求。默认情况下，此请求发送到 URL /centrifuge/refresh。你可以使用 Javascript 客户端配置选项 refreshEndpoint 进行更改。应用服务器需要返回带有连接凭据的 JSON 作为响应。返回相应示例（Python）：
to_return = {&amp;#39;user&amp;#39;: &amp;#34;USER ID&amp;#34;,&amp;#39;timestamp&amp;#39;: &amp;#34;CURRENT TIMESTAMP AS INTEGER&amp;#34;,&amp;#39;info&amp;#39;: &amp;#34;ADDITIONAL CONNECTION INFO&amp;#34;,&amp;#39;token&amp;#39;: &amp;#34;TOKEN BASED ON PARAMS ABOVE&amp;#34;,}return json.dumps(to_return) 你在响应中返回的连接凭据必须与页面初始化时的凭据一致，其中 timestamp 要使用当前的时间戳。然后，Javascript 客户端会将凭据发送到 Centrifugo 服务器，并刷新连接时长。
如果你不想保持该连接，应用程序后端只需要向 AJAX POST 请求返回 403 响应即可。
          
          
        
      </description>
    </item>
    
    <item>
      <title>常用 Git 命令清单</title>
      <link>https://rjguanwen.cn/posts/git/git_03/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/git/git_03/</guid>
      <description>
        
          
            经常记不住 Git 命令，备查！
本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html
一般来说，日常使用只要记住下图 6 个命令即可。
专用名词译名：
Workspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库 一、新建代码库 # 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置 Git 的配置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。
# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &amp;#34;[NAME]&amp;#34;$ git config [--global] user.email &amp;#34;[EMAIL ADDRESS]&amp;#34; 三、增加/删除文件 # 添加指定文件到暂存区$ git add [file1] [file2] .
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（七）Server HTTP API</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_07/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_07/</guid>
      <description>
        
          
            HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。
Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.rjguanwen.cn，那么 API 地址则是 https://centrifugo.rjguanwen.cn/api/。
当使用 HTTP API 时，你需要做的是向正确的地址发送正确构造的 POST 请求。
API 请求是一个 POST application/json 请求，指令包含在请求体，并带有一个附加的header X-API-Sign。请求体是 JSON 结构，其中包含了你需要执行的指令，指令可以是单条也可以是多条。
X-API-Sign 标头是基于 Centrifugo 密钥和要发送的 JSON 正文的 SHA-256 HMAC 字符串。该字符串主要用于 Centrifugo 对请求进行验证，以防假冒。在大多数情况下，你可以使用防火墙规则保护 Centrifugo API 端点，并且在 Centrifugo 启动时使用 --api_insecure 选项禁用验证检查。在此模式下，你使用 HTTP API 只需要发送 POST 请求，而不需要额外的 X-API-Sign 标头。
请求体是 JSON 对象，包括两个属性：method 和 params：
# 一条指令command = json.dumps({&amp;#34;method&amp;#34;: &amp;#34;publish&amp;#34;,&amp;#34;params&amp;#34;: {&amp;#34;channel&amp;#34;: &amp;#34;news&amp;#34;, &amp;#34;data&amp;#34;:{}}})# 多条指令command = json.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（六）引擎（Engines）</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_06/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_06/</guid>
      <description>
        
          
            Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。
Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Memory 引擎只支持一个 Centrifugo 节点，而 Redis 引擎支持多节点部署。可以通过配置文件中的 engine 属性来设置 Centrifugo 使用的引擎，也可以在启动命令中通过 engine 参数指定：
centrifugo --config=config.json --engine=redis 也可以在配置文件中指定：
{...&amp;#34;engine&amp;#34;: &amp;#34;redis&amp;#34;} Memory engine 只支持一个节点，所有信息存储在服务器内存中。
优点 速度快 简单，不需要安装 Redis 缺点 无法扩展节点 Redis engine 支持 Centrifugo 在多服务器伸缩部署，使用 Redis 作为消息路由，状态信息及历史数据保存在 Redis 内存数据库中，内部节点之间的通讯通过 Redis 的发布/订阅机制来进行通信。同时，此模式支持 API 命令排队。
Redis 最低版本要求为 v3.2.0
与 Redis 引擎相关的配置选项如下：
redis_host (string, default &amp;quot;127.0.0.1&amp;quot;) redis_port (int, default 6379) redis_url (string, default &amp;quot;&amp;quot;): optional Redis connection URL redis_password (string, default &amp;quot;&amp;quot;) redis_db (int, default 0): number of Redis db to use redis_tls (boolean, default false): enable Redis TLS connection (new in v2.
          
          
        
      </description>
    </item>
    
    <item>
      <title>上传本地文件到git</title>
      <link>https://rjguanwen.cn/posts/git/git_02/</link>
      <pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/git/git_02/</guid>
      <description>
        
          
            1、创建本地仓库 cd 到相应文件夹
仓库初始化：
git init 将文件添加到仓库： git add . 提交文件到仓库： git commit -m &amp;#34;xxxxxxx&amp;#34; 2、关联 github 仓库 添加远程仓库： git remote add origin https://github.com/rjguanwen/xxxx.git 合并本地内容与远程内容： git pull --rebase origin master 3、上传本地内容 git push -u origin master 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（三）安装与启动</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_03/</link>
      <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_03/</guid>
      <description>
        
          
            一、下载安装程序 Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方便的编译为各个平台的执行程序。Centrifugo 安装首先根据操作系统获取最新版本的安装程序（lastest release）。
二、生成配置文件 Centrifugo 运行需要依赖配置文件，最小化的配置文件可以通过命令自动生成：
./centrifugo genconfig以上命令，会在当前目录生成一个 config.json 文件，其中包含自动生成的 secret key，你可以根据自己的喜好对其进行修改。
三、运行 Centerfugo ./centrifugo --config=config.json四、检查配置文件 ./centrifugo checkconfig --config=config.json当配置文件出现问题时，可以使用该命令检查。
五、Linux 安装包及 Docker 镜像 参考 RPM and DEB packages 及 Docker image
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（二）基本使用</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_02/</link>
      <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_02/</guid>
      <description>
        
          
            Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。
基本运行框架：
Centrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifugo。当然，也可以只有客户端和 Centrifugo。基本使用流程如下：
下载并安装
下载并安装Centrifugo，推荐使用 docker 方式。安装教程
配置运行
创建基础配置文件，设置 token_hmac_secret_key(or token_rsa_public_key) 和 api_key，然后运行Centrifugo。配置文件（config.json）可以通过命令自动创建：
./centrifugo genconfig 关键配置项
在后端应用程序配置文件中设置三个变量：Centrifugo secret、Centrifugo API Key 以及 Centrifugo API address。Centrifugo API address 默认为 http://localhost:8000/api。Centrifugo secret 和 Centrifugo API Key 是关键信息，不能泄露到客户端。
连接到 Centrifugo
根据客户端语言下载相应的客户端库（支持的客户端库列表）。客户端库中有连接到 Centrifugo 的方法。在连接时，客户端需要提供令牌（Token JWT）。令牌的生成应该在应用程序后端进行，然后提供给客户端，可以考虑在页面模板上下文中传递令牌给客户端或者提供令牌获取服务供已登录的客户端调用。令牌的生成需要依赖 Centrifugo secret。 客户端库一般都有 setToken 方法供使用。注意：对于 RSA 令牌，需要使用私钥生成 JWT。（JWT生成方法）
Centrifugo v2.3.0 之后，可以不使用 JWT 进行连接认证，参见 proxying to backend
频道订阅
客户端连接到 Centrifugo 后，即可根据需要订阅相关的频道（Channel）。所有的客户端库都提供了处理所订阅频道（Channel）消息的方法。
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（五）频道（Channel）</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_05/</link>
      <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_05/</guid>
      <description>
        
          
            频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到本频道的消息、用户订阅/取消订阅的消息等等。同样，客户端也需要订阅频道来获取频道的状态（presence）和历史消息。
频道的生命周期比较短暂，不需要显式的去声明。当第一个客户端进行订阅时，Centrifugo 会自动创建相应频道。当最后一个客户端取消订阅时，频道会立即自动被销毁。
频道的命名规则 频道以字符串为标识，由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$），默认最大长度为255，如需修改可以通过配置文件中的 channel_max_length 参数进行调整。
以下几个符号是 Centrifugo 的内部保留符号：
: - 命名空间分隔符 $ - 私有频道前缀 # - 用户频道分隔符 * - 保留字符 &amp;amp; - 保留字符 / - 保留字符 **命名空间分隔符（:）：**如果频道名称为 public:chat，该频道的配置信息将使用 public 命名空间的配置参数设置。
**私有频道前缀（$）：**如果频道名称以 $ 开头，则意味着该频道为私有频道。订阅私有频道必须通过应用程序后端签名。
**用户频道分隔符（#）：**该字符用于创建用户专属频道，而无需向后端Web应用程序发送POST请求。例如，频道名 news#42，表示只有 ID 为 42 的用户可以订阅该频道。客户端在连接 Centrifugo 时需要提供 Token，其中包含了 user ID，因此 Centrifugo 清楚每个客户端的 user ID。另外，用户频道可以支持多个 user ID，user ID 之间通过逗号分隔，例如 dialog#42,43。此种类型的频道适用于固定用户，例如用户个人消息通道、确定用户之间的对话通道，一旦需要动态用户访问频道，此频道类型就不合适了。
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（四）配置文件说明</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_04/</link>
      <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_04/</guid>
      <description>
        
          
            Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。
通过 ./centrifugo -h 命令，可以查看所有的可用选型，如下：
Centrifugo – real-time messaging serverUsage:[flags] [command]Available Commands:checkconfig Check configuration filegenconfig Generate simple configuration file to start withhelp Help about any commandversion Centrifugo version informationFlags:-a, --address string interface address to listen on 服务的地址--admin enable admin web interface 是否开启admin的管理界面--admin_insecure use insecure admin mode – no auth required for admin socket admin安全验证, 节点: /, 可直接访问admin管理界面, 默认为false, 登录admin需要admin_password, 反之可直接登录--api_insecure use insecure API mode 后台推送安全验证, 节点: /api.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Centrifugo（一）简介</title>
      <link>https://rjguanwen.cn/posts/centrifugo/centrifugo_01/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/centrifugo/centrifugo_01/</guid>
      <description>
        
          
            Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。
提供基于频道的发布/订阅（PUB/SUB）模式。
容易和现有系统集成– 不改变已有后端情况下为系统提供实时通信能力。
HTTP API 和已有后端通信 . API clients for Python, Ruby, PHP, Go, NodeJS。
浏览器可以通过SockJS或者纯粹Websocket协议和centrifugal通信。 提供 iOS和Android平台SDK。
采用Redis实现分布式部署，也支持使用Memory引擎单机简单部署。
SHA-256 HMAC连接认证和隐私保护。
多种类型的频道 – 私有, 用户限制，客户端限制。
通过名字空间灵活配置频道。
支持即时消息和历史消息。
支持用户加入/离开消息。
网络重连后可以恢复消息。
内置管理界面，提供多种计量(Metrics)。
可用于WebRTC信令服务器。
多种部署手段(docker 镜像, RPM/DEB 包, Nginx 配置, TLS certificates)。
MIT license。
基本运行框架：
​ Centrifugo 作为独立服务器运行，可以处理来自应用程序用户的持久连接。应用的前端和后端可以基于任何语言进行开发。你的客户端使用应用程序后端提供的令牌(Token JWT)连接到 Centrifugo，并订阅频道（Channel）。当有事件发生时，后端应用可以使用 Centrifugo 的 API 发布消息到相关 Channel。随后，消息会被投递到所有订阅本 Channel 的客户端。
项目地址：https://github.com/centrifugal/centrifugo
          
          
        
      </description>
    </item>
    
    <item>
      <title>git错误解决</title>
      <link>https://rjguanwen.cn/posts/git/git_01/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rjguanwen.cn/posts/git/git_01/</guid>
      <description>
        
          
            pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull，此时在较新的git版本上会报错。因为git认为两个仓库可能不是同一个，报错是为了防止开发者上传错误。
解决办法： 在 pull 命令的最后增加--allow-unrelated-histories
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
