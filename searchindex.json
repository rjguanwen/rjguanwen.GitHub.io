{"categories":[{"title":"Centrifugo","uri":"https://rjguanwen.cn/categories/centrifugo/"},{"title":"GIT","uri":"https://rjguanwen.cn/categories/git/"},{"title":"GOLANG","uri":"https://rjguanwen.cn/categories/golang/"},{"title":"杂七杂八","uri":"https://rjguanwen.cn/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"系统架构","uri":"https://rjguanwen.cn/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"title":"诗词","uri":"https://rjguanwen.cn/categories/%E8%AF%97%E8%AF%8D/"}],"posts":[{"content":" 什么是ADR ADR（Architecture Decision Records）即架构决策记录。\n架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求进行的选择设计。软件架构决策需要在软件质量属性、成本、时间以及其他各种因素之间，做出正确的权衡。架构决策记录（ADR） 是跟踪软件设计选择的一种方法，其应能向项目经理、架构师、开发人员及软件的其他利益相关者，清楚阐明选择何种解决方案以及为此做出的权衡。\n架构决策记录记啥？ 架构决策记录（ADR）首先要解决的基本问题：“我们做了什么决策？”、“为什么这样决策？”，稍次要的问题包括：“我们还考虑过哪些解决方案？”、“为什么没有采用？”等。\n架构决策记录的作用  可以作为和开发人员进行沟通的工具，说明应遵循的重要架构原则\n 当开发人员对架构背后的逻辑提出质疑时，使团队成员能够“就事论事”，提高效率。（如果事实表明你的决策站不住脚，便应虚心接受批评，改正架构）\n 向领导和利益相关者说明这样构建软件的确切原因（比如，采用某种较为昂贵的硬件或软件的必要性等）\n 要把项目移交给下任架构师时，保持架构设计的有序传承\n 如果相关条件发生变化，需要对决策重新评估时，它可以作为一个起点\n 架构决策记录也会倒逼架构师在进行架构决策时更严谨，有助于确保基础的扎实稳固\n  架构决策记录的组成部分 每个架构决策至少有 6 部分组成：标题、时间、状态（Status）、上下文（Context）、决策（Decision）、后果（Consequences）。\n 标题：按数字顺序编号，简要描述架构决策内容\n 时间：在标题下一行，记录架构决策做出的日期，如 日期：2020年2月28日\n 状态：表示本架构决策当前所处的状态，可选项包括：\n 提议：决策已被提出讨论，但是利益相关方尚未达成一致。\n 公认：决策已讨论通过并达成一致。\n 已取代：因条件变化，已有新的架构决策取代本决策。此时需要给出新决策链接。\n 已弃用：本架构决策已撤销，不再使用。\n  上下文：架构决策相关的背景及决策原因。本部分的语言应该是价值中立的，只用于描述事实\n 决策：本部分简洁明了的描述我们最终确定的架构决策\n 后果：本部分描述应用决策后产生的影响，所有的影响都应该列在这里，包括“积极的”、“中性的”与消极的”\n  其他关键问题  架构决策按照顺序和数字编号，不要打乱顺序。\n 已记录的架构决策不应该被删除，如果被取代掉或已不符合当前情况，请将其标记为 已取代 或 已弃用\n  一个架构决策记录示例 1. 使用 ssh key 替换用户名密码方式登录 日期: 2019年11月12日 状态： 公认 上下文： 当前我们使用的是用户名、密码方式进行服务器登录，存在以下问题 安全性问题，密码面临被破解的风险； 易用性问题，无法使用 config 记录密码，可以使用第三方软件解决，如，SecureCRT，ZOC7； 无法充分使用 local terminal，如 iTerm2； 参考: SSH: passwords or keys? https://lwn.net/Articles/369703/ Why is SSH key authentication better than password authentication? https://superuser.com/questions/303358/why-is-ssh-key-authentication-better-than-password-authentication Why is using an SSH key more secure than using passwords? https://security.stackexchange.com/questions/69407/why-is-using-an-ssh-key-more-secure-than-using-passwords 决策： 禁用用户名、密码登录，使用 ssh key 进行登录 后果： 团队成员使用新方式需要适应； key 的管理需要统一（需要引入堡垒机）。  ","id":0,"section":"posts","summary":"什么是ADR ADR（Architecture Decision Records）即架构决策记录。 架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求","tags":["技术"],"title":"架构决策记录（ADR）","uri":"https://rjguanwen.cn/2020/02/adr/","year":"2020"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，我们将使用前面章节中讲到的 Redis engine。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;首先，我们需要有一个处在运行状态的 Redis 服务器。然后，我们可以一次启动三个 Cetrifugofu 服务节点：\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;打开命令行窗口，启动第一个节点：\n centrifugo --config=config.json --port=8000 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;如果 Redis 和 Centrifugo 运行在同一台机器，并且使用了默认的端口号，上面命令中的 redis_host 与 redis_port 选项可以省略。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;然后打开一个新的命令行窗口，启动第二个节点：\n centrifugo --config=config.json --port=8001 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;此命令中，我们指定了一个新的端口 8001，以防与节点一出现端口冲突。如果你的两个节点不在一台机器上，则不存在该问题。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;接下来再次开启一个新的命令行窗口，启动第三个节点：\n centrifugo --config=config.json --port=8002 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;现在你已经拥有了三个 Centrifugo 实例，分别运行在 8000、8001、8002 端口，客户端可以选择连接任何一个实例。同样，你也可以发送 API 请求到任何一个节点。这三个节点通过 Redis 的 PUB/SUB 机制实现消息共享。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;多个节点之间的负载均衡可以通过 Nginx 实现。要非常注意的一点是，如果你的客户端使用了 SockJS 连接到 Centrifugo 节点，那么接下来的该客户端的请求只能路由到同一节点，因为该节点保存了客户端的会话信息。而使用 websocket 则不存在该问题。\nRedis 分片\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;从 V1.6.0 开始 Centrifugo 内置了对 Redis 分片的支持。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;该功能防止 Redis 在大型的 Centrifugo 应用中成为性能瓶颈。Redis 是单线程服务器，它速度非常快，但是当你的 Redis CPU 使用率接近 100% 的时候，分片可以帮助你的应用程序实现扩展。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;目前，Centrifugo 支持基于逗号的简单方法来配置 Redis 分片。\n示例一（基于本机运行的两个 Redis 分片来启动 Centrifugo）：\n centrifugo --config=config.json --engine=redis --redis_port=6379,6380  示例二（基于运行在不同主机上的 Reids 实例来启动 Centrifugo）：\n centrifugo --config=config.json --engine=redis --redis_host=192.168.1.34,192.168.1.35  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;启用分片后，Centrifugo 将使用一致性哈希算法在已配置的 Redis 实例上传播频道和历史/状态信息。\nKeyDB engine\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo Redis engine 可与 KeyDB 无缝协作，KeyDB 服务器与 Reids 兼容，并且提供其他一些附加功能。此功能为实验功能，不保证未来版本仍然与 KeyDB 兼容。\n","id":1,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，","tags":["技术","Centrifugo"],"title":"Centrifugo（九）使用 Redis 实现伸缩","uri":"https://rjguanwen.cn/2019/12/centrifugo_09/","year":"2019"},{"content":"Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本文主要描述如何针对不同的动作（actions）生成令牌及签名。如果你使用 Python，那么所有所需的方法都已经封装到 Cent 库中，你直接使用即可。针对 PHP、GO、Ruby、NodeJs等常用开发语言，同样有官方 HTTP API clients 提供，可以直接使用。\n","id":2,"section":"posts","summary":"Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026e","tags":["技术","Centrifugo"],"title":"Centrifugo（十）令牌和签名","uri":"https://rjguanwen.cn/2019/12/centrifugo_10/","year":"2019"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从他已订阅的频道中读取消息。在有些时候，这不是我们想要的。因此，我们需要连接检查机制。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 有一个选项 connection_lifetime。其默认值为 0，此时，连接检查机制处于关闭状态。当该选项设置的数值大于 0 时，连接检查机制开启，并且这个数值表示成功连接后，连接保持的时长（以秒为单位）。例如，将 connection_lifetime 设置为 60，表示连接保持时长为 60 秒。当连接时长到期时，Javascript 浏览器客户端将向应用程序后端发送 AJAX POST 请求。默认情况下，此请求发送到 URL /centrifuge/refresh。你可以使用 Javascript 客户端配置选项 refreshEndpoint 进行更改。应用服务器需要返回带有连接凭据的 JSON 作为响应。返回相应示例（Python）：\n to_return = { 'user': \u0026quot;USER ID\u0026quot;, 'timestamp': \u0026quot;CURRENT TIMESTAMP AS INTEGER\u0026quot;, 'info': \u0026quot;ADDITIONAL CONNECTION INFO\u0026quot;, 'token': \u0026quot;TOKEN BASED ON PARAMS ABOVE\u0026quot;, } return json.dumps(to_return)  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;你在响应中返回的连接凭据必须与页面初始化时的凭据一致，其中 timestamp 要使用当前的时间戳。然后，Javascript 客户端会将凭据发送到 Centrifugo 服务器，并刷新连接时长。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;如果你不想保持该连接，应用程序后端只需要向 AJAX POST 请求返回 403 响应即可。\n","id":3,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从","tags":["技术","Centrifugo"],"title":"Centrifugo（八）连接检查","uri":"https://rjguanwen.cn/2019/12/centrifugo_08/","year":"2019"},{"content":" 经常记不住 Git 命令，备查！\n本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n一般来说，日常使用只要记住下图 6 个命令即可。\n专用名词译名：\nWorkspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库  一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]  二、配置 Git 的配置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026quot;[NAME]\u0026quot; $ git config [--global] user.email \u0026quot;[EMAIL ADDRESS]\u0026quot;  三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]  四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...  五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]  六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]  七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\u0026quot;提交说明\u0026quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \u0026quot;@{0 day ago}\u0026quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog  八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all  九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop  十、其他 # 生成一个可供发布的压缩包 $ git archive  ","id":4,"section":"posts","summary":"经常记不住 Git 命令，备查！ 本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/gi","tags":["技术","GIT"],"title":"常用 Git 命令清单","uri":"https://rjguanwen.cn/2019/12/git_03/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。\n Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.rjguanwen.cn，那么 API 地址则是 https://centrifugo.rjguanwen.cn/api/。\n 当使用 HTTP API 时，你需要做的是向正确的地址发送正确构造的 POST 请求。\n API 请求是一个 POST application/json 请求，指令包含在请求体，并带有一个附加的header X-API-Sign。请求体是 JSON 结构，其中包含了你需要执行的指令，指令可以是单条也可以是多条。\n X-API-Sign 标头是基于 Centrifugo 密钥和要发送的 JSON 正文的 SHA-256 HMAC 字符串。该字符串主要用于 Centrifugo 对请求进行验证，以防假冒。在大多数情况下，你可以使用防火墙规则保护 Centrifugo API 端点，并且在 Centrifugo 启动时使用 --api_insecure 选项禁用验证检查。在此模式下，你使用 HTTP API 只需要发送 POST 请求，而不需要额外的 X-API-Sign 标头。\n 请求体是 JSON 对象，包括两个属性：method 和 params：\n# 一条指令 command = json.dumps({ \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;:{}} }) # 多条指令 command = json.dumps([ { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;1\u0026quot;}} }, { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;2\u0026quot;}} }, ])  Centrifugo 已经提供了一些编程语言的官方 API client（API libraries）以方便调用 HTTP API。但是，你也可以不使用官方提供的 API client，而是自己编写程序发送请求，这样做也并不麻烦，而且可以减少你的应用程序的依赖。以 Python（使用 requests 库发送请求）为例：\nimport json import requests from cent.core import generate_api_sign commands = [ { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;docs\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;1\u0026quot;}} } ] encoded_data = json.dumps(commands) # 使用官方库中的方法来生成标识 sign = generate_api_sign('very-long-secret-key', encoded_data) headers = {'Content-type': 'application/json', 'X-API-Sign': sign} r = requests.post(\u0026quot;https://centrifugo.rjguanwen.cn/api/, data=encoded_data, headers=headers) print r.json()   \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在上面的代码中，我们使用了官方提供的 Python 语言的 Cent 库中的方法来生成标识（sign）。你也可以自己构建标识。在上例中，commands 是一个数组，可以包含多条指令。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;我们可用的指令包括：publish、broadcast、unsubscribe、presence、history、disconnect、channels、stats、node。\npublish \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;publish 指令用来向频道发送消息。publish 方法的 params 是一个 JSON 对象，至少包含两个 KEY ：channel 和 data。从version 0.2.0之后，可以选择将客户端ID client 包含在 publish 指令中。\n{ \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;hello\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;long-unique-client-id\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot; }  broadcast \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;与 publish 基本类似，不过可以同时发布一条消息到多个渠道。\n{ \u0026quot;method\u0026quot;: \u0026quot;broadcast\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channels\u0026quot;: [\u0026quot;CHANNEL_1\u0026quot;, \u0026quot;CHANNEL_2\u0026quot;], \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;Hello\u0026quot; } } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;broadcast 指令同样可以包含 client 参数。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本指令会将消息发送到所有指定队列直到第一个错误发生。当错误发生时，错误信息会以响应的方式返回，并且停止消息的继续发布。当使用 Redis API 时，错误信息无法返回，而是会记录日志。\nunsubscribe \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;unsubscribe 用来从渠道取消用户的订阅。params 包括两个 KEY：channel、user。\n \u0026quot;method\u0026quot;: \u0026quot;unsubscribe\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot;, \u0026quot;user\u0026quot;: \u0026quot;USER ID\u0026quot; }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;unsubscribe\u0026quot; }  disconnect \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;disconnect 指令用来通过 ID 断开用户连接。params 包含一个 KEY：user。\n{ \u0026quot;method\u0026quot;: \u0026quot;disconnect\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;USER ID\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;disconnect\u0026quot; }  presence \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;presence 指令用来获取渠道的状态信息（当前订阅本渠道的所有客户端）。params 包含一个 KEY：channel。\n{ \u0026quot;method\u0026quot;: \u0026quot;presence\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;e5ee0ab0-fde1-4543-6f36-13f2201adeac\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;e5ee0ab0-fde1-4543-6f36-13f2201adeac\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } } } }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;presence\u0026quot; }  history \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;history 指令用来获取渠道的历史信息（发送到本渠道的最近的消息列表）。params 包含一个 KEY：channel。\n{ \u0026quot;method\u0026quot;: \u0026quot;history\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: [ { \u0026quot;uid\u0026quot;: \u0026quot;8c5dca2e-1846-42e4-449e-682f615c4977\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;1445536974\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;world\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot; }, { \u0026quot;uid\u0026quot;: \u0026quot;63ecba35-e9df-4dc6-4b72-a22f9c9f486f\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;1445536969\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;hello\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot; } ] }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;history\u0026quot; }  channels \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;channels 指令用来获取活动渠道列表（拥有至少一个订阅者）。\n{ \u0026quot;method\u0026quot;: \u0026quot;channels\u0026quot;, \u0026quot;params\u0026quot;: {} }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;: [ \u0026quot;$public:chat\u0026quot;, \u0026quot;news\u0026quot;, \u0026quot;notifications\u0026quot; ] }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;channels\u0026quot; }  stats \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;stats 指令用来获取正在运行的 Centrifugo 节点的统计信息。\n \u0026quot;method\u0026quot;: \u0026quot;stats\u0026quot;, \u0026quot;params\u0026quot;: {}  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;: { \u0026quot;nodes\u0026quot;: [ { \u0026quot;uid\u0026quot;: \u0026quot;6045438c-1b65-4b86-79ee-0c35367f29a9\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;MacAir.local_8000\u0026quot;, \u0026quot;num_goroutine\u0026quot;: 21, \u0026quot;num_clients\u0026quot;: 0, \u0026quot;num_unique_clients\u0026quot;: 0, \u0026quot;num_channels\u0026quot;: 0, \u0026quot;started_at\u0026quot;: 1445536564, \u0026quot;gomaxprocs\u0026quot;: 1, \u0026quot;num_cpu\u0026quot;: 4, \u0026quot;num_msg_published\u0026quot;: 0, \u0026quot;num_msg_queued\u0026quot;: 0, \u0026quot;num_msg_sent\u0026quot;: 0, \u0026quot;num_api_requests\u0026quot;: 0, \u0026quot;num_client_requests\u0026quot;: 0, \u0026quot;bytes_client_in\u0026quot;: 0, \u0026quot;bytes_client_out\u0026quot;: 0, \u0026quot;memory_sys\u0026quot;: 7444728, \u0026quot;cpu_usage\u0026quot;: 0 } ], \u0026quot;metrics_interval\u0026quot;: 60 } }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;stats\u0026quot; }  node \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;node 指令用来获取单个 Centrifugo 节点的信息。\n{ \u0026quot;method\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;params\u0026quot;: {} }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;:{ \u0026quot;uid\u0026quot;:\u0026quot;c3ceab87-8060-4c25-9cb4-94eb9db7899a\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;MacAir.local_8000\u0026quot;, \u0026quot;num_goroutine\u0026quot;:14, \u0026quot;num_clients\u0026quot;:0, \u0026quot;num_unique_clients\u0026quot;:0, \u0026quot;num_channels\u0026quot;:0, \u0026quot;started_at\u0026quot;:1455450238, \u0026quot;gomaxprocs\u0026quot;:4, \u0026quot;num_cpu\u0026quot;:4, \u0026quot;num_msg_published\u0026quot;:0, \u0026quot;num_msg_queued\u0026quot;:0, \u0026quot;num_msg_sent\u0026quot;:0, \u0026quot;num_api_requests\u0026quot;:3, \u0026quot;num_client_requests\u0026quot;:0, \u0026quot;bytes_client_in\u0026quot;:0, \u0026quot;bytes_client_out\u0026quot;:0, \u0026quot;memory_sys\u0026quot;:0, \u0026quot;cpu_usage\u0026quot;:0 } }, \u0026quot;error\u0026quot;:null, \u0026quot;method\u0026quot;:\u0026quot;node\u0026quot; }  ","id":5,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。 Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.","tags":["技术","Centrifugo"],"title":"Centrifugo（七）Server API","uri":"https://rjguanwen.cn/2019/12/centrifugo_07/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Memory 引擎只支持一个 Centrifugo 节点，而 Redis 引擎支持多节点部署。可以通过配置文件中的 engine 属性来设置 Centrifugo 使用的引擎，也可以在启动命令中通过 engine 参数指定：\ncentrifugo --config=config.json --engine=redis  也可以在配置文件中指定：\n{ ... \u0026quot;engine\u0026quot;: \u0026quot;redis\u0026quot; }  Memory engine 只支持一个节点，所有信息存储在服务器内存中。\n 优点\n 速度快\n 简单，不需要安装 Redis\n  缺点\n 无法扩展节点\n   Redis engine \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;支持 Centrifugo 在多服务器伸缩部署，使用 Redis 作为消息路由，状态信息及历史数据保存在 Redis 内存数据库中，内部节点之间的通讯通过 Redis 的发布/订阅机制来进行通信。同时，此模式支持 API 命令排队。\nRedis 最低版本要求为 v3.2.0\n与 Redis 引擎相关的配置选项如下：\n redis_host (string, default \u0026quot;127.0.0.1\u0026quot;)\n redis_port (int, default 6379)\n redis_url (string, default \u0026quot;\u0026quot;): optional Redis connection URL\n redis_password (string, default \u0026quot;\u0026quot;)\n redis_db (int, default 0): number of Redis db to use\n redis_tls (boolean, default false): enable Redis TLS connection (new in v2.0.2)\n redis_tls_skip_verify (boolean, default false): disable Redis TLS host verification (new in v2.0.2)\n redis_sentinels (string, default \u0026quot;\u0026quot;): 以逗号分隔的 Sentinels for HA 列表\n redis_mastr_name (string, default \u0026quot;\u0026quot;): name of Redis master Sentinel monitors\n redis_prefix (string, default \u0026quot;centrifugo\u0026quot;): 用于 Redis 中的频道（channels）与键（keys）的自定义前缀\n redis_sequence_ttl (int, default 0): 设置 Redis 引擎中序列数据的过期时间，以秒为单位。Sequence meta key in Redis is a HASH that contains current sequence number in channel and epoch value. 默认情况下，频道的序列数据是永不过期的。尽管在某下情况下（例如当频道只创建了很短一段时间，之后就不再使用），创建的序列元数据会被保存在内存中，而实际上并没有用。从长远来看，这也可以认为是一种内存泄漏。将本选项设置为一个合适的值，将有助于改善这种状况\n  以上这些选项均可以在配置文件中设置，其中的部分可以在启动命令行参数中直接设置 。\n关于选项 redis_url，该选项用于设置 Redis 的连接字符串，格式为 redis://:password@hostname:port/db。当 --redis_url 参数生效时，--redis_host、--redis_port、--redis_password、--redis_db 参数会被替代掉，不再生效。\n\n// \u0026mdash;\u0026ndash; 以下为老版本内容，未验证是否在新版本仍适用 \u0026mdash;\u0026mdash;-\n --redis_api enable Redis API listener (Redis engine) --redis_api_num_shards int Number of shards for redis API queue (Redis engine) --redis_db string redis database (Redis engine) (default \u0026quot;0\u0026quot;) --redis_host string redis host (Redis engine) (default \u0026quot;127.0.0.1\u0026quot;) --redis_master_name string Name of Redis master Sentinel monitors (Redis engine) --redis_password string redis auth password (Redis engine) --redis_pool int Redis pool size (Redis engine) (default 256) --redis_port string redis port (Redis engine) (default \u0026quot;6379\u0026quot;) --redis_sentinels string Comma separated list of Sentinels (Redis engine) --redis_url string redis connection URL in format redis://:password@hostname:port/db (Redis engine)  说明：\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;1. 当 --redis_url 参数生效时，--redis_host、--redis_port、--redis_password、--redis_db 参数会被替代掉，不再生效。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;2. --redis_api_num_shards 参数必须与 --redis_api 参数配合使用。它将创建 N 个分片队列。该参数主要用于超高并发的消息发布。通过对 API 队列分片降低单队列的压力，提升消息发布效率。如果 --redis_api_num_shards 配置为 5，则将产生 5 个 API 队列分片：\ncentrifugo.api.0 centrifugo.api.1 centrifugo.api.2 centrifugo.api.3 centrifugo.api.4  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当使用此参数时，在客户端侧，你必须指定要将消息发布到哪个 API 队列。为了保证频道中消息的顺序，需要注意在客户端中要将消息按顺序推送到同一 API 队列的同一频道中。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;要想使 Centrifugo 支持通过 Redis engine API listener 发布消息，可以在启动时使用 --redis_api 参数：\n centrifugo --config=config.json --engin=redis --redis_api  如此启动后，可以直接通过 Redis 客户端来发布消息，示例代码（Python）:\nimport redis import json client = redis.Redis() command = { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;events\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;enent\u0026quot;: \u0026quot;message\u0026quot;} } } client.rpush(\u0026quot;centrifugo.api\u0026quot;, json.dumps(command))  RPUSH 命令允许在一个请求中将多条消息推入队列。\n注意：我们通过 RPUSH 将消息推送到了 centrifugo.api，这是 API 队列的默认名称，Centrifugo 实时对其监控。事实上，在 Redis 中，这是一个列表结构。此处，你推送过来的指令会被 Centrifugo 及时处理，但是并不会给客户端响应。如果需要获取响应，那只能使用 HTTP API。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;publish 是最常用的 Centrifugo 指令，Redis_API 的主要目的是降低高频率发布时的 HTTP 开销。同时，也方便各种类型的语言使用 Centrifugo，而不需要依赖 HTTP API client。\n","id":6,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Me","tags":["技术","Centrifugo"],"title":"Centrifugo（六）引擎（Engines）","uri":"https://rjguanwen.cn/2019/12/centrifugo_06/","year":"2019"},{"content":" 1、创建本地仓库  cd 到相应文件夹\n 仓库初始化：\ngit init  将文件添加到仓库：\ngit add .  提交文件到仓库：\ngit commit -m \u0026quot;xxxxxxx\u0026quot;  2、关联 github 仓库 添加远程仓库：\ngit remote add origin https://github.com/rjguanwen/xxxx.git  合并本地内容与远程内容：\ngit pull --rebase origin master  3、上传本地内容 git push -u origin master   ","id":7,"section":"posts","summary":"1、创建本地仓库 cd 到相应文件夹 仓库初始化： git init 将文件添加到仓库： git add . 提交文件到仓库： git commit -m \u0026quot;xxxxxxx\u0026quot; 2、关联 github 仓库 添加远程仓库： git remote add origin https://github.com/rjguanwen/xxxx.git 合并本地","tags":["技术","GIT"],"title":"上传本地文件到git","uri":"https://rjguanwen.cn/2019/12/git_02/","year":"2019"},{"content":" 一、下载安装程序 \u0026ensp;\u0026ensp;Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方便的编译为各个平台的执行程序。Centrifugo 安装首先根据操作系统获取最新版本的安装程序（lastest release）。\n二、生成配置文件 \u0026ensp;\u0026ensp;Centrifugo 运行需要依赖配置文件，最小化的配置文件可以通过命令自动生成：\n./centrifugo genconfig  以上命令，会在当前目录生成一个 config.json 文件，其中包含自动生成的 secret key，你可以根据自己的喜好对其进行修改。\n三、运行 Centerfugo ./centrifugo --config=config.json  四、检查配置文件 ./centrifugo checkconfig --config=config.json  当配置文件出现问题时，可以使用该命令检查。\n五、Linux 安装包及 Docker 镜像 \u0026ensp;\u0026ensp;参考 RPM and DEB packages 及 Docker image\n","id":8,"section":"posts","summary":"一、下载安装程序 \u0026ensp;\u0026ensp;Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方","tags":["技术","Centrifugo"],"title":"Centrifugo（三）安装与启动","uri":"https://rjguanwen.cn/2019/12/centrifugo_03/","year":"2019"},{"content":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。\n基本运行框架：\nCentrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifugo。当然，也可以只有客户端和 Centrifugo。基本使用流程如下：\n 下载并安装\n下载并安装Centrifugo，推荐使用 docker 方式。安装教程\n 配置运行\n创建基础配置文件，设置 token_hmac_secret_key(or token_rsa_public_key) 和 api_key，然后运行Centrifugo。配置文件（config.json）可以通过命令自动创建：\n./centrifugo genconfig  关键配置项\n在后端应用程序配置文件中设置三个变量：Centrifugo secret、Centrifugo API Key 以及 Centrifugo API address。Centrifugo API address 默认为 http://localhost:8000/api。Centrifugo secret 和 Centrifugo API Key 是关键信息，不能泄露到客户端。\n 连接到 Centrifugo\n根据客户端语言下载相应的客户端库（支持的客户端库列表）。客户端库中有连接到 Centrifugo 的方法。在连接时，客户端需要提供令牌（Token JWT）。令牌的生成应该在应用程序后端进行，然后提供给客户端，可以考虑在页面模板上下文中传递令牌给客户端或者提供令牌获取服务供已登录的客户端调用。令牌的生成需要依赖 Centrifugo secret。 客户端库一般都有 setToken 方法供使用。注意：对于 RSA 令牌，需要使用私钥生成 JWT。（JWT生成方法）\nCentrifugo v2.3.0 之后，可以不使用 JWT 进行连接认证，参见 proxying to backend\n 频道订阅\n客户端连接到 Centrifugo 后，即可根据需要订阅相关的频道（Channel）。所有的客户端库都提供了处理所订阅频道（Channel）消息的方法。\n 消息推送\n以上完成后，当用户打开应用程序的相关页面时，客户端会成功连接到 Centrifugo 并订阅一个或多个频道。如果你想向订阅特定频道的用户发送实时消息，例如：有人发布了新评论、部分商品打折促销、某个业务按钮被按下等，可以通过 Centrifugo HTTP API 来完成，官方针对不同的编程语言提供了一些 API 库（API libraries），使用这些库可以方便的发布消息到指定的频道（Channel）。当然，你也可以根据API 描述编写自己的 API 库。Centrifugo 也支持 GRPC API。发布到频道的消息会被投递到订阅相应频道的客户端。\n 生产环境安装包\n为了方便在生产环境中安装 Centrifugo，官方提供了 Docker 镜像、rpm 包以及 deb 包。\n 监控\n不用忘记对 Centrifugo 设置进行监控。参考资料\n 详细参考资料地址。\n  ","id":9,"section":"posts","summary":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。 基本运行框架： Centrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifu","tags":["技术","Centrifugo"],"title":"Centrifugo（二）基本使用","uri":"https://rjguanwen.cn/2019/12/centrifugo_02/","year":"2019"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到本频道的消息、用户订阅/取消订阅的消息等等。同样，客户端也需要订阅频道来获取频道的状态（presence）和历史消息。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道的生命周期比较短暂，不需要显式的去声明。当第一个客户端进行订阅时，Centrifugo 会自动创建相应频道。当最后一个客户端取消订阅时，频道会立即自动被销毁。\n 频道的命名规则\n  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道以字符串为标识，由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$），默认最大长度为255，如需修改可以通过配置文件中的 channel_max_length 参数进行调整。\n以下几个符号是 Centrifugo 的内部保留符号：\n : - 命名空间分隔符\n $ - 私有频道前缀\n # - 用户频道分隔符\n * - 保留字符\n \u0026amp; - 保留字符\n / - 保留字符\n  命名空间分隔符（:）：如果频道名称为 public:chat，该频道的配置信息将使用 public 命名空间的配置参数设置。\n私有频道前缀（$）：如果频道名称以 $ 开头，则意味着该频道为私有频道。订阅私有频道必须通过应用程序后端签名。\n用户频道分隔符（#）：该字符用于创建用户专属频道，而无需向后端Web应用程序发送POST请求。例如，频道名 news#42，表示只有 ID 为 42 的用户可以订阅该频道。客户端在连接 Centrifugo 时需要提供 Token，其中包含了 user ID，因此 Centrifugo 清楚每个客户端的 user ID。另外，用户频道可以支持多个 user ID，user ID 之间通过逗号分隔，例如 dialog#42,43。此种类型的频道适用于固定用户，例如用户个人消息通道、确定用户之间的对话通道，一旦需要动态用户访问频道，此频道类型就不合适了。\n","id":10,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到","tags":["技术","Centrifugo"],"title":"Centrifugo（五）频道（Channel）","uri":"https://rjguanwen.cn/2019/12/centrifugo_05/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过 ./centrifugo -h 命令，可以查看所有的可用选型，如下：\n Centrifugo – real-time messaging server Usage: [flags] [command] Available Commands: checkconfig Check configuration file genconfig Generate simple configuration file to start with help Help about any command version Centrifugo version information Flags: -a, --address string interface address to listen on 服务的地址 --admin enable admin web interface 是否开启admin的管理界面 --admin_insecure use insecure admin mode – no auth required for admin socket admin安全验证, 节点: /, 可直接访问admin管理界面, 默认为false, 登录admin需要admin_password, 反之可直接登录 --api_insecure use insecure API mode 后台推送安全验证, 节点: /api. 默认为 false, 此时访问节点需要api_key. 当设置为 true 后, 任何人都将可以访问此节点 --client_insecure start in insecure client mode 客户端是否需要安全验证, 默认为false, 客户端必须拥有 JWT token 才能访问 -c, --config string path to config file (default \u0026quot;config.json\u0026quot;) --debug enable debug endpoints 是否开启dubug节点, 开启后可访问 /debug/pprof/ 查看一些Centrifugo的网络状态 -e, --engine string engine to use: memory or redis (default \u0026quot;memory\u0026quot;) 消息存储引擎, 默认为内存, 部署多个实例会造成数据不同步, 因此推荐使用 redis --grpc_api enable GRPC API server 是否开启grpc api, 默认使用 http_api -h, --help help for this command --internal_port string custom port for internal endpoints 开启自定义默认端口, 默认为8000, 开启额外的端口为admin访问 --log_file string optional log file - if not specified logs go to STDOUT log输出文件 --log_level string set the log level: debug, info, error, fatal or none (default \u0026quot;info\u0026quot;) log级别 -n, --name string unique node name 命名空间名称, 此空间下的属性会覆盖common部分, 但不会继承 --pid_file string optional path to create PID file -p, --port string port to bind HTTP server to (default \u0026quot;8000\u0026quot;) 服务端口号 --prometheus enable Prometheus metrics endpoint --redis_db int Redis database (Redis engine) --redis_host string Redis host (Redis engine) (default \u0026quot;127.0.0.1\u0026quot;) --redis_master_name string name of Redis master Sentinel monitors (Redis engine) --redis_password string Redis auth password (Redis engine) --redis_port string Redis port (Redis engine) (default \u0026quot;6379\u0026quot;) --redis_sentinels string comma-separated list of Sentinel addresses (Redis engine) --redis_tls enable Redis TLS connection --redis_tls_skip_verify disable Redis TLS host verification --redis_url string Redis connection URL in format redis://:password@hostname:port/db (Redis engine) --tls enable TLS, requires an X509 certificate and a key file --tls_cert string path to an X509 certificate file --tls_key string path to an X509 certificate key  注意：所有的命令行选项都可以用同样的名字在配置文件中进行设置。此外，所有的可用选项也都可以设置到环境变量中，格式为 CENTRIFUGO_\u0026lt;OPTION_NAME\u0026gt;。\nversion centrifugo version  JSON file Centrifugo 启动时依赖配置文件。最简单的配置文件如下：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; }  必须的两个选项为 token_hmac_secret_key 和 api_key。token_hmac_secret_key 用来检查 JWT 签名。api_key 用于 Centrifugo API 端点授权。在生产环境你应该将这两个参数设置的足够复杂并且避免外泄。唯二的需要知道这两个参数值的只有 Centrifugo 自身和你的应用程序后端。该值被用来生成客户端连接令牌、调用 API 以及订阅私有频道。\nTOML file Centrifugo 同样支持 TOML 格式的配置文件：\ncentrifugo --config=config.toml  config.toml 示例：\ntoken_hmac_secret_key = \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot; api_key = \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; log_level = \u0026quot;debug\u0026quot;  YAML file Centrifugo 同样支持 TOML 格式的配置文件，config.yaml：\ntoken_hmac_secret_key: \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot; api_key: \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; log_level: debug  checkconfig command Centrifugo 有专门的命令用来检查配置文件：\ncentrifugo checkconfig --config=config.json  genconfig command centrifugo genconfig -c config.json  该命令会生成最小化的配置文件。\nImportant options 运行 Centrifugo 时可以配置一些最重要的选项：\n- address - 将 Centrifugo 绑定到特定的接口地址（默认为 \u0026quot;\u0026quot;）\n- port - Centrifugo 的绑定端口（默认为 8000）\n- engine - Centrifugo 使用的引擎：memory 或者 redis（默认为 memory） 注意：命令行参数优先级要大于配置文件选项。\nChannel options 频道（channel）是一个实体，客户端可以订阅发布到相应频道的消息。下面几个选项可以控制频道的一些行为：\n publish：允许客户端直接发布消息到频道，而不经过应用程序后端。一般情况下，消息都是由应用程序后端通过 Centrifugo API 发布到 Centrifugo 服务器的。这个参数适用于没有后端或者 demo 的快速构建。需要注意的一点是客户端只有成功订阅了频道之后才能发布消息到该频道。本参数默认值为 false。\n subscribe_to_publish：当 publish 选项启用后，客户端可以发布消息到频道中而无需订阅。使用此选项，客户端会在发布到频道之前自动检查是否已订阅该频道。\n anonymous：该参数允许匿名访问（在连接参数中使用空字符串作为 user ID，JWT token 中 sub 为空）。通常情况下，应用程序的用户都需要登录认证，因此客户端建立连接时可以使用用户名作为唯一标识。如果你需要提供公共的实时消息服务，你可以在相应的频道上开启本参数。本参数默认值为 false。\n presence：是否开启 presence 信息，presence 为当前订阅本频道的客户端信息。本参数默认是为 false，即不开启。\n presence_disable_for_client：（v2.2.3 之后版本有效）presence 在客户端不可用。默认值为 false，即同时允许客户端和服务端 API 访问 presence 信息。\n join_leave：当有用户订阅/取消订阅频道时，是否发送相关信息到频道中。本参数默认值为 false。\n history_size：频道历史消息数量。因为 Centrifugo 将所有的消息存储在内存中，因此限制每个频道保留的历史消息数量是非常重要的。本参数默认值为 0，这意味着频道不会保留历史消息。启用本参数后，Centrifugo 会为命名空间中的每条频道保留指定数量的历史消息，直到消息过期，关于消息过期详见参数 history_lifetime。\n history_lifetime：频道历史消息的过期时间，单位为秒。本参数默认值为 0，这意味着频道不会保留历史消息。如果要保留历史消息，需要同时配置 history_size 与 history_lifetime，并设置合理的参数值。\n history_recover：是否恢复丢失的消息。如果开启本参数，当客户端重新连接时（如因网络原因断线重连），Centrifugo 将试图重新恢复丢失的消息。本参数默认值为 false。这个参数的启用要配合历史消息相关参数（history_size 和 histroy_lifetime），毕竟消息的恢复依靠的是频道历史消息记录。请注意，并非所有实时事件消息都需要开启此功能，因此在需要时请慎重考虑。启用此选项后，你的应用程序需要考虑消息去重。\n history_disable_for_client：（v2.2.3 之后版本有效）历史消息在客户端不可用。默认为 false，即历史消息在客户端与服务端均可用。该参数是否启用不会影响历史消息恢复机制。\n  参数配置示例：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;my-secret-key\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;secret-api-key\u0026quot;, \u0026quot;anonymous\u0026quot;: true, \u0026quot;publish\u0026quot;: true, \u0026quot;subscribe_to_publish\u0026quot;: true, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 300, \u0026quot;history_recover\u0026quot;: true }   namespaces：namespaces 是可选参数，如果设置的话，需要设置成 namespace 数组的形式。通过 namespaces 可以针对 namespace 下的频道配置自定义参数。每个 namespace 都有自己的 name，并且拥有上面所有的针对频道的参数。name 必须唯一，并且由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$）。\n  namespaces 相关配置文件示例：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;very-long-secret-key\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;secret-api-key\u0026quot;, \u0026quot;anonymous\u0026quot;: true, \u0026quot;publish\u0026quot;: true, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 30, \u0026quot;namespaces\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;public\u0026quot;, \u0026quot;publish\u0026quot;: true, \u0026quot;anonymous\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 300, \u0026quot;history_recover\u0026quot;: true }, { \u0026quot;name\u0026quot;: \u0026quot;gossips\u0026quot;, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true } ]  }\n在以上配置下：\n\u0026ensp;\u0026ensp;- 频道 news 将使用全局参数配置。\n\u0026ensp;\u0026ensp;- 频道 public:news 将使用 public 命名空间的参数配置。\n\u0026ensp;\u0026ensp;- 频道 gossips:news 将使用 gossips 命名空间的参数配置。\n注意：频道（channel）相关的选项在命名空间（namespaces）中不存在继承关系。例如，你在配置文件的顶层配置了 presence: true，在命名空间中，频道的 presence 选项不会继承 true，你必须在命名空间中显式的启用。\nAdvanced configuration Centrifugo 还提供了更多的配置选项，一般情况下，你不需要配置他们，使用默认值即可。\n client_channel_limit\nDefault: 128\n设置单个客户端可以拥有的不同频道订阅的最大数量。\n channel_max_length\nDefault: 255 设置频道名称的最大长度。\n client_user_connection_limit\nDefault: 0\n同一用户（不包含匿名用户）连接到 Centrifugo 节点的最大连接数。默认值 0 表示不限制。\n client_request_max_size\nDefault: 65536\n客户端请求的最大允许长度，按字节计。\n client_queue_max_size\nDefault: 10485760\n客户端消息队列的最大大小，以字节计。默认大小为 10mb。（超出长度后缓慢的读取连接会被关闭？）\n client_anonymous\nDefault: false\n是否允许客户端匿名连接。如果设置为 true，则所有客户端可以在没有 JWT 令牌的情况下连接到 Centrifugo。在这种情况下，没有令牌的连接会被视为匿名（user ID 为空），并且只能订阅开启了 anonymous 选项的频道。\n sockjs_heartbeat_delay\nDefault: 25\nSockJS 心跳检测时间间隔，单位为秒。\n websocket_compression\nDefault: fasle 是否开启 websocket 压缩。\n gomaxprocs\nDefault: 0\n默认情况下，Centrifugo 会在所有可用 CPU 内核上执行，本选项可以用来限制 Centrifugo 同时可利用的 CPU 内核数。\n  Advanced endpoint configuration 启动 Centrifugo 后，你会有几个可用的端点（endpoint），如果你没有提供额外的选项，你默认会有 3 个端点。\n Default endpoints\n  主端点是原生的 Websocket 端口，用来支持纯 Websocket 协议的客户端连接：ws://localhost:8000/connection/websocket\nSockJS 端点，用来服务使用 SockJS library 连接的客户端：http://localhost:8000/connection/sockjs\n最后，API 端点，用来发布消息到频道以及执行其他可用的 API 指令：http://localhost:8000/api\n所有的端点默认使用 8000 端口，可以通过 port 选项修改：\n{ \u0026quot;port\u0026quot;: 9000 }  在生产环境中，你的域名将替代上面 URL 中的 localhost。如果你的 Centrifugo 服务器位于代理或者负载均衡服务器之后，则 URL 中可能没有端口号。\n Admin endpoints 启用管理端点：\n{ ... \u0026quot;admin\u0026quot;: true, \u0026quot;admin_password\u0026quot;: \u0026quot;\u0026lt;password\u0026gt;\u0026quot;, \u0026quot;admin_secret\u0026quot;: \u0026quot;\u0026lt;secret\u0026gt;\u0026quot; }  以上配置，使管理端点可用：http://localhost:8000\n通过上面的地址，你可以看到管理界面，通过上面配置的 admin_password 登录。\n Debug endpoints 当 Centrifugo 以 debug 模式启动时，debug 端点将可用。\n{ ... \u0026quot;debug\u0026quot;: true }  端点 URL: http://localhost:8000/debug/pprof/\n通过上面的地址，你可以看到 Centrifugo 实例的内部状态信息，这些信息在故障排除时会非常有用。\n Healthcheck endpoint 使用 health 选项（默认值为 false）来启用健康检查端点，该端点路径为 /health。同样，也可以在启动命令通过标记来启用健康检查端点：\n./centrifugo -c config.json --health  Custom internal ports 我们强烈建议，不要将 API、admin、debug 以及 prometheus 端点暴露到互联网，这些端点被视为内部的：\n API 端点（/api）: 针对 HTTP API 请求\n Admin web interface endpoints（/, /admin/auth, /admin/api）: used by web interface\n Prometheus endpoint(/metrics): 用于以 Prometheus 格式公开服务器指标\n Healthcheck endpoint(/health): 用来进行健康检查\n Debug endpoints(/debug/pprof): 用于检测服务器内部状态\n   这些内部端点，最好使用防火墙保护起来。\n可以通过 internal_port 选项来自定义内部端点的端口：\n{ ... \u0026quot;internal_port\u0026quot;: 9000 }   Disable default endpoints 以下选项在 v2.4.0 版本后有效：websocket_disable、sockjs_disable、api_disable，这些选项默认值均为 true。\n Customize handler endpoinds\n从 Centrifugo v2.2.5 开始，可以自定义 HTTP 处理程序端点，有如下几个选项可用：\n admin_handler_prefix（默认值为 \u0026quot;\u0026quot;）: 控制台 URL 前缀。\n websocket_handler_prefix（默认值为 /connection/websocket）: WebSocket URL前缀。\n sockjs_handler_prefix（默认值为 /connection/sockjs）: SockJS URL 前缀。\n api_handler_prefix（默认值为 /api）: HTTP API URL 前缀。\n prometheus_handler_prefix（默认值为 /metrics）: Prometheus URL 前缀。\n health_handler_prefix（默认值为 /health）: 健康检查 URL 前缀。\n   \n// \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nother options 下面几个参数在新版本中是否仍可使用，未验证\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;connection_lifetime 参数用来设置客户端连接的过期时间，单位为秒。如果该参数设置为0，表示该客户端连接永不过期。\n{ \u0026quot;secret\u0026quot;: \u0026quot;very-long-secret-key\u0026quot;, \u0026quot;connect_lifetime\u0026quot;: 0 }  \n频道（Channel）相关的选项：\nwatch：Centrifugo 会同时发生消息到 admin channel，这些消息可以在 admin 管理界面的 messages tab 下查看。这个参数要慎用，特别是针对消息发布频率比较高的频道，以免超出 admin client 的处理能力。本参数默认值为 fasle。\nhistory_drop_inactive：是否丢弃不活跃的历史消息。本参数可以大幅降低资源消耗（内存、消息传播次数）。简单来说，该参数开启后，Centrifugo 会主动丢弃不需要的历史消息。本参数默认值为 false。\n\n","id":11,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过 ./centrifugo -h 命令，可以查看所有的可用选型，","tags":["技术","Centrifugo"],"title":"Centrifugo（四）配置文件说明","uri":"https://rjguanwen.cn/2019/12/centrifugo_04/","year":"2019"},{"content":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。\n 提供基于频道的发布/订阅（PUB/SUB）模式。\n 容易和现有系统集成– 不改变已有后端情况下为系统提供实时通信能力。\n HTTP API 和已有后端通信 . API clients for Python, Ruby, PHP, Go, NodeJS。\n 浏览器可以通过SockJS或者纯粹Websocket协议和centrifugal通信。 提供 iOS和Android平台SDK。\n 采用Redis实现分布式部署，也支持使用Memory引擎单机简单部署。\n SHA-256 HMAC连接认证和隐私保护。\n 多种类型的频道 – 私有, 用户限制，客户端限制。\n 通过名字空间灵活配置频道。\n 支持即时消息和历史消息。\n 支持用户加入/离开消息。\n 网络重连后可以恢复消息。\n 内置管理界面，提供多种计量(Metrics)。\n 可用于WebRTC信令服务器。\n 多种部署手段(docker 镜像, RPM/DEB 包, Nginx 配置, TLS certificates)。\n MIT license。\n  基本运行框架：\n​ Centrifugo 作为独立服务器运行，可以处理来自应用程序用户的持久连接。应用的前端和后端可以基于任何语言进行开发。你的客户端使用应用程序后端提供的令牌(Token JWT)连接到 Centrifugo，并订阅频道（Channel）。当有事件发生时，后端应用可以使用 Centrifugo 的 API 发布消息到相关 Channel。随后，消息会被投递到所有订阅本 Channel 的客户端。\n项目地址：https://github.com/centrifugal/centrifugo\n","id":12,"section":"posts","summary":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。 提供基于频道的发布/订阅（PUB/SUB）模式。 容易和现有系统集成– 不改变已有后端情况下为系统","tags":["技术","Centrifugo"],"title":"Centrifugo（一）简介","uri":"https://rjguanwen.cn/2019/12/centrifugo_01/","year":"2019"},{"content":"摘抄并总结几条个人认为对提升自我帮助较大的好习惯，希望能坚持！\n\u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\n 心情糟糕时认真清理房间，心情莫名就开始清爽起来。\n 晨起刷牙时问问自己，如果要过好这一天，有什么可改良创造之处。\n 出差、旅行，记得带上一双跑鞋，一身运动服，去陌生城市的清晨跑个步，或许收获新的灵感。\n 睡前半小时远离手机和任何电子设备。\n 戒糖，戒所有含糖饮料，将可口可乐改为零度可乐等无糖甜味饮料。\n 当出现负面情绪和自我否定时，想办法转移自己的负面情绪，听增强自信的音乐，或者看励志书籍/电源。\n 误解或伤害过他人，一定要专门去道歉和解释。\n 每天问问自己，最重要的人，最重要的事情，最重要的目标，到底是什么；对那些不重要的人、事、物，尽可能少分配精力。\n 给人第二次机会，但不要给第三次。圣经上说过：凡第二次犯错者，必有第三次。 受人恩惠后除了说声谢谢，再赠送一件小礼品，可以结识到更亲密的关系。\n 建立自己的日常事项，比如日常写日记，日常有氧健身半小时，用恒定不变的习惯，抵抗人生的无常。会建立自信，缓解焦虑。\n 坚持阅读，家里准备着可以读的书，保证每天有一定的阅读时间，和利用碎片化时间阅读。\n 坚持记账，让你对自己的收入和消费情况充分了解，更有利于帮助你纠正不良消费习惯，管理好自己的财物状况。\n 吃饭不要吃太饱，八分饱更健康。\n 早睡早起，感觉精力充沛的时间更多。\n 洗手间内、公司走廊上不要和别人过多交流。\n 对方正在说话的时候不要插嘴。\n 正式去别人家里一定不要空手去！无论你们关系有多好！\n 使用积极语言： 当你以积极的语言开始陈述，对方也会摆出积极的姿态倾听你的话语。如果你没有自信，不妨抛开带有感情色彩的开场白，平缓地开始叙述。如果因为多余的客气话和谦虚反而让对方认为你没有能力，那就得不偿失了。\n 遇事少抱怨！万事健康第一！\n 宁可鱼死网破，也绝不降低原则与底限。\n 坚持反省： 每天晚上进行一次对自己今天所做事情的冥想，不管做的好还是不好，都去总结分析其缘由。 坚持运动： 无论你多么优秀、多么地与众不同，你都有责任为自己的身体负责。\n 不要说脏话，戒掉口头禅！\n  ","id":13,"section":"posts","summary":"摘抄并总结几条个人认为对提升自我帮助较大的好习惯，希望能坚持！ \u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen","tags":["个人"],"title":"坚持好习惯","uri":"https://rjguanwen.cn/2019/11/good_habits/","year":"2019"},{"content":"数据传输加密流程：\n","id":14,"section":"posts","summary":"数据传输加密流程：","tags":["技术"],"title":"数据加解传输过程","uri":"https://rjguanwen.cn/2019/11/data_translet_safely/","year":"2019"},{"content":"简单记录 go mod 的使用方式：\n 代理配置\n$env:GOPROXY = \u0026quot;https://goproxy.io\u0026quot; 或使用 goproxy.cn\n 初始化\ngo mod init ***，***为你要创建的mod名字，直接为工程名即可\n 自动下载依赖\ngo run *****.go，在执行前会首先查找并下载安装依赖\n 更新旧的 package import 方式，内部依赖也需要增加 mod 名\npackage main import ( api \u0026quot;mymod/api\u0026quot; // mymod 是初始化的 mod 名 \u0026quot;github.com/labstack/echo\u0026quot; ) func main() { e := echo.New() e.GET(\u0026quot;/\u0026quot;, api.MyAPI) e.Logger.Fatal(e.Start(\u0026quot;:1234\u0026quot;)) }  使用 replace 替换无法直接获取的 package\nreplace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u0026gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a )  检查并升级 package\ngo list -m -u all\ngo get -u need-upgrade-package 或者 go get -u\n  常用的命令如下：\n   命令 功能     download 下载依赖包   edit 编辑 go.mod   graph 打印模块依赖图   init 初始化 mod   tidy 拉取缺少的模块，移除不用的模块   vendor 将依赖复制到 vendor 下   verify 验证依赖是否正确   why 解释为什么需要依赖    ","id":15,"section":"posts","summary":"简单记录 go mod 的使用方式： 代理配置 $env:GOPROXY = \u0026quot;https://goproxy.io\u0026quot; 或使用 goproxy.cn 初始化 go mod init ***，***为你要创建的mod名字，直接为工程名即可 自动下载依赖 go run *****.","tags":["技术","GOLANG"],"title":"gomod使用记录","uri":"https://rjguanwen.cn/2019/11/gomod_use/","year":"2019"},{"content":"简单记录 govendor 的使用方式：\n 安装\ngo get -u -v github.com/kardianos/govendor\n 初始化 vendor 目录\ngovendor init\n 添加依赖包到 vendor 目录\ngovendor add +external 或 govendor add +e\n 从 $GOPATH 更新依赖包到 vendor 目录\ngovendor update +vendor\n 删除依赖包\ngovendor remove +vendor\n  常用的命令如下：\n   命令 功能     init 初始化 vendor 目录   list 列出所有依赖包   add 添加包到 vendor 目录   add PKG_PATH 添加指定依赖包到 vendor 目录   update 从 $GOPATH 更新依赖包到 vendor 目录   remove 从 vendor 管理中删除依赖   status 列出 vendor 管理的各个包的状态   fetch 添加或更新包到 vendor 目录   sync 同步，基于已存在的 vendor.json 拉取依赖包   get 类似 go get ，拉取依赖包到 vendor 目录    可用的 Status Types 如下：\n+local (l) packages in your project\n+external (e) referenced packages in GOPATH but not in current project\n+vendor (v) packages in the vendor folder\n+std (s) packages in the standard library\n+excluded (x) external packages explicitly excluded from vendoring\n+unused (u) packages in the vendor folder, but unused\n+missing (m) referenced packages but not found\n+program (p) package is a main package\n+outside +external +missing\n+all +all packages\n注意事项：\n使用 vendor 后，请配置 .gitignore 文件：\n/vendor/* !/vendor/vendor.json  ","id":16,"section":"posts","summary":"简单记录 govendor 的使用方式： 安装 go get -u -v github.com/kardianos/govendor 初始化 vendor 目录 govendor init 添加依赖包到 vendor 目录 govendor add +external 或 govendor add +e 从 $GOPATH 更新依赖包到 vendor 目录 govendor update +vendor 删除依赖包 govendor remove +vendor 常用的命令如","tags":["技术","GOLANG"],"title":"govendor使用记录","uri":"https://rjguanwen.cn/2019/11/govendor_use/","year":"2019"},{"content":" pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull，此时在较新的git版本上会报错。因为git认为两个仓库可能不是同一个，报错是为了防止开发者上传错误。\n解决办法： 在 pull 命令的最后增加--allow-unrelated-histories\n","id":17,"section":"posts","summary":"pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull","tags":["技术","GIT"],"title":"git错误解决","uri":"https://rjguanwen.cn/2019/11/git_01/","year":"2019"},{"content":" 技术的发展非常迅速，对新技术的探索与应用和  ","id":18,"section":"posts","summary":"技术的发展非常迅速，对新技术的探索与应用和","tags":["杂感随笔"],"title":"关于产品与技术的一些想法","uri":"https://rjguanwen.cn/2019/11/any_01/","year":"2019"},{"content":"1.读书不是为了雄辩与驳斥，也不是为了轻信与盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们是在重新整理自己的偏见。\n2.用一套程序保证问题会摆在桌面上，同时确保问题根源会得到剖析，这样才能实现持续的改进。\n3.\n","id":19,"section":"posts","summary":"1.读书不是为了雄辩与驳斥，也不是为了轻信与盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们是在重新整理自己的偏见。 2.用一套程","tags":["句子"],"title":"杂句摘抄","uri":"https://rjguanwen.cn/2019/11/somewords_01/","year":"2019"},{"content":"苦昼短\n【唐】李贺\n飞光飞光，劝尔一杯酒。\n吾不识青天高，黄地厚。\n唯见月寒日暖，来煎人寿。\n食熊则肥，食蛙则瘦。\n神君何在？太一安有？\n天东有若木，下置衔烛龙。\n吾将斩龙足，嚼龙肉，使之朝不得回，夜不得伏。\n自然老者不死，少者不哭。\n何为服黄金、吞白玉？\n谁似任公子，云中骑碧驴？\n刘彻茂陵多滞骨，嬴政梓棺费鲍鱼。\n","id":20,"section":"posts","summary":"苦昼短 【唐】李贺 飞光飞光，劝尔一杯酒。 吾不识青天高，黄地厚。 唯见月寒日暖，来煎人寿。 食熊则肥，食蛙则瘦。 神君何在？太一安有？ 天东有若木，下置","tags":["光阴","诗词"],"title":"苦昼短","uri":"https://rjguanwen.cn/2019/11/art-1/","year":"2019"}],"tags":[{"title":"Centrifugo","uri":"https://rjguanwen.cn/tags/centrifugo/"},{"title":"GIT","uri":"https://rjguanwen.cn/tags/git/"},{"title":"GOLANG","uri":"https://rjguanwen.cn/tags/golang/"},{"title":"个人","uri":"https://rjguanwen.cn/tags/%E4%B8%AA%E4%BA%BA/"},{"title":"光阴","uri":"https://rjguanwen.cn/tags/%E5%85%89%E9%98%B4/"},{"title":"句子","uri":"https://rjguanwen.cn/tags/%E5%8F%A5%E5%AD%90/"},{"title":"技术","uri":"https://rjguanwen.cn/tags/%E6%8A%80%E6%9C%AF/"},{"title":"杂感随笔","uri":"https://rjguanwen.cn/tags/%E6%9D%82%E6%84%9F%E9%9A%8F%E7%AC%94/"},{"title":"诗词","uri":"https://rjguanwen.cn/tags/%E8%AF%97%E8%AF%8D/"}]}