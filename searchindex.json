{"categories":[{"title":"Centrifugo","uri":"https://rjguanwen.cn/categories/centrifugo/"},{"title":"docker","uri":"https://rjguanwen.cn/categories/docker/"},{"title":"gin","uri":"https://rjguanwen.cn/categories/gin/"},{"title":"GIT","uri":"https://rjguanwen.cn/categories/git/"},{"title":"GOLANG","uri":"https://rjguanwen.cn/categories/golang/"},{"title":"Ignite","uri":"https://rjguanwen.cn/categories/ignite/"},{"title":"python","uri":"https://rjguanwen.cn/categories/python/"},{"title":"rasa","uri":"https://rjguanwen.cn/categories/rasa/"},{"title":"redis","uri":"https://rjguanwen.cn/categories/redis/"},{"title":"Superset","uri":"https://rjguanwen.cn/categories/superset/"},{"title":"工具","uri":"https://rjguanwen.cn/categories/%E5%B7%A5%E5%85%B7/"},{"title":"杂七杂八","uri":"https://rjguanwen.cn/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"系统架构","uri":"https://rjguanwen.cn/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"title":"诗词","uri":"https://rjguanwen.cn/categories/%E8%AF%97%E8%AF%8D/"},{"title":"读书","uri":"https://rjguanwen.cn/categories/%E8%AF%BB%E4%B9%A6/"}],"posts":[{"content":" \u0026lt;部分内容借鉴自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\nGartner战略技术趋势（2021-2023） 一、总览 二、2021年 2.1、技术成熟度曲线 2.2、2021战略技术趋势 2021年的十大战略技术趋势，将主要趋势分为“以人为本”，“位置独立性”和“弹性交付”。 以人为本重视技术影响整个生态系统中利益相关方的方式；重点关注人们的行为，经验和隐私将如何变化。位置独立性关注员工，供应商和客户可以在任何地方工作或者使用产品。新冠大流行加速了远程渠道的使用率。分布式云，无处不在的操作以及新的安全性范式推动了这一需求的发展。弹性交付创建了一个技术组织，该组织可以迅速适应以克服新挑战并支持新的运营。其中包括创建可组合的业务架构，并得到AI工程师和超自动化技术的支持。\n2.3、行为互联网（Internet of Behaviors） 行为互联网（IoB）不断涌现，许多技术都在捕获并使用人们日常生活中的“数字尘埃”。IoB汇集了面部识别、位置跟踪和大数据等当前直接关注个人的技术，并将结果数据与现金购买或设备使用等相关的行为事件相关联。\n企业机构使用该数据来影响人的行为。例如为了在疫情期间监控对健康规定的遵守情况，企业机构可以通过使用IoB计算机视觉来查看员工是否戴着口罩或通过热成像来识别发热者。\nGartner预测，到2025年末，全球一半以上的人口将至少参加一项商业或政府的IoB计划。虽然IoB在技术上可成为可能，但社会各界将对各种影响行为的方法展开广泛的伦理和社会学讨论。\n2.4、全面体验（Total Experience） Burke表示：“去年，Gartner将多重体验定义为一种重要的战略科技趋势。而在今年，这一趋势又进一步发展成为全面体验（TX），将多重体验与客户、员工和用户体验相联系。Gartner预计在未来三年中，提供TX的企业机构在关键满意度指标方面的表现将超越竞争对手。”\n由于新冠疫情，移动、虚拟和分布式互动日益盛行，因此企业机构需要有TX策略。TX将改善体验的各个组成部分，实现业务成果的转型。这些相互交织的体验是企业运用创新革命性体验实现差异化，从而从疫情中恢复的关键驱动力。\n2.5、隐私增强计算（Privacy-Enhancing Computation） 随着全球数据保护法规的成熟，各地区首席信息官所面临的隐私和违规风险超过了以往任何时候。不同于常见的静态数据安全控制，隐私增强计算可在确保保密性或隐私的同时，保护正在使用的数据。\nGartner认为，到2025年将有一半的大型企业机构使用隐私增强计算在不受信任的环境和多方数据分析用例中处理数据。企业机构应在开始确认隐私增强计算候选对象时，评估要求个人数据转移、数据货币化、欺诈分析和其他高度敏感数据用例的数据处理活动。\n2.6、分布式云（Distributed Cloud） 分布式云将公有云分布到不同的物理位置，但服务的运营、治理和发展依然由公有云提供商负责。它为具有低延迟、降低数据成本需求和数据驻留要求的企业机构方案提供了一个灵活的环境，同时还使客户的云计算资源能够更靠近发生数据和业务活动的物理位置。\n到2025年，大多数云服务平台至少都能提供一些可以根据需要执行的分布式云服务。Burke先生认为：“分布式云可以取代私有云，并为云计算提供边缘云和其他新用例。它代表了云计算的未来。”\n2.7、随处运营（Anywhere Operations） 随处运营是一种为全球各地客户提供支持、赋能全球各地员工并管理各类分布式基础设施业务服务部署的IT运营模式。它所涵盖的不仅仅是在家工作或与客户进行虚拟互动，还能提供所有五个核心领域的独特增值体验，分别是：协作和生产力、安全远程访问、云和边缘基础设施、数字化体验量化以及远程运营自动化支持。\n到2023年末，40%的企业机构将通过随处运营提供经过优化与混合的虚拟/物理客户与员工体验。\n2.8、网络安全网格（Cybersecurity Mesh） 网络安全网格使任何人都可以安全地访问任何数字资产，无论资产或人员位于何处。它通过云交付模型解除策略执行与策略决策之间的关联，并使身份验证成为新的安全边界。到2025年，网络安全网格将支持超过一半的数字访问控制请求。\nBurke先生认为：“新冠疫情加快了耗时数十年的数字化企业变革过程。我们已经越过了一个转折点，大多数企业机构的网络资产现在都已超出传统的物理和逻辑安全边界。随着随处运营的不断发展，网络安全网状组网将成为从非受控设备安全访问和使用云端应用与分布式数据的最实用方法。”\n2.9、组装式智能企业（Intelligent Composable Business） Burke先生表示：“为了提高效率而建立的静态业务流程非常脆弱，因此在疫情的冲击下变得支离破碎。首席信息官和IT领导者正在努力收拾残局，他们开始了解适应业务变化速度的业务能力有多么重要。”\n智能组合型业务通过获取更好的信息并对此做出更敏锐的响应来彻底改变决策。依靠丰富的数据和洞见，未来的机器将具有更强大的决策能力。智能组合型业务将为重新设计数字化业务时刻、新业务模式、自主运营和新产品、各类服务及渠道铺平道路。\n2.10、人工智能工程化（AI Engineering） Gartner的研究表明，只有53%的项目能够从人工智能（AI）原型转化为生产。首席信息官和IT领导者发现，由于缺乏创建和管理生产级人工智能管道的工具，人工智能项目的扩展难度很大。为了将人工智能转化为生产力，就必须转向人工智能工程化这门专注于各种人工智能操作化和决策模型（例如机器学习或知识图）治理与生命周期管理的学科。\n人工智能工程化立足于三大核心支柱：数据运维、模型运维和开发运维。强大的人工智能工程化策略将促进人工智能模型的性能、可扩展性、可解释性和可靠性，完全实现人工智能投资的价值。\n2.11、超级自动化（Hyperautomation） 业务驱动型超级自动化是一项可用于快速识别、审查和自动执行大量获准业务和IT流程的严格方法。在过去几年中，超级自动化一直在持续不断地发展。而因为疫情，一切事物都被突然要求首先实现数字化，这大大增加了市场的需求。业务利益相关者所积压的需求已促使70%以上的商业机构实施了数十种超级自动化计划。\nBurke先生表示：“超级自动化是一股不可避免且不可逆转的趋势。一切可以而且应该被自动化的事物都将被自动化。”\n三、2022年 3.1、技术成熟度曲线 3.2、2022战略技术趋势 10 月 19 日，Gartner 发布了 2022 年重要战略技术趋势，包括生成式人工智能、数据编织、分布式企业、云原生平台、自治系统、决策智能、组装式应用程序、超级自动化、隐私增强计算、网络安全网格、人工智能工程化、全面体验等十二项技术。\n3.3、主题一、工程化信任 工程化信任（Engineering Trust），本质上是为了构建一个安全可靠的数据处理基础设施，它为数字经济夯实数据基础。\n3.3.1、数据编织（Data Fabric） 在过去的十年里，数据和应用孤岛的数量激增，而数据和分析（D\u0026amp;A）团队的技能型人才数量却保持不变，甚至下降。如何把企业的数据整合起来、编织起来，是数据编织想要解决的问题。\n数据编织是一种新型的数据管理设计理念。作为一种跨平台和业务用户的灵活、弹性数据整合方式，数据编织能够简化企业机构的数据、整合基础设施并创建一个可扩展数据架构来减少大多数数据和分析团队因整合难度上升而出现的技术债务。这个数据架构里包括的数据元素，可以是传统的关系型数据库，也可以是非结构化数据库、数据湖、云数据库等。\n从业务的角度看，数据编织是指，现在很多企业在拥有大量离散数据的情况下如何用一套新的架构把不同的数据连接起来，并对应真实世界中的业务场景。\n数据编织的真正价值在于它能够通过内置的分析技术动态改进数据的使用，使数据管理工作量减少 70% 并加快价值实现时间。\n3.3.2、网络安全网格（Cybersecurity Mesh） Groombridge 表示：“数据贯穿了今年的许多趋势，但只有当企业能够信任数据时，数据才会变得有用。如今，资产和用户可能出现在任何地方，这意味着传统的安全边界已经消失。这就需要有网络安全网格架构（CSMA）。”\n高挺认为，在大数据时代，用户设备无处不在，数据的来源也无处不在。传统的以数据中心为核心的中心化架构，已不能满足逐渐“云化”、“边缘化”的时代的安全需求，需要有一种新的安全架构，即“网络安全网格”。\n网络安全网格之所以称为网格（Mesh），是因为它把一系列的网络安全服务整合起来提供身份内容及策略等方面的认证。与传统的安全模式不同，它采用分布式的形式。\n且不同于传统的“一对多”的方式，即一个中央控制台对应所有终端或接入网络的安全“点”。网络安全网格是一种“多对多”、“N 对 N”的方式，能够让安全工具之间产生更多协作。这种方式的优点在于，除了做到中心化的网络安全模式下集中式的安全以外，它还可以做到模块化或者可编排化。\n市面上已经有一些类似于网络安全网格的解决方案出现了，如 SASE、XDR 架构等，一些传统安全厂商如 Fortinet、IBM、McAfee、微软等，都在做一些相应的解决方案。\nCSMA 帮助提供一体化安全结构和态势，为任何位置的任何资产提供安全保障。到 2024 年，使用 CSMA 一体化安全工具组成一个合作生态系统的企业机构能够将单项安全事件的财务影响平均减少 90%。\n3.3.3、隐私增强计算（Privacy-Enhancing Computation，PEC） 除了应对不断成熟的国际隐私和数据保护法律外，首席信息官还必须避免因隐私事件而导致客户信任下降。因此，Gartner 预计到 2025 年，60% 的大型企业机构将使用一种或多种隐私增强计算技术。\n有了网络安全网格之后，可以在很大程度上保证数据是安全、可信的，但接下去的一个问题是：要让数据产生价值，我们就必须处理分析数据，或者是构建 AI 模型，那么如何保证数据在被处理的过程中，它的隐私不会泄露，尤其是在和第三方的数据合作和数据外包的场景中？这就是隐私增强计算背后的逻辑。\n隐私增强计算大致分三类：\n第一类：为敏感数据的处理或分析提供一个可信环境。这里的可信环境，包括可信第三方或硬件可信执行环境，这类隐私增强计算也被称为“机密计算”。\n第二类：在不泄露数据的情况下对数据进行本地处理或分析。这一类技术往往通过分布式的形式来实现，包括联邦学习、隐私感知机器学习等。\n第三类：在处理或分析数据之前对数据和算法进行转换。使得数据和算法在处理的过程中不会泄露隐私。具体的技术包括：差分隐私、同态加密、安全多方计算、零知识证明等等。\n3.3.4、云原生平台（Cloud-Native Platform，CNP） 为了真正能够在任何地方提供数字能力，企业必须放弃熟悉的“直接迁移”并转向 CNP。CNP 运用云计算的核心能力，向使用互联网技术的技术创造者提供可扩展的弹性“IT 相关能力即服务”，从而加快价值实现时间并降低成本。\n“云原生平台”是打造数字基础设施的闭环之一，如今云的应用已越来越普遍，传统的上云模式是，企业有一个数据中心，“上云”后，企业就把传统的应用直接“切”到“云端”上去，但因为“云”的环境和传统数据中心的环境不一样，直接把数据“切”上去可能会产生“兼容性问题”。\n为了解决兼容性问题，Gartner 发现，许多企业使用云原生平台作为打造数据底座的闭环。简而言之，“云原生平台”就是天生就为“云”设计的平台，应用程序从设计到写代码，到最后部署，一开始就考虑到了“云”的环境，充分利用和发挥了“云平台”的弹性和分布式的优势。\n传统的 DevOps、微服务、容器等，都是“云原生”平台中的一部分，最后用云平台来实现弹性伸缩、动态调度，优化资源的利用率。\n“云原生平台”最大的好处是在开发时可以把应用和基础设施的关联性剥离，缩短上线时间，充分利用公有云的优势。\nGartner 预测到 2025 年，云原生平台将成为 95% 以上新数字倡议的基础，而在 2021 年这一比例只有不到 40%。\n3.4、主题二、塑造变化 这是一组用来加速数字化的技术趋势，其中包括 Gartner 去年提出的“超级自动化”、“AI 工程化”及今年新引入的“决策智能”以及“组装式应用程序”等四项技术。\n3.4.1、组装式应用程序（Composable Applications） 在不断变化的业务环境中，业务适应性需求能够引导企业转向支持快速、安全和高效应用变化的技术架构。可组合的应用架构增强了这种适应性，而采用可组合方法的企业机构在新功能的实现速度上将比竞争对手快 80%。\n传统的应用程序开发面临诸多挑战：一，没有足够的开发能力；二，选错技术方向；三，交付不够迅速。解决这一问题，一种常见的技术型方案是“代码重用”，将已有的、较成熟的代码重新应用，可节省时间，提高交付速度。\n而 Gartner 所提出来的“组装式应用”是通过引入一种新的架构来解决问题，它希望引入模块化的理念使技术和业务团队可以更敏捷、更有效地重用代码。\n其核心被称为“封装的业务能力（Packaged Business Capability，PBC）”，PBC 的定义是一种软件定义的最小化的业务功能，可以把它理解为是一种单一的对象或单一的功能。\n它和传统的软件开发交付的一个很大的区别是颗粒度。如传统的 ERP/CRM 系统，它是基于项目交付的封装应用, 首先它是基于项目交付的，因为一个大的 ERP 上线，一个大的 CRM 上线, 是一个超大的项目。这个项目最后交付的是一个大系统，这个大系统是一个封装应用。封装应用的意思是，一旦部署完了，除小的地方可以修修改改，基本上不能动它大的体系、大的架构了。\n而基于 PBC 的交付，它更像是一种高度定制化的可重复使用的组装应用。在这种架构中，PBC 像一个个原子，组装式的应用是把这些原子重新组合起一个个分子。用户团队可以根据自己的需要来组装所需的业务能力。\nGroombridge 表示：“在动荡的时代，可组合的业务原则帮助企业机构驾驭对业务韧性和增长至关重要的加速变化。没有它的现代企业机构可能会失去在市场中的前进动力和客户忠诚度。”\n3.4.2、决策智能（Decision Intelligence，DI） 一家企业机构的决策能力是其竞争优势的重要来源，而如今这个时代对这项能力的要求也越来越高。\n决策智能是一门实用的学科。该学科通过清楚理解并精心设计做出决策的方式以及根据反馈评估、管理和改进结果的方式来改进决策。\nGartner 预测在未来两年，三分之一的大型企业机构将使用决策智能实现结构化决策，进而提高竞争优势。\n这样的预测背后，是基于 Gartner 在 2020 年做的一项调查所发现的普遍现象：\n- 决策比两年之前更复杂了 - 对决策者能够解释自己决策的期望提高了 - 基于数据事实的基础是决策时最重要的参考因素 - 在足够的数据和 AI 模型的基础上，有一些决策是可以被自动化的\n3.4.3、超级自动化（Hyperautomation） 超自动化通过快速识别、审核和自动执行尽可能多的流程来实现加速增长和业务韧性。\nGroombridge 表示：“Gartner 的研究表明，表现最好的超自动化团队专注于三个关键优先事项：提高工作质量、加快业务流程和增强决策敏捷性。在过去的一年中，业务技术专家平均支持 4.2 项自动化倡议。”\nGartner 曾在 2021 年的重要战略技术趋势中提过“超级自动化”，2022 年的关注点有所三点不同：\n- 第一，今年更强调 IT 和业务的融合团队 - 第二，超级自动化包含 AI、机器学习、RPA、BPMS 等多项技术 - 第三，今年，中国乃至全球范围内的企业，都已经逐渐开始自动化，至少在某些流程或最重要的流程上已经实现了自动化运营。尽管目前有很多传统行业，目前暂时无法实现超级自动化，但 Gartner 认为这个趋势已经成为必然\n3.4.4、人工智能工程化（AI Engineering） IT 领导人想方设法地将人工智能集成到应用中，在从未投入生产的人工智能项目上浪费时间和金钱或在人工智能解决方案发布后努力保持它们的价值。人工智能工程化是一种实现人工智能模型操作化的综合方法。\n高挺表示，“AI 工程化”本质上是 AI 在企业中大规模、全流程的落地过程，尽管目前大家现在对 AI 期待很高，但实际上 AI 目前的应用仍然是被低估的。因为，很多 AI 项目的价值只能体现在一些“点对点”的一次性的方案中。将 AI 大规模落地的工程化方法（包含 DataOps、ModelOps 和 DevOps）总和起来，便是“AI 的工程化”的一整套体系。人工智能工程化对企业有很多好处，企业在进行人工智能落地的时候，落地效率、落地广泛度会更高。\nGroombridge 表示：“从事人工智能工作的混合团队是否真正能够为他们的企业机构实现差异化，取决于他们通过快速人工智能变革不断提升价值的能力。到 2025 年，10% 建立人工智能工程化最佳实践的企业从其人工智能工作中产生的价值将至少比 90% 未建立该实践的企业高出三倍。”\n3.5、主题三、加速增长 加速增长的本质是一组将数字化技术用以连接物理和虚拟世界，以构建一种新的工作方式（包括新的体验模式、新的商业模式等）的技术趋势。\n3.5.1、分布式企业（Distributed Enterprise） 随着远程和混合工作模式的增加，以办公室为中心的传统企业机构正在演变成由分散在各地的工作者组成的分布式企业。\nGroombridge 表示：“这就要求首席信息官通过重大技术和服务变革提供无摩擦工作体验，不过事情总有两面性：这项技术会对业务模式产生影响。从零售到教育，每家企业机构都必须重新配置交付模式才能支持分布式服务。两年前，全世界没有人想到自己能在数字试衣间里试穿衣服。”\n高挺认为，“分布式企业”的本质就是许多员工开始远程工作。如今“远程工作”已经成为新常态。在这个过程中，企业会发现自身的运作模式开始悄然发生一些变化，例如企业发现远程工作一样能满足公司的业务需求，还能降低成本。\n对企业来说，另外一个改变是员工在家里办公，企业的客户也在家办公，这样一来，整个需求场景包括交付场景会发生一些变化，这背后基础设施的需求也会发生变化。例如，国内很多互联网厂商开发了“在线会议”的解决方案，这其实就是这种变化所衍生出的商机。\nGartner 认为，构建以人为中心、整合物理空间和虚拟空间的技术将会成为主流趋势。它同时还会带来一些商业模式的变化，例如很多公司用 VR 技术实现数字试衣间，用户在虚拟世界里买衣服可以获得跟真实世界类似的体验。在未来，企业推出产品和服务时，可能会侧重采用数字优先、远程优先的逻辑。\nGartner 预计，到 2023 年，75% 充分发挥分布式企业效益的企业机构将实现比竞争对手快 25% 的收入增长。\n3.5.2、全面体验（Total Experience，TX） 全面体验是一项结合客户体验（CX）、员工体验（EX）、用户体验（UX）和多重体验（MX）学科的业务战略。TX 的目标是提升客户和员工的信心、满意度、忠诚度和拥护度。企业机构将通过实现具有适应性和韧性的 TX 业务成果来增加收入和利润。\n“全面体验”概念的大背景是，我们现在已经进入到了“体验经济”的时代。我们现在所处的时代，已经从传统的以营销为主的时代到了一个以产品为主的时代。这意味着，一家公司要做大做强，除了做很多市场宣传外，自身的产品力也要够强。而如何判定一项产品具有最强的产品力，一个关键指标是，这款产品给用户带来的体验。\nGartner 将全面体验分为四个模块：客户体验、用户体验、员工体验、多重体验。\n从销售的流程看，最关注客户体验，关注客户在从产品认知到买单这一系列流程中的体验感；用户和客户不同，一项产品的客户未必是它的用户，因此也要关注用户在产品使用过程中的体验；多重体验是指企业如何用技术手段去触达最终用户，这种触达可能采用线下或是线上的形式。多重体验强调具备一系列数字化能力，能够收集用户反馈等各项用户体验数据。\n现在许多企业追求客户体验，追求用户体验，但员工是不是有足够的技术能力进行支撑，使得员工可以很好地满足公司对用户体验和客户体验的要求呢？这正是员工体验所强调的内容。\n这四个体验模块在企业设计战略时候应当放在一起，考虑全面体验。不过现在，多数企业仅考虑了两个或三个模块。\n3.5.3、自治系统（Autonomic Systems） 随着企业的发展，传统的基于规则的系统或简单的自动化将无法适应不断变化的运营需求。\n自治系统是可以从所在环境中学习的自我管理型物理或软件系统。与自动化甚至自主系统不同，自治系统无需外部软件更新就可以动态修改自己的算法，使它们能够像人类一样迅速适应现场的新情况。\nGroombridge 表示：“自治行为已因为近期被部署在复杂的安全环境中而为人所知。而从长远看，这项技术将被普遍应用于机器人、无人机、制造机器和智能空间等物理系统。”\n高挺表示，“自治系统”早期虽然有一些案例，但它仍存在一些问题。自治系统的优点是，它会像人类一样可以自我迭代。但它现在还处于萌芽期，因此有时候会变得不可控。尤其当这个系统应用在生活中时，可能会遇到道德伦理上的困境。\n3.5.4、生成式 AI（Generative Artificial Intelligence） 生成式 AI 是最引人注目和最强大的人工智能技术之一。该机器学习方法从其数据中学习内容或对象，并运用数据生成全新、完全原创的实际工件。\n此前人们对于 AI 的使用，很多时候是要让它去做出判断、分类或得出结论。而如今，AI 的新用法，生成式 AI 正在出现。生成式 AI 不仅可以做判断，还可以做创造，人们可以用 AI 来创造出一些新事物，生成式人工智能可用于多种活动，如创建软件代码、促进药物研发和有针对性的营销。\n我们可以看到，在未来一段时间内。AI 会逐渐从一个做判断的机器变成一个做创造的机器。\nGartner 预计到 2025 年，生成式人工智能将占所有生成数据的 10%，而目前这一比例还不到 1%。\n但该技术也会被滥用于诈骗、欺诈、政治造谣、伪造身份等，具有一定的争议性。\n3.5.5、小结 从宏观上看，2021 年重要战略技术趋势的大主线是“新冠疫情影响下的世界发生了怎样的变革”，而今年的主线是，在新冠疫情已经成为新常态的背景下，企业如何在新常态下创造出新模式，以获得长期发展。\n四、2023年 Gartner将技术趋势划分为优化、开拓、扩展三大主题。其中，优化包括：数字免疫系统、应用可观测性、AI信任、风险和安全管理；开拓包括：元宇宙、超级应用、自适应AI；扩展包括：行业云平台、平台工程、无线价值实现。而可持续性技术贯穿2023年的所有战略技术趋势。\n4.1、主题一、开 拓 4.1.1、元宇宙（Metaverse） Gartner 将元宇宙定义为一个由通过虚拟技术增强的物理和数字现实融合而成的集体虚拟共享空间。这个空间具有持久性，能够提供增强沉浸式体验。Gartner 预计完整的元宇宙将独立于设备并且不属于任何一家厂商。它将产生一个由数字货币和非同质化通证（NFT）推动的虚拟经济体系。Gartner 预测，到 2027 年，全球超过 40%的大型企业机构将在基于元宇宙的项目中使用 Web3、增强现实（AR）云和数字孪生的组合来增加收入。\n实际用例：印度虚拟现实初创公司OneRare正在为美食爱好者打造身临其境的游戏化体验，让食品品牌进入全球市场，通过提供食品吸引游戏玩家，并在虚拟和实体商店中使用。\n4.1.2、超级应用（Superapps） 超级应用是一个集应用、平台和生态系统功能于一身的应用程序。它不仅有自己的一套功能，而且还为第三方提供了一个开发和发布他们自己的微应用的平台。Gartner 预测，到 2027 年，全球 50%以上的人口将成为多个超级应用的日活跃用户。\nKaramouzis 表示：“虽然大多数超级应用是移动应用，但这个概念也可以应用于 Microsoft Teams、Slack 等桌面客户端应用，关键在于超级应用必须能够整合并取代客户或员工使用的多个应用。”\n超级应用的5个特征：应用，小应用的用户发现和激活；平台，小应用的设计和开发框架、小应用的生态发布机制；生态，小应用的用户发现和激活，超级应用和小应用之间的数据共享等。\n超级应用的关键行动：\n- 通过设计以人为本的产品、流程和服务来提高超级应用交付模型的有效性；\n- 确定超级应用程序中的核心、高参与度功能，这些功能将推动大量最终用户；\n- 通过建立以共享平台功能加强的生态系统治理，满足小应用程序的安全和数据保护要求；\n实际用例：PayPay是一家日本支付提供商，拥有近5000万用户。其增长战略的一个关键部分是将第三方产品和服务的购买，整合到其超级应用程序中，它已经提供了用于购买电影票、订购外卖和自行车共享的第三方小应用程序，以及自己的财务管理应用程序服务和零售购物等。\n4.1.3、自适应 AI（Adaptive AI） 自适应 AI 系统通过不断反复训练模型并在运行和开发环境中使用新的数据进行学习来迅速适应在最初开发过程中无法预见或获得的现实世界情况变化。这些系统根据实时反馈动态调整它们的学习和目标，因此适合外部环境快速变化的运营或者因为企业目标不断变化而需要优化响应速度的运营。\nGartne预测，到2026年，采用AI工程实践来构建和管理自适应AI系统的企业，将在AI模型的可操作性方面优于同行至少25%。\n实际用例：美国化学和材料制造商陶氏公司部署了自适应人工智能系统，利用对使用模式和业务价值优化的反馈来增强企业分析。它使分析平台产生的价值增加了320%。\n4.2、主题二、优 化 4.2.1、数字免疫系统（Digital Immune System） 76%负责数字产品的团队现在还需要对营收负责，因此首席信息官正在寻找新的实践和方法，使其团队能够在实现高商业价值的同时，降低风险和提高客户满意度。数字免疫系统为他们提供了满足这一要求的路线图。\n数字免疫系统通过结合数据驱动的运营洞察、自动化和极限测试、自动化事件解决、IT 运营中的软件工程以及应用供应链中的安全性来提高系统的弹性和稳定性。Gartner 预测，到 2025 年，投资建设数字免疫系统的企业机构将能够减少多达 80%的系统宕机时间，所减少的损失将直接转化为更高的收入。\n实际用例：巴西银行为其监控系统增加了预测和补救功能，以持续评估系统健康状况、提高系统性能并深入了解推动最佳员工和客户体验的因素。这些功能将事件的自动补救率提高了 37%，并将平均解决时间缩短了45%\n4.2.2、应用可观测性（Applied Observability ） 在任何相关方采取任何类型的行动时，都会产生包含了数字化特征的可观测数据，如日志、痕迹、API 调用、停留时间、下载和文件传输等。应用可观测性以一种高度统筹和整合的方式将这些可观测的特征数据进行反馈，创造出一个决策循环，从而提高组织决策的有效性。\nKaramouzis 表示：“可观测行应用使企业机构能够利用他们的数据特征来获得竞争优势。它能够在正确的时间提高正确数据的战略重要性，以便根据确认的相关方行动而不是意图采取快速行动，因此是一种强大的工具。如果能够在战略中予以规划并成功执行，可观测性应用将成为数据驱动型决策的最强大来源。”\n实际用例：特斯拉是一个使用应用可观察性的典型案例。该技术通过实时观察特斯拉车主的驾驶行为，在美国几个州为他们提供车辆保险。特斯拉汽车使用传感器和 Autopilot 软件“观察”和测量驾驶行为，以生成每月安全评分。特斯拉表示，那些通过安全评分的司机可以节省20%到40%的保费，而那些安全分数最高的司机可以节省40%到60%费用。\n4.2.3、AI 信任、风险和安全管理（Trust, Risk and Security Management） 许多企业机构未做好管理 AI 风险的充分准备。Gartner 在美国、英国和德国开展的一项调查显示，41%的企业机构曾经历过 AI 隐私泄露或安全事件。但该调查也发现积极管理 AI 风险、隐私和安全的企业机构在 AI 项目中取得了更好的成果。与未积极管理这些功能的企业机构的 AI 项目相比，在这些企业机构中有更多的 AI 项目能够从概念验证阶段进入到生产阶段并实现更大的业务价值。\n企业机构必须使用新的功能来保证模型的可靠性、可信度、安全性和数据保护。AI 信任、风险和安全管理（TRiSM）需要来自不同业务部门的参与者共同实施新的措施。\nAI TRiSM支持AI模型治理、可信赖性、公平性、可靠性、稳健性、有效性和隐私性。它包括模型可解释性、人工智能隐私、模型操作等。\n实际用例：丹麦商业管理局 (DBA) 开发了一种将高级道德原则应用于其 AI 模型的方法。DBA 将其道德原则与具体行动联系起来，根据公平测试、检查模型、预测并建立模型监控框架。DBA的方法帮助其快速部署和管理16个AI模型，用于监控价值数十亿欧元的金融交易。\n4.3、主题三、扩 展 4.3.1、行业云平台（Industry Cloud Platforms） 行业云平台通过组合 SaaS、平台即服务（PaaS）和基础设施即服务（IaaS）提供支持行业应用场景的行业模块化能力。企业可以将行业云平台的打包功能作为基础模块，组合成独特、差异化的数字业务项目，在提高敏捷性、推动创新和缩短产品上市时间的同时避免单一厂商锁定。\nGartner 预测，到 2027 年，超过 50%的企业将使用行业云平台来加速他们的业务项目。\n实际用例：杭州是中国人口最多的城市之一，通过与阿里巴巴的技术合作建立了“智慧城市大脑”平台，来管理拥堵并简化日常城市运营。该平台结合了数字化基础设施、中央数据平台和海量应用。实施后，该市的拥堵排名大幅下降，从中国第五大拥堵城市跌至前50名。\u0026lt;(这个案例和行业云平台这个主题有啥关系啊？奇怪！)\u0026gt;\n4.3.2、平台工程（Platform Engineering） 平台工程是一套用来构建和运营支持软件交付和生命周期管理的自助式内部开发者平台的机制和架构。平台工程的目标是优化开发者体验并加快产品团队为客户创造价值的速度。\nGartner 预测，到 2026 年，80%的软件工程组织将建立平台团队，其中 75%将包含开发者自助服务门户。\n实际用例：耐克建立了“可组合平台”，将战略相关的全球业务能力结合起来，这些能力由通过API公开的模块化和可组合技术实现。耐克发现该平台使其能够更快地响应变化，加快产品上市时间，提高可扩展性并降低运营成本。\n4.3.3、无线价值实现（Wireless Value Realization） 由于没有一项技术能够占据主导地位，企业将使用一系列无线解决方案来满足办公室 Wi-Fi、移动设备服务、低功耗服务以及无线电连接等所有场景的需求。Gartner 预测，到 2025 年，60%的企业将同时使用五种以上的无线技术。\n网络的功能将不再仅限于纯粹的连接，它们将使用内置的分析功能提供洞察，而其低功耗系统将直接从网络中获取能量。这意味着网络将直接产生商业价值。\n无线价值实现了从传统终端用户计算，到支持边缘设备再到数字标签解决方案的方方面面。所有这些都需要连接才能运行，并且需要一系列无线解决方案来满足所有环境的需求。网络将远远超越单纯的连接，成为直接商业价值的来源。无线正在从一种通信技术转变为更广泛的数字创新平台。\n实际用例：Bosch-Siemens通过使用超声波传感器实时减慢叉车的速度。除了消除叉车事故外，未遂事故减少了98%，同时生产力提高了10%。\n4.4、可持续技术（Sustainability） Gartne预测，到2025年，50%的CIO将拥有与 IT 组织的可持续性相关的绩效指标。\n可持续技术是一种解决方案框架，可提高 IT服务的能源和效率；通过可追溯性、分析、可再生能源等技术实现企业可持续发展；并通过应用程序、软件、市场等帮助客户变得更具可持续性。对可持续技术的投资也有可能创造更大的运营弹性和财务业绩，同时提供新的业务增长途径。\n实际用例：迪拜电力和水务局 (DEWA) 等公用事业部门，使用物联网和数字孪生创建智能建筑管理解决方案，用水量减少50%。\n","id":0,"section":"posts","summary":"\u0026lt;部分内容借鉴自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt; Gart","tags":["技术"],"title":"Gartner战略技术趋势（2021-2023）","uri":"https://rjguanwen.cn/2022/10/gartner_01/","year":"2022"},{"content":" 什么是组装式应用? \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;组装式应用被Gartner连续两年列为重要战略技术趋势。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;之所以“组装式应用”能够成为近年来的重要战略技术趋势，究其原因是，由于互联网已经进入“下半场”，靠“堆人力”的研发方式已经不再具备竞争力了，真正可行且有效的方式是让系统能力变得可沉淀、可组合复用、可灵活应对各种变化。面对不断变化的业务环境、快速迭代的业务需求，急需通过组装式应用来提升企业的竞争力。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;那么什么是组装式应用呢？\n“组装式应用由以业务为中心的模块化组件构成，具备更易使用和可重复使用的代码，可加速新软件解决方案的上市时间，并释放企业价值。”\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;“组装式应用”可以理解为一种技术理念，倡导的是任何企业数字化技术元素均可被组合。组装式应用协力为企业提供更灵活的组装式部件，帮助企业应对不同环境带来的挑战，让企业更具韧性和抗风险能力。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;组装式应用是由一系列的“封装业务能力”（Packaged Business Capability，简称PBC）组成的。PBC是封装好的软件组件，代表定义良好的业务功能，业务用户可快速识别，并可对外开放API接口。PBC并没有规定的大小、功能范围或内部体系结构，但PBC只有在实现了模块化、可发现、自主和可编排（集成）的特征后才是有价值的。换句话说，封装好的业务能力，必须是独立的，对某类受众能体现出业务或技术价值。\n组装式应用的价值 个人认为，组装式应用在两个方面有较大的意义：\n1. 面向企业的价值，通过组装式应用的方式，可以重构企业的信息化架构，可以用搭积木的方式快速构建新型应用，为业务的快速变化提供敏捷的信息化支撑。这个可以看成是微服务的一个升级。\n2. 面向软件开发商的价值，特别是像我们这样的，面向某个行业的软件开发商。通过这种模式，可以打造多行业相对通用的软件体系，方便在具体行业、具体企业时，快速定制开发个性化软件。\n接下来的论述主要针对第二种情况。\n组装式应用与低代码平台的关系 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;组装式应用与低代码平台关系非常密切，可以认为低代码平台应该是组装式应用架构里面很重要的一个组成部分。但是，从两者的定位来看，还是有明显差别的。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;组装式应用的核心是对业务的抽象，它的每一个PBC都有具体的业务含义与业务目标，甚至包含业务动作。而低代码平台的核心是提供了可复用的技术组件，业务人员可以用这些技术组之间来拼装成业务功能来支撑具体业务的开展。两者虽然都是为了敏捷开发，但是出发点是有巨大差异。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;为什么说低代码平台是组装式应用架构的重要组成部分呢？关键在于两者虽然有差异，但是其互补性也非常强。两者一个注重技术一个注重业务，通过低代码的理念来实现PBC的组装，可以更高效、更精确的实现业务诉求。\n组装式应用的实现设想 1、组装式应用的底座 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;所谓组装式应用的底座，就像汽车底盘一样，它是一个承载平台。同一个汽车底盘，通过配置不同的动力总成、车身、内饰、空调电子等，可以生产制造各种不同系列的汽车，例如：速腾、高尔夫、奥迪TT就都是基于PQ35平台研发生产的。组装式应用的底座应该也有同样的功效，它可以承载各种不同的PBC，为不同的行业、不同的企业构建出个性化十足的应用系统。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;个人认为组装式应用的底座应该就是企业数字中台，精确的来说就是业务中台+数据中台。数字中台天生具有成为底座资质，因为它本身就是对业务的抽象，可以为各个PBC提供稳定的原子服务，同时也为各PBC之间的连接提供了服务、流程与数据方面的保障。所以，数字中台的建设是组装式应用架构建设的基础。以快消品行业为例，我们要建设一套能适应多个快消品行业的组装式应用系统，那么我们首先要建设一个面向快消品领域且提出了具体行业属性的数字中台，基于这套中台，来构建面向各种具体业务的PBC，通过PBC的组装形成面向具体快消品行业（如烟、酒）的业务应用。\n2、PBC的形态 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;关于PBC到底长啥样，应该以什么技术支持、以什么形态存在，这个暂时没有唯一正确的回答。我想，PBC应该是是分不同种类的，我将其分为三类：业务服务类、功能组件类、应用模块类。\n2.1、业务服务类 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;业务服务类PBC以Rest服务的形式存在，包括数字中台的原子服务、通过中台原子服务封装的业务能力服务以及自定义服务。前两者很好理解，自定义服务是特指通过服务定义平台用SQL的方式生产的服务。自定义服务的特殊之处在于，它所连接的数据库可能不是中台这样的稳定的数据库，可能是归属于某一个应用的数据库。这样它的可用性要以该应用的在用为基础。这是需要在PBC管理上需要注意的。\n2.2、功能组件类 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;功能组件类PBC以web组件或页面组件的形式存在，举两个例子有助于理解：一是客户漏斗，它在系统里面可能表现为一个弹出框，但是它是具有一定的业务含义的。首先它要受到登录用户的数据权限控制，另外它也会收到上级页面上一些参数与选择条件的控制，最后它本身也集成了一些相关的能力，如基于标签、分类分档、经营情况的筛选等；二是订单明细，它在系统里面可能表现为一个设置一系列的页面组合。在业务系统中，每个显示了订单号的地方，都能将其挂载上去，用户客户虽然进入查看其明细设置统计信息；三是客户档案，客户档案除了包括客户的基本信息之外，可能还会包括客户画像、客户经营情况、客户诚信情况等等，与订单明细一样，它也可以提炼为一个PBC，在系统里面广泛应用。功能类组件在引入时应该提供相应的参数配置能力，以保证其适应性。\n2.3、应用模块类 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;应用模块类BPC比功能组件类更高了一个层次，它应该是以容器封装的微应用为主要形态。这类BPC的特点是具有相对高的业务通用性。例如问卷调查，它本身有足够高的可配置性，同时又有足够的通用性，这就可以抽象为一个BPC。各业务系统需要时，可以直接将其引入系统，需要重点考虑的是该组件与业务系统其他模块之间的互通问题，例如调查范围的选择可能要和系统中的客户、组织机构等打通；调查的结果可能要和具体的业务打通。\n3、PBC研发管控平台 \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;只有好的管理才能有好的复用。PBC研发管控平台包括PBC定义、设计、发布、停用等生命周期管理及分类管理、引用管理等内容。具体不再详述。目标是最大限度的方便PBC在各业务系统中复用。\n4、总体架构图 ","id":1,"section":"posts","summary":"什么是组装式应用? \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;组装式应用被Gartner连续两年列为重要战略技术","tags":["技术"],"title":"组装式应用思考","uri":"https://rjguanwen.cn/2022/09/pbc_01/","year":"2022"},{"content":" 读书笔记 - 《经济学通识》 \u0026mdash;\u0026mdash;\u0026mdash;- 原文摘抄 \u0026mdash;\u0026mdash;\u0026mdash;-\n以淳朴的眼光看，人类至少面临四项普遍约束：\n1. 东西不够\n2. 生命有限\n3. 互相依赖\n4. 需要协作\n人类种种制度的安排，一概是为了应付这些约束而衍生的。粗略地概括，这四项约束对应着四类经济理论：\n1. 需求定律\n2. 利息理论\n3. 制度理论\n4. 宏观理论\n……\n","id":2,"section":"posts","summary":"读书笔记 - 《经济学通识》 \u0026mdash;\u0026mdash;\u0026mdash;- 原文摘抄 \u0026mdash;\u0026mdash;\u0026mdash;- 以淳朴的眼光看，人类至少面临四项普遍约束： 1. 东西不够 2. 生命有限 3. 互相依赖 4. 需要协作 人类种种制度的安排，一","tags":["读书"],"title":"读书 - 《经济学通识》","uri":"https://rjguanwen.cn/2022/06/jingjixuetongshi_1/","year":"2022"},{"content":" 一、本身原则：只要做了就违法 “本身原则”：在执法过程中，不问原由，只要有证据表明被告人事实上做了某件事情， 他就违法，不需要问动机是什么、这么做的后果是什么、这么做对你自己和社会的影响是什么。\n在现实生活中很常见：\n- 考试迟到15分钟，不管什么原因，考生都不能再进入考场。\n- 不论你闯红灯的原因、后果是什么，闯了红灯就是违法。\n二、理性原则：是否违法要看具体条件 理性原则与本身原则是相对的：当事人做了一件事情，不见得一定违法，但要全面衡量此事的前因后果。\n 一种商业行为是在怎样的条件下被选用？\n 当事人选用这种商业模式的动机是什么？\n 实际后果是怎样的？\n 对其他竞争者的影响是怎样的？\n 对消费者的影响是怎样的？\n 对当前的技术进步和普及，会产生什么样的作用？\n 从长远看是不是要做出重新评估？\n所有这些因素加起来，称之为理性原则。\n  ","id":3,"section":"posts","summary":"一、本身原则：只要做了就违法 “本身原则”：在执法过程中，不问原由，只要有证据表明被告人事实上做了某件事情， 他就违法，不需要问动机是什么、这么","tags":["杂七杂八"],"title":"本身原则与理性原则","uri":"https://rjguanwen.cn/2022/05/two_yz/","year":"2022"},{"content":" 读书笔记 - 《数据资产论》  根据会计学的定义，资源要成为资产有一个必要条件：带来预期的经济收益。由此，不是所有的数据都可以称为资产，只有那些能够产生商业价值的数据才可以成为资产。\n数据资产的彰显需要一个必要条件：业务场景。业务场景可以孤立于数据之外而产生价值，但是数据却无法孤立于业务场景之外产生价值。数据价值之道在于：场景为王，数据次之，算法最后。\n 不确定性产生有两大根本原因：一是无知；二是无奈。无知所对应的不确定性，可以通过数据的无限积累、算法的不断改良、知识的持续增加而逐步化解。无奈所对应的不确定性，其根源是人类对稀缺资源的无限博弈，我们对它无可奈何，它将长期广泛的存在，甚至不回衰减。我们要分清数据分析中“可为”与“不可为”之间的区别。\n   ","id":4,"section":"posts","summary":"读书笔记 - 《数据资产论》 根据会计学的定义，资源要成为资产有一个必要条件：带来预期的经济收益。由此，不是所有的数据都可以称为资产，只有那些能够","tags":["读书","技术"],"title":"读书 - 《数据资产论》","uri":"https://rjguanwen.cn/2022/03/sjzcl01/","year":"2022"},{"content":" 表单参数 表单传输为 POST 请求，http 常见的传输格式为四种：\n- application/json - application/x-www-form-urlencoded - application/xml - multipart/form-data 表单参数可以通过 PostForm() 方法获取，该方法默认解析的是 x-www-form-urlencoded 或 form-data 格式的参数。\n简单的表单示例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;demo1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;http://localhost:8080/form\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;application/x-www-form-urlencoded\u0026quot;\u0026gt; 用户名：\u0026lt;inpurt type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; placeholder=\u0026quot;请输入你的用户名\u0026quot;\u0026gt; \u0026lt;br\u0026gt; 密\u0026amp;nbsp;\u0026amp;nbsp;码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; placeholder=\u0026quot;请输入你的密码\u0026quot;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  package main import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/gin-gonic/gin\u0026quot; \u0026quot;net/http\u0026quot; ) //表单参数 func main(){ r:=gin.Default() r.POST(\u0026quot;/form\u0026quot;, func(c *gin.Context) { types:=c.DefaultPostForm(\u0026quot;type\u0026quot;,\u0026quot;post\u0026quot;) // 键名和html页面属性名对应 username:=c.PostForm(\u0026quot;username\u0026quot;) password:=c.PostForm(\u0026quot;userpassword\u0026quot;) c.String(http.StatusOK,fmt.Sprintf(\u0026quot;username:%s,password:%s,types:%s\u0026quot;,username,password,types)) }) r.Run() }  文件上传 ","id":5,"section":"posts","summary":"表单参数 表单传输为 POST 请求，http 常见的传输格式为四种： - application/json - application/x-www-form-urlencoded - application/xml - multipart/form-data 表单参数可以通过 PostForm() 方法获取，该方法默认解析的是 x-www-form-urlencoded 或 form-data 格式的参数。 简单","tags":["技术","gin","golang","开发框架"],"title":"Gin 表单与文件上传","uri":"https://rjguanwen.cn/2022/03/gin_03/","year":"2022"},{"content":" 路由 核心功能  路由系统可根据请求方法、请求路径和路径参数来识别转发 可设置一个或者多个中间件用于在请求处理器前后处理特殊的事件 可以分组设置，将一个或多个中间件作用在一组多个路由上  基本语法 //构建路由对象并注册请求路径对应的处理器 r := gin.Default() r.GET(\u0026quot;/ping\u0026quot;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026quot;message\u0026quot;: \u0026quot;ping\u0026quot;, }) }) // 监听并在 0.0.0.0：8080 上启动服务 r.Run()  可以将路由的定义放在单独的文件中完成，如 /router/api.go :\n// file: /router/api.go func APIRouter() *gin.Engine { r := gin.Default() r.GET(\u0026quot;/ping\u0026quot;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026quot;message\u0026quot;: \u0026quot;ping\u0026quot; }) }) // 更多的注册 // r.POST() // r.DELETE() // r.PUT() return r }  然后，在 main() 中完成调用和初始化，并启动监听：\n// file /main.go func main() { // 初始化路由 r := router.APIRouter() // 启动服务 r.Run() }  请求方法 快捷方法 除 GET 方法外，路由系统还支持任意方式的请求：DELETE、GET、HEAD、OPTIONS、PATCH、POST、PUT。\n通用方法 如果需要接收其他的请求方式，可以使用通用的方法 Handle 来注册：\nfunc (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes  其中 httpMethod 就是请求方法字符串，例如 TRACE、CONNECT 等。\n任意方法 若需要监听同一个请求路径的多个任意方法，可以使用 Any()：\nfunc (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes  处理器 handler 处理器（也被成为控制器），用来处理 HTTP 请求：\ntype HandlerFunc func(*Context)  handler 就是一个可以接收 *Context 类型的 (*gin.Context) 参数的函数。\n处理器可以分为两类，中间件和请求处理器（也叫业务逻辑处理器）。在 router.GET() 之类的方法中，最后一个 Handler 就是请求处理器，除此之外前边的都是中间件。\n处理器被调用时，会接收一个 *Context 参数，是请求上下文，用于获取请求和响应操作。\n路由参数 路由参数指在请求路径中定义的参数，例如请求的 URI 是 /user/21，21 作为用户的 ID，那么 21 就是路由参数。路由参数与查询字符串有区别，例如 /user?ID=21，这个 ID=21 叫做查询字符串。\n使用路由参数的好处是将动态 URL 变为静态 URL，因为请求客户端会认为路由参数不是变化的数据，因此被视为静态 URL.\n如需定义带有路由参数的路径，需要使用 :param 或 *param 的语法在路径中。\n必选参数 使用 :param 的语法完成必选参数的定义，例如 /user/:ID，即可匹配 /user/21 这个 URI，但不能匹配 /user 或 /user/。例如\nrouter.GET(\u0026quot;/user/:ID\u0026quot;, func(c *gin.Context) { ID := c.Para(\u0026quot;ID\u0026quot;) })  可选参数 使用 *param 的语法完成可选参数的定义，例如 /user/*ID 可以匹配 /user/21 和 /user 或 /user/ 的 URI。例如：\nrouter.GET(\u0026quot;/user/*ID\u0026quot;, func(c *gin.Context) { ID := c.Para(\u0026quot;ID\u0026quot;) })  若没有匹配到，则 ID 为空字符串。\n获取参数 使用 gin.Context 对象的 c.Param(\u0026quot;param\u0026quot;) 来获取参数值。\n路由分组 路由分组用于将多个路由进行统一的处理，例如统一的前缀，统一的中间件等。例如在需要做认证的业务逻辑时，就可以将大量的需要身份认证的路由定义在一个组中，集中设置用于认证校验的中间件。\n创建分组 使用函数 router.Group() 完成分组的创建。创建时可以提供路径前缀和公用中间件：\nfunc (group *RouterGroup) Group(relativePath string, handlers ...handlerFunc) *RouterGroup  调用该函数后，会形成一个分组路由对象，组内的路由需要使用该对象完成处理器的注册，例如：\n// 简单的路由组 v1 := router.Group(\u0026quot;/v1\u0026quot;) { v1.Post(\u0026quot;/login\u0026quot;, loginEndpoint) v1.Post(\u0026quot;/submit\u0026quot;, submitEndpoint) v1.Post(\u0026quot;/delete\u0026quot;, deleteEndpoint) } v2 := router.Group(\u0026quot;/v2\u0026quot;) { v2.Post(\u0026quot;/login\u0026quot;, loginEndpoint) v2.Post(\u0026quot;/submit\u0026quot;, submitEndpoint) v2.Post(\u0026quot;/delete\u0026quot;, deleteEndpoint) }  上面的代码创建了两个路由分组，前缀分别是 v1 和 v2。\n中间件 中间件 middleware，也是一种处理器。主要用于在多个业务逻辑中间重用代码，例如认证校验、日志处理等。中间件需要附加在路由上，使用 router.User() 方法。\n我们在使用 gin.Default() 初始化路由对象时，会随之附加两个中间件 Logger 和 Recovery，用于完成日志和恢复的相关处理：\nfunc Default() *Engine { debugPrintWARNINGDefault() engine := New() // 注册中间件 engine.Use(Logger(), Recovery()) return engine }  若不想使用任何中间件，可以使用函数 gin.New() 来创建空白的路由，例如：\nrouter := gin.New()  此时的路由对象，不会自动附加任何的中间件。\n启动监听 函数 router.Run() 用于启动 HTTP 监听，函数接收监听地址作为参数，默认地址为 :8080。\n","id":6,"section":"posts","summary":"路由 核心功能 路由系统可根据请求方法、请求路径和路径参数来识别转发 可设置一个或者多个中间件用于在请求处理器前后处理特殊的事件 可以分组设置，将一","tags":["技术","gin","golang","开发框架"],"title":"Gin 路由","uri":"https://rjguanwen.cn/2021/09/gin_02/","year":"2021"},{"content":" 临江仙·夜登小阁忆洛中旧游 【宋】陈与义\n忆昔午桥桥上饮，坐中多是豪英。\n长沟流月去无声。\n杏花疏影里，吹笛到天明。\n二十余年如一梦，此身虽在堪惊。\n闲登小阁看新晴。\n古今多少事，渔唱起三更。\n","id":7,"section":"posts","summary":"临江仙·夜登小阁忆洛中旧游 【宋】陈与义 忆昔午桥桥上饮，坐中多是豪英。 长沟流月去无声。 杏花疏影里，吹笛到天明。 二十余年如一梦，此身虽在堪惊。 闲","tags":["古文"],"title":"《临江仙·夜登小阁忆洛中旧游》","uri":"https://rjguanwen.cn/2021/08/scsj-6/","year":"2021"},{"content":" 师旷劝学 【西汉】刘向\n晋平公问于师旷曰：“吾年七十欲学，恐已暮矣！”师旷曰：“何不炳烛乎？”平公曰：“安有为人臣而戏其君乎？”师旷曰：“盲臣安敢戏其君乎！臣闻之：‘少而好学，如日出之阳；壮而好学，如日中之光；老而好学，如炳烛之明。’炳烛之明，孰与昧行乎？”平公曰：“善哉！”\n","id":8,"section":"posts","summary":"师旷劝学 【西汉】刘向 晋平公问于师旷曰：“吾年七十欲学，恐已暮矣！”师旷曰：“何不炳烛乎？”平公曰：“安有为人臣而戏其君乎？”师旷曰：“盲臣安","tags":["古文"],"title":"《师旷劝学》","uri":"https://rjguanwen.cn/2021/08/scsj-5/","year":"2021"},{"content":" 贺新郎·甚矣吾衰矣 【宋】辛弃疾\n邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。\n甚矣吾衰矣。\n怅平生、交游零落，只今余几！\n白发空垂三千丈，一笑人间万事。\n问何物、能令公喜？\n我见青山多妩媚，料青山见我应如是。\n情与貌，略相似。\n一尊搔首东窗里。\n想渊明、停云诗就，此时风味。\n江左沉酣求名者，岂识浊醪妙理。\n回首叫、云飞风起。\n不恨古人吾不见，恨古人、不见吾狂耳。\n知我者，二三子。\n","id":9,"section":"posts","summary":"贺新郎·甚矣吾衰矣 【宋】辛弃疾 邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云","tags":["诗词"],"title":"《贺新郎·甚矣吾衰矣》","uri":"https://rjguanwen.cn/2021/08/scsj-4/","year":"2021"},{"content":" 鹧鸪天·吴子似过秋水 【宋】辛弃疾\n秋水长廊水石间。\n有谁来共听潺湲。\n羡君人物东西晋，分我诗名大小山。\n穷自乐，懒方闲。\n人间路窄酒杯宽。\n看君不了痴儿事，又似风流靖长官。\n","id":10,"section":"posts","summary":"鹧鸪天·吴子似过秋水 【宋】辛弃疾 秋水长廊水石间。 有谁来共听潺湲。 羡君人物东西晋，分我诗名大小山。 穷自乐，懒方闲。 人间路窄酒杯宽。 看君不了痴儿","tags":["诗词"],"title":"《鹧鸪天·吴子似过秋水》","uri":"https://rjguanwen.cn/2021/08/scsj-3/","year":"2021"},{"content":" 鹧鸪天•西都作 【宋】朱敦儒\n我是清都山水郎，天教分付与疏狂。\n曾批给雨支风券，累上留云借月章。\n诗万首，酒千觞，几曾着眼看侯王？\n玉楼金阙慵归去，且插梅花醉洛阳。\n","id":11,"section":"posts","summary":"鹧鸪天•西都作 【宋】朱敦儒 我是清都山水郎，天教分付与疏狂。 曾批给雨支风券，累上留云借月章。 诗万首，酒千觞，几曾着眼看侯王？ 玉楼金阙慵归去，且","tags":["古文"],"title":"《鹧鸪天•西都作》","uri":"https://rjguanwen.cn/2021/08/scsj-7/","year":"2021"},{"content":" 天台石梁雨后观瀑歌 【清】魏源\n雁荡之瀑烟苍苍，中条之瀑雷硠硠，\n惟有天台之瀑不奇在瀑奇石梁，如人侧卧一肱张。\n力能撑开八万四千丈，放出青霄九道银河霜。\n我来正值连朝雨，两崖佰束风愈怒。\n松涛一涌千万重，漭泉冲夺游人路。\n重岗四合如重城，震电万车争殷辚。\n山头草木思他徙，但有虎啸苍龙吟。\n须臾雨尽月华湿，月瀑更较雨瀑谧。\n千山万山惟一音，耳畔众响皆休息。\n静中疑是曲江涛，此则云垂彼海立。\n我曾观潮更观瀑，浩气胸中两仪塞。\n不以目视以耳听，斋心三日钧天瑟。\n造物贶我良不悭，所至江山纵奇特，\n山僧掉头笑休道，雨瀑月瀑那如冰瀑妙。\n破玉裂琼凝不流，黑光中线空明窈。\n层冰积压忽一摧，天崩地坼空晴昊。\n前冰已裂后冰乘，一日玉山百颓倒。\n是时樵牧无声游屐绝，老僧扶杖穷幽讨。\n山中胜不传山外，武陵难向渔郎道。\n语罢月落山茫茫，但觉石梁之下烟苍苍、雷硠硠，\n挟以风雨，浩浩如河江。\n","id":12,"section":"posts","summary":"天台石梁雨后观瀑歌 【清】魏源 雁荡之瀑烟苍苍，中条之瀑雷硠硠， 惟有天台之瀑不奇在瀑奇石梁，如人侧卧一肱张。 力能撑开八万四千丈，放出青霄九道银河","tags":["诗词"],"title":"《天台石梁雨后观瀑歌》","uri":"https://rjguanwen.cn/2021/08/scsj-1/","year":"2021"},{"content":" 清江引·弃微名去来心快哉 【元】贯云石\n弃微名去来心快哉，一笑白云外。知音三五人，痛饮何妨碍？醉袍袖舞嫌天地窄。\n竞功名有如车下坡，惊险谁参破？昨日玉堂臣，今日遭残祸，争如我避风波走在安乐窝。\n避风波走入安乐窝，酒里乾坤大。醒了醉还醒，卧了重还卧，似这般得清闲的谁似我？咏梅南枝夜来先破蕊，泄漏春消息。偏宜雪月交，不惹蜂蝶戏，有时节暗香来梦里。\n冰姿迥然天赋奇，独占阳和地。未曾着子时，先酿调羹味，休教画楼三弄笛。\n芳心对人娇欲说，不忍轻轻折。溪桥淡淡烟，茅舍澄澄月，包藏几多春意也。\n玉肌素洁香自生，休说精神莹！风来小院时，月华人初静，横窗好看清瘦影。惜别玉人泣别声渐杳，无语伤怀抱。寂寞武陵源，细雨连芳草，都被他带将春去了。知足画堂不如安乐窝，尽了吾侪坐。闲来偃仰歌，醉后弯全卧，尽教利名人【笑我】荣枯自天休觊图，且进怀中物。莫言李白仙，休说刘伶墓，酒不到他坟上土。\n烧香扫地门半掩，几册闲书卷。识破幻泡身，绝却功名念，高竿上再不看人弄险。\n野花满园春昼永，客来相陪奉。草堂书千卷，月下琴三弄，子落得这些儿闲受用。惜别窗间月娥风韵煞，良夜千金价。一掬可怜情，几句临明话，小书生这歇儿难立马。\n玉人泣别声渐哑，久立凉生袜。无处托春心，背立秋千下，被梨花月儿迤逗煞。\n湘云楚雨归路杳，总是伤怀抱。江声搅暮涛，树影留残照，兰舟把愁都载了。\n若还与他相见时，道个真传示。不是不修书，不是无才思，绕清江卖不得天样纸。\n闲来唱会〔清江引〕，解放愁和闷。富贵在於天，生死由乎命，且开怀与知音谈笑饮。\n且天怀与知音谈笑饮，一曲瑶琴弄。弹出许多声，不与时人共，倚帏屏静中心自省。\n倚帏屏静中心自省，万事皆前定。穷通各有时，聚散非骄吝，立忠诚步步前程稳。\n立忠诚步步前程稳，勉励勤和慎。劝君且耐心，缓缓相随顺，好消息到头端的准。立春限金木水火土五字冠於每句之首，句各用春字金钗影摇春燕斜，木杪生春叶。水塘春始波，火候春初热，土牛儿载将春到也。\n","id":13,"section":"posts","summary":"清江引·弃微名去来心快哉 【元】贯云石 弃微名去来心快哉，一笑白云外。知音三五人，痛饮何妨碍？醉袍袖舞嫌天地窄。 竞功名有如车下坡，惊险谁参破？昨","tags":["诗词"],"title":"《清江引·弃微名去来心快哉》","uri":"https://rjguanwen.cn/2021/08/scsj-2/","year":"2021"},{"content":" 常用命令 #使用方法: hugo hugo [flags] hugo [command] hugo [command] [flags] #查看版本 hugo version #版本和环境详细信息 hugo env #创建新站点 hugo new site \u0026quot;$mysite\u0026quot; #创建文章 hugo new index.md 在content/文件夹可以看到，此时多了一个markdown格式的文件index.md，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。 #编译生成静态文件 hugo Hugo将编译所有文件并输出到public目录 #编译生成静态文件并启动web服务 hugo server  常用参数 --bind=\u0026quot;127.0.0.1\u0026quot; 服务监听IP地址； -p, --port=1313 服务监听端口； -w, --watch[=true] 监听站点目录，发现文件变更自动编译； -D, --buildDrafts 包括被标记为draft的文章； -E, --buildExpired 包括已过期的文章； -F, --buildFuture 包括将在未来发布的文章； -b, --baseURL=\u0026quot;www.datals.com\u0026quot; 服务监听域名； --log[=false]: 开启日志； --logFile=\u0026quot;/var/log/hugo.log\u0026quot;: log输出路径； -t, --theme=\u0026quot;\u0026quot; 指定主题； -v, --verbose[=false]: 输出详细信息  ","id":14,"section":"posts","summary":"常用命令 #使用方法: hugo hugo [flags] hugo [command] hugo [command] [flags] #查看版本 hugo version #版本和环境详细信息 hugo env #创建新站点 hugo new site \u0026quot;$mysite\u0026quot; #创建文章 hugo new index.md 在content/文件夹可以看","tags":["技术"],"title":"hugo 常用命令","uri":"https://rjguanwen.cn/2021/07/hugo_cmd/","year":"2021"},{"content":" 前言：没有比官网文档更好的资料了。看这里https://rasa.com/docs/rasa/\nrasa 安装 pip install -U rasa pip show rasa  注：我是用的 rasa 版本为 Version: 2.8.1\n初始化项目 1、 在工作文件夹中执行\n# 创建默认的初始化项目，加“--no-prompt”就避免了中间的问题提示 rasa init --no-prompt  该命令会在工作文件夹中创建一系列的文件，关键文件如下：\n config.yml : Rasa NLU 和 Rasa Core 的配置文件\n credentials.yml : 定义和其他服务连接的一些细节，例如rasa api接口\n data/nlu.yml : Rasa NLU 的训练数据\n data/stories.yml : Rasa stories 数据 data/rule.yml : Rasa 规则数据 endpoints.yml : 和外部消息服务对接的配置\n models/.tar.gz : 初始训练的模型数据\n  以上文件都打开看一下，基本能明白是啥意思。\n2、 训练模型\n如果添加了 NLU 或者 Core 数据，或者修改了domain和配置文件，需要重新训练模型：\nrasa train  3、 对话应用\nrasa shell  可能因训练数据的问题，bot 表现的挺傻的，呵呵~\n定制简单的中文对话 1、 建立工作目录\n创建一个新的工作文件夹，如 \u0026ldquo;rasa-zh-1\u0026rdquo;。\n在文件夹中直接用 rasa init --no-prompt 进行初始化\n2、 修改其中的关键内容\n domain.yml: 其中定义了意图和响应，将其修改为你需要的\n data/nul.yml: 其中意图的识别方式，每个意图都有些 “examples”\n data/stories.yml: 其中定义了多个情节（即对话剧本），为每个意图对应上了响应，用于机器学习训练方式\n data/rules.yml: 其中定于了基于规则的流程控制，只要满足规则，每次走的都是确定性分支  影响RASA会话流程的有2个配置，一个是Story，一个就是Rules！\n其中 config.yml 开头的语言配置 language: en 也应该修改，不过好像不该也行。\n根据需要将上面说的四个文件修改修改 \u0026hellip;\n3、训练并跑跑试试\nrasa train rasa shell  ","id":15,"section":"posts","summary":"前言：没有比官网文档更好的资料了。看这里https://rasa.com/docs/rasa/ rasa 安装 pip install -U rasa pip show rasa 注：我是用的 rasa 版本为 Version: 2.8.1 初","tags":["技术","python","rasa"],"title":"rasa 入门","uri":"https://rjguanwen.cn/2021/07/rasa-1/","year":"2021"},{"content":" rasa 支持多种语言模型与分词器，语言模型常用的有 MITIENLP 和 SpaCyNLP，分词器常用的有 WhitespaceTokenizer、JiebaTokenizer、MitieTokenizer、SpacyTokenizer 等。\nWhitespaceTokenizer 空格分词器，每个空格间隔的文本，都将分为一个token，典型的英文句子的分词。该分词器不支持中文分词。配置方式如下：\npipeline: - name: \u0026quot;WhitespaceTokenizer\u0026quot; # Flag to check whether to split intents \u0026quot;intent_tokenization_flag\u0026quot;: False # Symbol on which intent should be split \u0026quot;intent_split_symbol\u0026quot;: \u0026quot;+\u0026quot; # Regular expression to detect tokens \u0026quot;token_pattern\u0026quot;: None  intent_tokenization_flag和intent_split_symbol是在nlu返回多意图的时候使用。当intent_tokenization_flag设置为False，nlu只返回一个置信度最高的意图。但有些时候，一句话包含多个意图，例如：\n## intent: affirm+ask_transport - Yes. How do I get there? - Sounds good. Do you know how I could get there from home?  用户的回答包含2层意思，首先是同意我的建议，另外是询问怎么去。这时候，需要将intent_tokenization_flag设置为True，然后在训练数据里面编写多意图对应的话术，多个意图中间用intent_split_symbol去分割。在运行的时候，用户说“Sounds good. Do you know how I could get there from home?”，Rasa nlu就会返回affirm+ask_transport这个意图。\ntoken_pattern是一个正则表达式，是对分词后的结果做后处理，过程是这样：先对一句话进行分词，生成一个序列，然后将序列中每个token再应用到token_pattern处理一次，将新生成的词也放在最终分词列表里面。\nJiebaTokenizer jieba分词器，仅可以在中文分词使用，支持自定义词库分词。词库的配置方法如下：\npipeline: - name: \u0026quot;JiebaTokenizer\u0026quot; dictionary_path: \u0026quot;path/to/custom/dictionary/dir\u0026quot; # Flag to check whether to split intents \u0026quot;intent_tokenization_flag\u0026quot;: False # Symbol on which intent should be split \u0026quot;intent_split_symbol\u0026quot;: \u0026quot;_\u0026quot; # Regular expression to detect tokens \u0026quot;token_pattern\u0026quot;: None  其中，dictionary_path是字典文件所在路径。\nSpaCyNLP spaCy是一个用Python和Cython编写的高级自然语言处理的库。它跟踪最新的研究成果，并将其应用到实际产品。spaCy带有预训练的统计模型和单词向量，目前支持60多种语言。它用于标记任务，解析任务和命名实体识别任务的卷积神经网络模型，在非常快速的情况下，达到比较好的效果，并且易于在产品中集成应用。\n1、安装并下载语言模型包：\npip install -U spacy # 中文包 python -m spacy download zh_core_web_sm # 英文包 python -m spacy download en_core_web_sm  如果通过命令下载不下来，可以下载包到本地安装。如下：\n1.到 https://spacy.io/ 下载响应的语言包\n2.使用 pip 进行安装，如：\n# 中文包 pip install \\你的下载路径\\zh_core_web_sm-3.1.0-py3-none-any.whl pip install \\你的下载路径\\zh_core_web_sm-3.1.0.tar.gz # 英文包 pip install \\你的下载路径\\en_core_web_sm-3.1.0-py3-none-any.whl pip install \\你的下载路径\\en_core_web_sm-3.1.0.tar.gz   SpaCy的语言支撑的很多，每种语言又有不同的包，根据需要恰当选择吧\n2、rasa 中配置：\n简单配置：\npipeline: - name: \u0026quot;SpacyNLP\u0026quot; model: \u0026quot;zh_core_web_sm\u0026quot;  更多的配置，具体参见 https://rasa.com/docs/rasa/language-support#spacy ：\npipeline: - name: \u0026quot;SpacyNLP\u0026quot; # language model to load model: \u0026quot;zh_core_web_sm\u0026quot; - name: \u0026quot;SpacyTokenizer\u0026quot; # Flag to check whether to split intents \u0026quot;intent_tokenization_flag\u0026quot;: False # Symbol on which intent should be split \u0026quot;intent_split_symbol\u0026quot;: \u0026quot;_\u0026quot; # Regular expression to detect tokens \u0026quot;token_pattern\u0026quot;: None - name: \u0026quot;SpacyFeaturizer\u0026quot; # Specify what pooling operation should be used to calculate the vector of # the complete utterance. Available options: 'mean' and 'max'. \u0026quot;pooling\u0026quot;: \u0026quot;mean\u0026quot;  此处配置要注意引号和下划线的问题\u0026hellip;\n修改 config.yml 的时候别忘记修改最开头的语言配置 language: en\n！！！不知为啥，我配上SpaCy后，rasa shell 就会 TimeoutError。暂时不知原因，回头解决吧！！！\n另，默认超时时间要修改的话，到这：$python安装目录$\\Lib\\site-packages\\rasa\\core\\channels\\console.py，修改 DEFAULT_STREAM_READING_TIMEOUT_IN_SECONDS = 10 为所需的值即可。\n  ","id":16,"section":"posts","summary":"rasa 支持多种语言模型与分词器，语言模型常用的有 MITIENLP 和 SpaCyNLP，分词器常用的有 WhitespaceTokenizer、JiebaToken","tags":["技术","python","rasa"],"title":"rasa 继续入门 - 语言模型与分词器","uri":"https://rjguanwen.cn/2021/07/rasa-2/","year":"2021"},{"content":" Anaconda 虚拟环境基础操作 创建 创建的同时可以同时指定安装必要的包：\nconda create -n \u0026lt;虚拟环境名\u0026gt; [包名1 包名2 包名3] python=3.6  激活虚拟环境 Linux:\nsource activate \u0026lt;虚拟环境名\u0026gt;  Windows：\nactivate \u0026lt;虚拟环境名\u0026gt;  退出虚拟环境 Linux：\nsource deactivate \u0026lt;虚拟环境名\u0026gt;  Windows：\ndeactivate \u0026lt;虚拟环境名\u0026gt;  删除虚拟环境 conda remove -n \u0026lt;虚拟环境名\u0026gt; --all  其他 conda 常用命令  conda list：查看安装了哪些包\n conda install package_name(包名)：安装包\n conda env list 或 conda info -e：查看当前存在哪些虚拟环境\n conda update conda：检查更新当前conda\n  ","id":17,"section":"posts","summary":"Anaconda 虚拟环境基础操作 创建 创建的同时可以同时指定安装必要的包： conda create -n \u0026lt;虚拟环境名\u0026gt; [包名1 包名2 包名3] python=3.6 激活虚拟环境 Linux: source activate \u0026lt;","tags":["技术","python"],"title":"Anaconda 虚拟环境基础操作","uri":"https://rjguanwen.cn/2021/02/python-1/","year":"2021"},{"content":" Apache Superset 简介 概要信息    项目 说明     官网 https://superset.apache.org/   开源/闭源 开源   源码管理地址 https://github.com/apache/incubator-superset/wiki   License类别 Mozilla Public License 2.0   开发语言 GO   操作系统支持 跨平台，支持多种操作系统    主要特性 Apache Superset是一款快速直观的轻量级工具，具有丰富的功能选项，各种用户都可以轻松地以可视化的方式浏览数据，从简单的折线图到高度详细的地理空间图，Apache Superset无所不能，提供了如下主要特性：\n 强大易用：可以快速容易地集成，从而浏览数据，而这一切通过SQL IDE或者无需编写代码，通过可视化构建器即可完成。\n 架构设计：Superset轻巧且极具可扩展性，它可以利用既存的数据基础框架而不需要另外一个接收层。\n 丰富的可视化方式与仪表盘：Superset提供了多种精美的可视化效果。可视化插件体系结构使得构建自定义的可视化变得更为容易。\n 支持多种数据库：可以通过SQL Alchemy连接到任何基于SQL的数据源，包括云原生的数据库以及PB级的数据引擎。比如：\n  基于 docker 部署使用 1、 下载 superset 镜像\ndocker search superset  选择 STARTS 最高的镜像\ndocker pull amancevice/superset  2、启动并初始化\n创建挂载目录：\nmkdir /opt/docker/superset/conf \u0026amp; mkdir /opt/docker/superset/data  启动镜像：\ndocker run --name superset -u 0 -d -p 8088:8088 -v /opt/docker/superset/conf:/etc/superset -v /opt/docker/superset/data:/var/lib/superset amancevice/superset  初始化 superset：\ndocker exec -it superset superset-init  此过程中，需要设置管理员用户名与密码。\n3、使用 superset 访问url：http://localhost:8088\n使用设置的管理员用户/密码登录系统\n加载样例数据：\ndocker exec -it superset superset load_examples  基于 python 虚拟环境部署 1、创建虚拟环境\nconda create -n superset python=3.6  创建完成后，启动\nactivate superset  2、安装\n为保证速度，使用国内源安装，如清华、豆瓣等。\n 安装必须的依赖：\npip install setuptools_rust dataclasses pillow  安装 superset :\npip install apache-superset  初始化数据库：\nsuperset db upgrade  运行superset，创建用户：\n# Create an admin user (you will be prompted to set a username, first and last name before setting a password) $ export FLASK_APP=superset superset fab create-admin # Load some data to play with（多半会失败，不需要样例则忽略） superset load_examples # Create default roles and permissions superset init # To start a development web server on port 8088, use -p to bind to another port（只能本地访问） superset run -p 8088 --with-threads --reload --debugger # 如果需要远程访问，需要使用以下命令运行superset superset run -h 0.0.0.0 -p 8089   ","id":18,"section":"posts","summary":"Apache Superset 简介 概要信息 项目 说明 官网 https://superset.apache.org/ 开源/闭源 开源 源码管理地址 https://github.com/apache/incubator-superset/wiki License类别 Mozilla Public License 2.0 开发语言 GO 操作系统支持 跨平台，支持多种操作系统 主要特性 Apache","tags":["技术","Superset"],"title":"Apache Superset 简介","uri":"https://rjguanwen.cn/2021/01/superset_01/","year":"2021"},{"content":" Apache Ignite 实践记录 使用 Docker 安装 基于 win10 WSL2(Ubuntu)\n 创建本地目录\nmkdir ignite_dir  使用本地目录启动持久化集群\ndocker run -d \\ -v ${PWD}/ignite_dir:/storage \\ -e IGNITE_WORK_DIR=/storage \\ apacheignite/ignite:2.9.0  使用自定义配置文件\n 通过 URI 传递配置文件\ndocker run -d \\ -e CONFIG_URI=http://myserver/config.xml \\ apacheignite/ignite:2.9.0  使用本地配置文件\ndocker run -d \\ -v /local/dir/config.xml:/config-file.xml \\ -e CONFIG_URI=/config-file.xml \\ apacheignite/ignite:2.9.0   启用模块 要启用特定模块，需要在 OPTION_LIBS 系统变量中指定。\nsudo docker run -d \\ -e \u0026quot;OPTION_LIBS=ignite-rest-http,ignite-aws\u0026quot; \\ apacheignite/ignite:2.9.0  Ignite 的 Docker 镜像默认会启用 ignite-log4j、ignite-spring、ignite-indexing 等模块。\n 环境变量\n     名称 描述 默认     CONFIG_URI Ignite配置文件的URL，下载的配置文件会保存于./ignite-config.xml 无   OPTION_LIBS 会被包含在类路径中的可选库 ignite-log4j, ignite-spring,ignite-indexing   JVM_OPTS 传递给Ignite实例的JVM参数 无   EXTERNAL_LIBS 库文件URL列表 无     web-console\n拉取 Ignite Web Console 镜像：\ndocker pull apacheignite/web-console-standalone  运行 docker：\ndocker run -d -p 80:80 -v ${PWD}/mongo:/var/lib/mongodb --name web-console-standalone apacheignite/web-console-standalone   ","id":19,"section":"posts","summary":"Apache Ignite 实践记录 使用 Docker 安装 基于 win10 WSL2(Ubuntu) 创建本地目录 mkdir ignite_dir 使用本地目录启动持久化集群 docker run -d \\ -v ${PWD}/ignite_dir:/storage \\ -e IGNITE_WORK_DIR=/storage \\ apacheignite/ignite:2.9.0 使用自定义配置文件 通过 URI 传递配置文件 docker run -d \\ -e","tags":["技术","Ignite"],"title":"Apache Ignite 实践记录","uri":"https://rjguanwen.cn/2021/01/ignite_02/","year":"2021"},{"content":" 在 win10 的 Linux 子系统中实现 docker 的安装使用 1、安装 WSL2 此处注意，一定是 WSL2！wsl 坑太多，经常有莫名错误！\n1. 配置 WSL2  开启WSL 以管理员运行 Powershell：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux  之后重启计算机。\n 启用“虚拟机平台”可选组件：\n以管理员运行 Powershell：\nEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform  之后重启计算机。\n 默认启用 WSL2\n运行 Powershell：\nwsl --set-default-version 2   2. 安装配置 Ubuntu  安装 Ubuntu 打开 Microsoft Store，搜索 ubuntu 并安装。\n之后启动刚刚安装的 Ubuntu。\n 设置 Ubuntu 系统的 root 密码 Ubuntu 的默认 root 密码是随机的，即每次开机都有一个新的 root 密码。要修改密码，可在终端输入命令：\n$ sudo passwd  输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是 root 新密码。\n  2、安装 Docker 以管理员身份运行 Ubuntu，在终端中依次执行以下命令：\n$ sudo apt-get remove docker docker-engine docker.io  $ sudo apt-get update  $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common  $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  $ sudo add-apt-repository \\ \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\u0026quot;  $ sudo apt-get update  $ sudo apt-get install docker-ce  3、启动运行 sudo service docker start  查看 docker 版本：\n$ docker -v  通过运行hello-world映像验证是否正确安装了Docker CE：\n$ sudo docker run hello-world  4、其他问题  安装指定版本的docker\n$ sudo apt-get install docker-ce=\u0026lt;VERSION\u0026gt;  其中\u0026lt;VERSION\u0026gt;可以通过以下命令查询：\n$ apt-cache madison docker-ce  报没有权限的错误\n如：“Got permission denied while trying to connect to the Docker daemon socket at unix:///var//run/docker.sock: \u0026hellip;..”\n从提示可以看出问题在于当前用户的权限不足以连接“/var/run/docker.sock”这个套接字文件，可以将普通用户加入 docker 用户组来解决：\n$ sudo gpasswd -a \u0026lt;username\u0026gt; docker #将普通用户username加入到docker组  $ newgrp docker #更新docker组  忘记 Ubuntu 用户密码\n1、 关闭 Ubuntu 窗口\n2、 打开 Powershell 或 cmd， 以 root 默认登陆 wsl -u root\n3、 别关，在这个cmd窗口内输入 wsl 进入\n4、 输入 passwd \u0026lt;your_username\u0026gt; ，确认密码\n5、 关闭 WSL exit\n 更换 docker 镜像源\nsudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-'EOF' { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://sx1pmhon.mirror.aliyuncs.com\u0026quot;] } EOF sudo service docker restart   ","id":20,"section":"posts","summary":"在 win10 的 Linux 子系统中实现 docker 的安装使用 1、安装 WSL2 此处注意，一定是 WSL2！wsl 坑太多，经常有莫名错误！ 1. 配置 WSL2 开启WSL 以管理员运行 Powers","tags":["技术","docker"],"title":"win10 的 Linux 子系统中安装 docker","uri":"https://rjguanwen.cn/2021/01/docker_wsl/","year":"2021"},{"content":" Apache Ignite 简介 待完善\n","id":21,"section":"posts","summary":"Apache Ignite 简介 待完善","tags":["技术","Ignite"],"title":"Apache Ignite 简介","uri":"https://rjguanwen.cn/2020/12/ignite_01/","year":"2020"},{"content":"心态对人的精神影响巨大，好的心态带来全新的精神面貌，希望能坚持！\n 校准情绪时间线\n不要让情绪停留在过去，出现问题不要想“早知如此”。情绪停留在过去，不会解决手头上的问题；更可怕的是，它还会产生新的矛盾，影响你现在和未来的心情和人际关系。\n 努力绕开负面情绪，从正面到负面很容易，但是从负面到正面会非常难\n多想想今天发生的好的事情；记下值得开心的小确幸，有空就翻翻。\n 不要沉浸在负面情绪中无法自拔\n人不会被强烈、持续时间长的痛苦打倒，却会被不那么强烈的、一时的破事击溃。\n 相信人好的一面\n当有事件发生时，在“相信人好的一面”与“相信人坏的一面”之间，当没有确凿证据时选择前者。\n “自私”无罪，避免讨好型人格\n 保持无知的心态\n 每次一小步，走出舒适圈\n  ","id":22,"section":"posts","summary":"心态对人的精神影响巨大，好的心态带来全新的精神面貌，希望能坚持！ 校准情绪时间线 不要让情绪停留在过去，出现问题不要想“早知如此”。情绪停留在过","tags":["个人"],"title":"锻炼好心态","uri":"https://rjguanwen.cn/2020/12/nine_attitude/","year":"2020"},{"content":" 与龚惟长先生书 【明】袁宏道\n数年闲散，惹一场忙在后。如此人置如此地，作如此事，奈之何？嗟夫，电光泡影，后岁知几何？而奔走尘土，无复生人半刻之乐，名虽作官，实当官耳。 尊家道隆崇，百无一阙，岁月如花，乐何可言。然真乐有五，不可不知。目极世间之色，耳极世间之声，身极世间之鲜，口极世间之谭，一快活也。堂前列鼎，堂后度曲，宾客满席，男女交舄，烛气熏天，珠翠委地，金钱不足，继以田土，二快活也。箧中藏万卷书，书皆珍异。宅畔置一馆，馆中约真正同心友十余人，人中立一识见极高，如司马迁、罗贯中、关汉卿者为主，分曹部署，各成一书，远文唐宋酸儒之陋，近完一代未竟之篇，三快活也。千金买一舟， 舟中置鼓吹一部，妓妾数人，游闲数人，泛家浮宅，不知老之将至，四快活也。然人生受用至此，不及十年，家资田地荡尽矣。然后一身狼狈，朝不谋夕，托钵歌妓之院，分餐孤老之盘，往来乡亲，恬不知耻，五快活也。士有此一者，生可无愧，死可不朽矣。若只幽闲无事，挨排度日，此最世间不紧要人，不可为训。古来圣贤，公孙朝穆、谢安、孙玚辈，皆信得此一着，此所以他一生受用。不然，与东邻某子甲蒿目而死者，何异哉！\n","id":23,"section":"posts","summary":"与龚惟长先生书 【明】袁宏道 数年闲散，惹一场忙在后。如此人置如此地，作如此事，奈之何？嗟夫，电光泡影，后岁知几何？而奔走尘土，无复生人半刻之乐","tags":["小品文"],"title":"《与龚惟长先生书》","uri":"https://rjguanwen.cn/2020/10/rswl/","year":"2020"},{"content":" 你还在我身旁 瀑布的水逆流而上\n蒲公英的种子从远处飘回 聚成伞的模样\n太阳从西边升起 落向东方\n子弹退回枪膛\n运动员回到起跑线上\n我交回录取通知书 忘了十年寒窗\n厨房里飘来饭菜的香\n你把我的卷子签好名字\n关掉电视 帮我把书包背上\n你还在我身旁\n","id":24,"section":"posts","summary":"你还在我身旁 瀑布的水逆流而上 蒲公英的种子从远处飘回 聚成伞的模样 太阳从西边升起 落向东方 子弹退回枪膛 运动员回到起跑线上 我交回录取通知书 忘了十年寒","tags":["现代诗"],"title":"《你还在我身旁》","uri":"https://rjguanwen.cn/2020/10/xds-1/","year":"2020"},{"content":" 浣溪沙 · 谁念西风独自凉 【清】纳兰性德\n谁念西风独自凉，\n萧萧黄叶闭疏窗，\n沉思往事立残阳。\n被酒莫惊春睡重，\n赌书消得泼茶香，\n当时只道是寻常。\n木兰花令 · 拟古决绝词 【清】纳兰性德\n人生若只如初见，何事秋风悲画扇。\n等闲变却故人心，却道故人心易变。\n骊山语罢清宵半，泪雨霖铃终不怨。\n何如薄幸锦衣郎，比翼连枝当日愿。\n浣溪沙 【清】纳兰性德\n残雪凝辉冷画屏，\n落梅横笛已三更，\n更无人处月胧明。\n我是人间惆怅客，\n知君何事泪纵横，\n断肠声里忆平生。\n","id":25,"section":"posts","summary":"浣溪沙 · 谁念西风独自凉 【清】纳兰性德 谁念西风独自凉， 萧萧黄叶闭疏窗， 沉思往事立残阳。 被酒莫惊春睡重， 赌书消得泼茶香， 当时只道是寻常。 木兰花令","tags":["诗词"],"title":"纳兰性德诗词一","uri":"https://rjguanwen.cn/2020/10/nlxd-1/","year":"2020"},{"content":" 定风波 · 南海归赠王定国侍人寓娘 【宋】苏轼\n常羡人间琢玉郎，\n天应乞与点酥娘。\n尽道清歌传皓齿，\n风起，雪飞炎海变清凉。\n万里归来颜愈少，\n微笑，笑时犹带岭梅香。\n试问岭南应不好，\n却道：此心安处是吾乡。\n","id":26,"section":"posts","summary":"定风波 · 南海归赠王定国侍人寓娘 【宋】苏轼 常羡人间琢玉郎， 天应乞与点酥娘。 尽道清歌传皓齿， 风起，雪飞炎海变清凉。 万里归来颜愈少， 微笑，笑时犹带","tags":["诗词"],"title":"《定风波·南海归赠王定国侍人寓娘》","uri":"https://rjguanwen.cn/2020/10/dfb-1/","year":"2020"},{"content":" 1、查看当前安装的 git 版本 git --version  2、更新 git 版本是 2.17.1 之前的：\ngit update  git 版本是 2.17.1 之后的：\ngit update-git-for-windows  3、如出现错误 重新下载新版本安装包，覆盖安装即可：https://git-scm.com/download/win\n","id":27,"section":"posts","summary":"1、查看当前安装的 git 版本 git --version 2、更新 git 版本是 2.17.1 之前的： git update git 版本是 2.17.1 之后的： git update-git-for-windows 3、如出现错误 重新下载新版本安装包，覆盖安装即可：https","tags":["技术","GIT"],"title":"Windows 更新 git 版本","uri":"https://rjguanwen.cn/2020/09/git_04/","year":"2020"},{"content":" 六州歌头 · 少年侠气 【宋】贺铸\n少年侠气，交结五都雄。\n肝胆洞，毛发耸。\n立谈中，死生同。\n一诺千金重。\n推翘勇，矜豪纵。\n轻盖拥，联飞鞚，斗城东。\n轰饮酒垆，春色浮寒瓮，吸海垂虹。\n闲呼鹰嗾犬，白羽摘雕弓，狡穴俄空。\n乐匆匆。\n似黄粱梦，辞丹凤；明月共，漾孤蓬。\n官冗从，怀倥偬；落尘笼，簿书丛。\n鹖弁如云众，供粗用，忽奇功。\n笳鼓动，渔阳弄，思悲翁。\n不请长缨，系取天骄种，剑吼西风。\n恨登山临水，手寄七弦桐，目送归鸿。\n","id":28,"section":"posts","summary":"六州歌头 · 少年侠气 【宋】贺铸 少年侠气，交结五都雄。 肝胆洞，毛发耸。 立谈中，死生同。 一诺千金重。 推翘勇，矜豪纵。 轻盖拥，联飞鞚，斗城东。 轰饮酒","tags":["诗词"],"title":"《六州歌头·少年侠气》","uri":"https://rjguanwen.cn/2020/08/lzgt/","year":"2020"},{"content":" 南吕·一枝花·不服老 【元】关汉卿\n攀出墙朵朵花，折临路枝枝柳；\n花攀红蕊嫩，柳折翠条柔。\n浪子风流。\n凭着我折柳攀花手，直煞得花残柳败休。\n半生来折柳攀花， 一世里眠花卧柳。\n[梁州]我是个普天下郎君领袖，盖世界浪子班头。\n愿朱颜不改常依旧，花中消遣，酒内忘忧。\n分茶扌颠竹，打马藏阄，通五音六律滑熟，甚闲愁到我心头？\n伴的是银筝女，银台前、理银筝、笑倚银屏；\n伴的是玉天仙，携玉手、并玉肩、同登玉楼；\n伴的是金钗容，歌金缕、捧金樽、满泛金瓯。\n你道我老也，暂休。\n占排场风月功名首，更玲珑又剔透，我是个锦阵花营都帅头，曾翫府游州。\n[隔尾]子弟每是个茅草岗、沙土窝、初生的兔羔儿，乍向围场上走；\n我是个经笼罩，受索网、苍瓴毛老野鸡，蹅踏得阵马儿熟。\n经了些窝弓冷箭鑞枪头，不曾落人后，恰不道人到中年万事休，我怎肯虚度了春秋。\n[尾]我是个蒸不烂、煮不熟、槌不匾、炒不爆、响当当一粒铜豌豆；\n恁子弟每谁教你钻入他锄不断、斫不下、解不开、顿不脱、慢腾腾千层锦套头。\n我翫的是梁园月，饮的是东京酒，赏的是洛阳花，攀的是章台柳。\n我也会围棋、会蹴踘、会打围、会插科、会歌舞、会吹弹、会口燕作、会吟诗、会双陆。\n你便是落了我牙，歪了我嘴，瘸了我腿，折了我手，天赐与我这几般儿歹症候，尚兀自不肯休。\n则除是阎王亲自唤，神鬼自来勾，三魂归地府，七魄丧冥幽，天哪，那其间才不向烟花路儿上走！\n","id":29,"section":"posts","summary":"南吕·一枝花·不服老 【元】关汉卿 攀出墙朵朵花，折临路枝枝柳； 花攀红蕊嫩，柳折翠条柔。 浪子风流。 凭着我折柳攀花手，直煞得花残柳败休。 半生来折柳","tags":["诗词"],"title":"《南吕·一枝花·不服老》","uri":"https://rjguanwen.cn/2020/08/yzh/","year":"2020"},{"content":" \u0026lt;部分内容借鉴自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\nGo 文件操作总结 1、基本操作 1.1 创建文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { newFile, err := os.Create(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } newFile.Close() }  1.2 Truncate文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main(){ // 裁剪一个文件到100个字节。 // 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。 // 如果文件本来超过100个字节，则超过的字节会被抛弃。 // 这样我们总是得到精确的100个字节的文件。 // 传入0则会清空文件。 err := os.Truncate(\u0026quot;example_1.txt\u0026quot;, 100) if err != nil { log.Fatal(err) } }  1.3 获取文件信息 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main(){ fi, err := os.Stat(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;文件名：\u0026quot;,fi.Name()) fmt.Println(\u0026quot;文件大小：\u0026quot;, fi.Size()) fmt.Println(\u0026quot;权限：\u0026quot;, fi.Mode()) fmt.Println(\u0026quot;最后修改时间：\u0026quot;, fi.ModTime()) fmt.Println(\u0026quot;是否文件夹：\u0026quot;, fi.IsDir()) fmt.Println(\u0026quot;系统信息：\u0026quot;, fi.Sys()) }  1.4 重命名和移动 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 在 windows 下，通过 Rename 将文件跨卷移动，会报错 // 当文件 open 后，未 close 时，Rename 方法貌似不起作用， // 并且也不会报错，需要注意 oldPath := \u0026quot;example_1.txt\u0026quot; newPath := \u0026quot;example_4.txt\u0026quot; err := os.Rename(oldPath, newPath) if err != nil { log.Fatal(err) } }  1.5 删除文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { err := os.Remove(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } }  1.6 打开和关闭文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 以只读方式打开文件 file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } file.Close() // 第二个参数为打开文件时的属性，可以多个组合使用 // 第三个参数为权限模式 file, err = os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_APPEND, 0666) if err != nil { log.Fatal(err) } file.Close() // 以下为可组合使用的文件属性 //os.O_RDONLY\t// 只读 //os.O_WRONLY\t// 只写 //os.O_RDWR\t// 读写 //os.O_APPEND\t// 向文件中添加 //os.O_CREATE\t// 如果文件不存在则先创建 //os.O_TRUNC\t// 文件打开时裁剪文件 //os.O_EXCL\t// //os.O_SYNC\t// 以同步I/O方式打开 }  1.7 检查文件是否存在 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) func main() { _, err := os.Stat(\u0026quot;example_2.txt\u0026quot;) fileExist := err == nil || os.IsExist(err) fmt.Println(fileExist) }  1.8 检查读写权限 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 测试写权限，如果文件是只读或者其他原因导致不具备写入权限，则返回 error file, err := os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_WRONLY, 0666) if err != nil { if os.IsPermission(err) { log.Println(\u0026quot;错误：无写入权限！\u0026quot;) } } file.Close() // 测试读权限 file, err = os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_RDONLY, 0666) if err != nil { if os.IsPermission(err) { log.Println(\u0026quot;错误：无读取权限！\u0026quot;) } } file.Close() }  1.9 改变权限、拥有者、时间戳 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;time\u0026quot; ) func main() { // 使用 Linux 风格改变文件权限 err := os.Chmod(\u0026quot;example_1.txt\u0026quot;, 0777) if err != nil { log.Println(err) } // 改变文件所有者 (not supported by windows) err = os.Chown(\u0026quot;example_1.txt\u0026quot;, os.Getuid(), os.Getgid()) if err != nil { log.Println(err) } // 改变时间戳 oneDaysFromNow := time.Now().Add(24 * time.Hour) lastAccessTime := oneDaysFromNow lastModifyTime := oneDaysFromNow err = os.Chtimes(\u0026quot;example_1.txt\u0026quot;, lastAccessTime, lastModifyTime) if err != nil { log.Println(err) } }  1.10 硬链接与软链接 一个普通的文件是一个指向硬盘的inode的地方。\n硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。\nsymbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。\npackage main import ( \u0026quot;os\u0026quot; \u0026quot;log\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { // 创建一个硬链接。 // 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。 // 删除和重命名不会影响另一个。 err := os.Link(\u0026quot;original.txt\u0026quot;, \u0026quot;original_also.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;creating sym\u0026quot;) // Create a symlink err = os.Symlink(\u0026quot;original.txt\u0026quot;, \u0026quot;original_sym.txt\u0026quot;) if err != nil { log.Fatal(err) } // Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。 // Symlink在Windows中不工作。 fileInfo, err := os.Lstat(\u0026quot;original_sym.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;Link info: %+v\u0026quot;, fileInfo) //改变软链接的拥有者不会影响原始文件。 err = os.Lchown(\u0026quot;original_sym.txt\u0026quot;, os.Getuid(), os.Getgid()) if err != nil { log.Fatal(err) } }  2、读写文件 2.1 复制文件 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { //打开文件 oFile, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer oFile.Close() // 创建新文件 nFile, err := os.Create(\u0026quot;example_copy.txt\u0026quot;) if err != nil { log.Fatalln(err) } defer nFile.Close() // 从源文件复制字节到目标文件 bytesWritten, err := io.Copy(nFile, oFile) if err != nil { log.Fatalln(err) } log.Printf(\u0026quot;已复制 %d 字节。\u0026quot;, bytesWritten) err = nFile.Sync() if err != nil { log.Fatal(err) } }  2.2 跳转到文件指定位置（Seek） package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, _ := os.Open(\u0026quot;example_1.txt\u0026quot;) defer file.Close() // 偏离位置，可以是正数也可以是负数 var offset int64 = 5 // offset 的初始位置，即相对那个位置进行偏移 // 0 ：文件开始位置 os.SEEK_SET // 1 ：当前位置 os.SEEK_CUR // 2 ：文件结尾位置 os.SEEK_END var whence int = 0 newPosition, err := file.Seek(offset, whence) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;向前移动 5：\u0026quot;, newPosition) // 从当前位置回退 3 个字节 newPosition, err = file.Seek(-3, os.SEEK_CUR) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;向后移动 2：\u0026quot;, newPosition) // 获取当前位置 currentPosition, err := file.Seek(0, 1) fmt.Println(\u0026quot;当前位置：\u0026quot;, currentPosition) // 转到文件开始处 newPosition, err = file.Seek(0, 0) if err != nil { log.Fatal(err) } //fmt.Println(newPosition) }  2.3 写文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 以可写方式打开文件 file, err := os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_WRONLY | os.O_TRUNC | os.O_CREATE, 0666, ) if err != nil { log.Fatal(err) } defer file.Close() byteSlice := []byte(\u0026quot;Hello!\\n\u0026quot;) bytesWriteen, err := file.Write(byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;写入 %d 个字节. \\n\u0026quot;, bytesWriteen) }  2.4 快写文件 ioutil 包有一个方法 WriteFile() 可以处理创建/打开文件、写字节切片和关闭文件一些列的操作。如果你需要简洁快速地写字节切片到文件中，可以使用它。\npackage main import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; ) func main() { err := ioutil.WriteFile(\u0026quot;example_1.txt\u0026quot;, []byte(\u0026quot;Hi, world!\\n\u0026quot;), 0666) if err != nil { log.Fatal(err) } }  2.5 使用缓存写 bufio 包提供了带缓存功能的writer，你可以在写字节到硬盘前使用内存缓存。当你处理很多数据时会很有用，因为它可以节省操作硬盘 I/O 的时间，大大提升性能并减少硬盘磨损。\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_WRONLY, 0666) if err != nil { log.Fatal(err) } defer file.Close() // 创建 buffered writer bufferedWriter := bufio.NewWriter(file) // 写字节到 buffer bytesWritten, err := bufferedWriter.Write([]byte{65, 66, 67},) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;写入字节数：%d \\n\u0026quot;, bytesWritten) // 写字符串到 buffer bytesWritten, err = bufferedWriter.WriteString(\u0026quot;Hello, buffer!\\n\u0026quot;) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;写入字节数：%d \\n\u0026quot;, bytesWritten) // 检查缓存中的字节数 unflushedBufferSize := bufferedWriter.Buffered() log.Printf(\u0026quot;缓存的字节数：%d \\n\u0026quot;, unflushedBufferSize) // 还有多少字节可用（未使用的缓存大小） bytesAvailable := bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存1：%d \\n\u0026quot;, bytesAvailable) // 写缓存到硬盘 bufferedWriter.Flush() bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存2：%d \\n\u0026quot;, bytesAvailable) // 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer // 当你想将缓存传给另外一个writer时有用 bufferedWriter.Reset(bufferedWriter) bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存3：%d \\n\u0026quot;, bytesAvailable) // 重新设置缓存的大小 // 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。 // 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存， // 而是writer的原始大小的缓存，默认是4096。 // 它的功能主要还是为了扩容。 bufferedWriter = bufio.NewWriterSize( bufferedWriter, 8000, ) // resize 后检查缓存大小 bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存4：%d \\n\u0026quot;, bytesAvailable) // 设置 resize 值小于当前缓存大小，此时是不起作用的 bufferedWriter = bufio.NewWriterSize( bufferedWriter, 800, ) bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存5：%d \\n\u0026quot;, bytesAvailable) }  2.6 读取最多 N 个字节 os.File 提供了文件操作的基本功能，而 io、ioutil、bufio 提供了额外的辅助函数。\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 以只读模式打开文件 file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer file.Close() // 从文件中读取指定长度的字节数据 byteSlice := make([]byte, 20) bytesRead, err := file.Read(byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的字节数据长度：%d\\n\u0026quot;, bytesRead) log.Printf(\u0026quot;读取到的数据：%s \\n\u0026quot;, byteSlice) }  2.7 读取正好 N 个字节 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } // file.Read()可以读取一个小文件到大的byte slice中， // 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误 byteSlice := make([]byte, 5) numBytesRead, err := io.ReadFull(file, byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的字节数: %d\\n\u0026quot;, numBytesRead) log.Printf(\u0026quot;读取到的数据: %s\\n\u0026quot;, byteSlice) }  2.8 读取至少 N 个字节 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 打开文件，只读 file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } byteSlice := make([]byte, 512) minBytes := 18 // io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留 numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的字节数: %d\\n\u0026quot;, numBytesRead) log.Printf(\u0026quot;读取到的数据: %s\\n\u0026quot;, byteSlice) }  2.9 读取全部字节 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } // os.File.Read(), io.ReadFull() 和 // io.ReadAtLeast() 在读取之前都需要一个固定大小的byte slice。 // 但ioutil.ReadAll()会读取reader(这个例子中是file)的每一个字节，然后把字节slice返回。 data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取到的数据（十六进制）: %x\\n\u0026quot;, data) fmt.Printf(\u0026quot;读取到的数据（字符串）: %s\\n\u0026quot;, data) fmt.Println(\u0026quot;读取到的数据长度:\u0026quot;, len(data)) }  2.10 快读到内存 package main import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; ) func main() { // 直接读取，省略掉文件打开与关闭操作 data, err := ioutil.ReadFile(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的数据：%s \\n\u0026quot;, data) }  2.11 使用缓存读 缓存 reader 会把一些内容缓存在内存中，它提供了比 os.File 和 io.Reader 更多的函数，缺省的缓存大小是 4096，最小缓存是 16。\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) // 使用缓存读 func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } bufferedReader := bufio.NewReader(file) // 读取字节，当前指针不变 byteSlice := make([]byte, 5) byteSlice, err = bufferedReader.Peek(5) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取 5 个字节：%s \\n\u0026quot;, byteSlice) // 读取，指针同时移动 numBytesRead, err := bufferedReader.Read(byteSlice) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取 %d 个字节：%s \\n\u0026quot;, numBytesRead, byteSlice) // 读取一个字节，如果不成功会返回 error myByte, err := bufferedReader.ReadByte() if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取一个字节：%c \\n\u0026quot;, myByte) // 读取到分隔符，包含分隔符 dataBytes, err := bufferedReader.ReadBytes('\\n') if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取字节：%s \\n\u0026quot;, dataBytes) // 读取到分隔符，包含分隔符，返回字符串 dataString, err := bufferedReader.ReadString('\\n') if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取字符串：%s \\n\u0026quot;, dataString) }  2.12 使用 scanner Scanner 是 bufio 包下的类型，在处理文件中以分隔符分隔的文本时很有用。\n通常我们使用换行符作为分隔符将文件内容分成多行。在 CSV 文件中，逗号一般作为一行内不同元素之间的分隔符。\nos.File 文件可以被包装成 bufio.Scanner，它就像一个缓存 reader。\n我们会调用 Scan() 方法去读取下一个分隔符，使用 Text() 或者 Bytes() 获取读取的数据。\n分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。\n如果没有定制的 SplitFunc 提供，缺省的 ScanLines 会使用 newLine 字符作为分隔符，其他的分隔函数还包括 ScanRunes 和 ScanWords，皆在 bufio 包中。\n/ To define your own split function, match this fingerprint type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error) // Returning (0, nil, nil) will tell the scanner // to scan again, but with a bigger buffer because // it wasn't enough data to reach the delimiter  下面的例子，为一个文件创建 bufio.Scanner，并按照单词和单行读取：\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } scanner := bufio.NewScanner(file) // 缺省的分隔函数是 buffio.ScanLines，我们这里使用 ScanWords。 // 也可以定制一个 SplitFunc 类型的分隔函数 scanner.Split(bufio.ScanWords) // scan 下一个 token。 success := scanner.Scan() if success == false { // 出现错误或者 EOF err = scanner.Err() if err == nil { log.Println(\u0026quot;读取完成，到达文件末尾！\u0026quot;) } else { log.Fatal(err) } } fmt.Println(\u0026quot;读取到第一个单词：\u0026quot;, scanner.Text()) //再次调用 scanner.Scan() 发下下一个 token //------ file.Close() file2, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer file2.Close() // 尝试按行读取 scannerLines := bufio.NewScanner(file2) scannerLines.Split(bufio.ScanLines) for { success2 := scannerLines.Scan() if success2 == false { // 出现错误或者 EOF err = scannerLines.Err() if err == nil { log.Println(\u0026quot;读取完成，到达文件末尾！\u0026quot;) } else { log.Fatal(err) } break } else { fmt.Printf(\u0026quot;读取到行：\u0026lt;%s\u0026gt;\\n\u0026quot;, scannerLines.Text()) } } }  3、压缩 3.1 打包（zip）文件 package main import ( \u0026quot;archive/zip\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) // 标准库支持zip 及 tar 格式打包 func main() { outFile, err := os.Create(\u0026quot;example_1.zip\u0026quot;) if err != nil { log.Fatal(err) } defer outFile.Close() // 创建 zip writer zipWriter := zip.NewWriter(outFile) // 往打包文件中写入文件及数据。 // 此处我们直接硬编码。你可以遍历文件夹，将其下的文件及内容写入。 var filesToArchive = []struct{ Name, Body string } { {\u0026quot;test1.txt\u0026quot;, \u0026quot;Hello, everyone!\u0026quot;}, {\u0026quot;test2.txt\u0026quot;, \u0026quot;\\x61\\x62\\x63\\n\u0026quot;}, } // 将要打包的内容写入打包文件 for _, file := range filesToArchive { fileWriter, err := zipWriter.Create(file.Name) if err != nil { log.Fatal(err) } _, err = fileWriter.Write([]byte(file.Body)) if err != nil { log.Fatal(err) } } // 清理 err = zipWriter.Close() if err != nil { log.Fatal(err) } }  3.2 抽取（unzip）文件 package main import ( \u0026quot;archive/zip\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;path/filepath\u0026quot; ) func main() { zipReader, err := zip.OpenReader(\u0026quot;example_1.zip\u0026quot;) if err != nil { log.Fatal(err) } defer zipReader.Close() // 遍历打包文件中的每一个文件/文件夹 for _, file := range zipReader.Reader.File { zippedFile, err := file.Open() if err != nil { log.Fatal(err) } defer zippedFile.Close() // 指定抽取的文件名 targetDir := \u0026quot;temp\u0026quot; extractedFilePath := filepath.Join(targetDir, file.Name) // 抽取项目或者创建文件夹 if file.FileInfo().IsDir() { // 创建文件夹并设置其权限与文件一致 log.Println(\u0026quot;创建文件夹：\u0026quot;, extractedFilePath) os.MkdirAll(extractedFilePath, file.Mode()) } else { // 抽取正常的文件 log.Println(\u0026quot;抽取文件：\u0026quot;, file.Name) outputFile, err := os.OpenFile( extractedFilePath, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, file.Mode(), ) if err != nil { log.Fatal(err) } defer outputFile.Close() // 通过 io.Copy 复制文件内容 _, err = io.Copy(outputFile, zippedFile) if err != nil { log.Fatal(err) } } } }  3.3 压缩文件 package main import ( \u0026quot;compress/gzip\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) // 压缩文件，本例使用 gzip 压缩格式，标准库还支持zlib, bz2, flate, lzw func main() { outputFile, err := os.Create(\u0026quot;example.txt.gz\u0026quot;) if err != nil { log.Fatal(err) } gzipWriter := gzip.NewWriter(outputFile) defer gzipWriter.Close() // 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。 // 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。 _, err = gzipWriter.Write([]byte(\u0026quot;我是数据数据数据!\\n\u0026quot;)) if err != nil { log.Fatal(err) } log.Println(\u0026quot;压缩数据已写入文件。\u0026quot;) }  3.4 解压缩文件 package main import ( \u0026quot;compress/gzip\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 打开一个gzip文件。 // 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容， // 它的内容不是一个文件，而是一个内存流 gzipFile, err := os.Open(\u0026quot;example.txt.gz\u0026quot;) if err != nil { log.Fatal(err) } gzipReader, err := gzip.NewReader(gzipFile) if err != nil { log.Fatal(err) } defer gzipReader.Close() // 解压缩到一个 writer,它是一个 file writer outfileWriter, err := os.Create(\u0026quot;example_unzipped.txt\u0026quot;) if err != nil { log.Fatal(err) } defer outfileWriter.Close() // 复制内容 _, err = io.Copy(outfileWriter, gzipReader) if err != nil { log.Fatal(err) } }  4、其他 4.1 临时文件和目录 ioutil 提供了两个函数：TempDir() 和 TempFile()。\n使用完毕后，调用者负责删除这些临时文件和文件夹。\n有一个好处是，当你传递一个空字符串作为文件夹名的时候，它会在操作系统的临时文件夹中创建这些项目（/tmp on Linux）。\nos.TempDir() 返回当前操作系统的临时文件夹。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 在系统临时文件夹中创建一个临时文件夹 tempDirPath, err := ioutil.TempDir(\u0026quot;\u0026quot;, \u0026quot;myTempDir\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;临时文件夹已创建:\u0026quot;, tempDirPath) // 在临时文件夹中创建临时文件 tempFile, err := ioutil.TempFile(tempDirPath, \u0026quot;myTempFile.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;临时文件已创建:\u0026quot;, tempFile.Name()) // ... 做一些操作 ... // 关闭文件 err = tempFile.Close() if err != nil { log.Fatal(err) } // 删除我们创建的资源 err = os.Remove(tempFile.Name()) if err != nil { log.Fatal(err) } err = os.Remove(tempDirPath) if err != nil { log.Fatal(err) } }  4.2 通过 HTTP 下载文件 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; ) func main() { newFile, err := os.Create(\u0026quot;good_habits.html\u0026quot;) if err != nil { log.Fatal(err) } defer newFile.Close() url := \u0026quot;https://rjguanwen.cn/2019/11/good_habits/\u0026quot; response, err := http.Get(url) defer response.Body.Close() // 将HTTP response Body中的内容写入到文件 // Body满足reader接口，因此我们可以使用ioutil.Copy numBytesWritten, err := io.Copy(newFile, response.Body) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;Downloaded %d byte file.\\n\u0026quot;, numBytesWritten) }  4.3 哈希和摘要 package main import ( \u0026quot;crypto/md5\u0026quot; \u0026quot;crypto/sha1\u0026quot; \u0026quot;crypto/sha256\u0026quot; \u0026quot;crypto/sha512\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; ) func main() { // 得到文件内容 data, err := ioutil.ReadFile(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } // 计算Hash fmt.Printf(\u0026quot;Md5: %x\\n\\n\u0026quot;, md5.Sum(data)) fmt.Printf(\u0026quot;Sha1: %x\\n\\n\u0026quot;, sha1.Sum(data)) fmt.Printf(\u0026quot;Sha256: %x\\n\\n\u0026quot;, sha256.Sum256(data)) fmt.Printf(\u0026quot;Sha512: %x\\n\\n\u0026quot;, sha512.Sum512(data)) }  上面的例子复制了整个文件内容到内存中，传递给 hash 函数。\n另一个方式是创建一个 hash writer，使用 Write、 WriteString、Copy 将数据传给它。\npackage main import ( \u0026quot;crypto/md5\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer file.Close() //创建一个新的 hasher,满足 writer 接口 hasher := md5.New() _, err = io.Copy(hasher, file) if err != nil { log.Fatal(err) } // 计算 hash 并打印结果。 // 传递 nil 作为参数，因为我们不通参数传递数据，而是通过 writer 接口。 sum := hasher.Sum(nil) fmt.Printf(\u0026quot;Md5 checksum: %x\\n\u0026quot;, sum) }  ","id":30,"section":"posts","summary":"\u0026lt;部分内容借鉴自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt; Go 文件操","tags":["技术","GOLANG"],"title":"Go 文件操作","uri":"https://rjguanwen.cn/2020/08/go_file/","year":"2020"},{"content":" Gin 使基于 go 语言的一个 web 框架，接口简洁，封装比较优雅，性能表现很好。\nGin 特性  快速：路由不使用反射，基于Radix树，内存占用少。\n 中间件：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。中间件机制极大地提高了框架的可扩展性。\n 异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。\n JSON：Gin可以解析并验证请求的JSON。这个特性对Restful API的开发尤其有用。\n 路由分组：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。\n 渲染内置：原生支持JSON，XML和HTML的渲染。\n  Quickstart  安装 Gin 前，首先要安装 Go，并做好各种设置。Go 版本要求 1.9 以上。\n 下载并安装 Gin。\n$ go get -u github.com/gin-gonic/gin  在代码中引入：\nimport \u0026quot;github.com/gin-gonic/gin\u0026quot;  如果需要使用类似 http.StatusOK 的常量，则需引入 net/http。\nimport \u0026quot;net/http\u0026quot;  示例代码：\npackage main import \u0026quot;github.com/gin-gonic/gin\u0026quot; func main() { r := gin.Default() r.GET(\u0026quot;/ping\u0026quot;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026quot;message\u0026quot;: \u0026quot;pong\u0026quot;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 }   ","id":31,"section":"posts","summary":"Gin 使基于 go 语言的一个 web 框架，接口简洁，封装比较优雅，性能表现很好。 Gin 特性 快速：路由不使用反射，基于Radix树，内存占用少。 中间件：HTTP","tags":["技术","gin","golang","开发框架"],"title":"Gin Quickstart","uri":"https://rjguanwen.cn/2020/06/gin_01/","year":"2020"},{"content":" Redis 常用命令，备查！\n1、测试 Docker 是否正常安装 docker run hello-world  2、Docker 状态信息查看 docker info  3、Docker 镜像管理 3.1 创建镜像 方法一：根据 Dockerfile 创建镜像  创建Dockerfile文件及其相关依赖文件\n 切换到Dockerfile文件所在目录，执行如下命令：\ndocker build -t \u0026lt;镜像名称\u0026gt; .   方法二：根据已有镜像实例化后进行交互式环境修改后保存  根据已有镜像实例化容器，记录容器ID，并进入交互式命令行\ndocker run -it \u0026lt;已有镜像名称\u0026gt; /bin/bash  在交互式命令行执行相关操作后退出交互式命令行\n 执行如下命令创建镜像\ndocker commit \u0026lt;容器ID\u0026gt; \u0026lt;镜像名称\u0026gt;   3.2 查看镜像 docker images  3.3 查看某个镜像详情 docker inspect \u0026lt;镜像名称\u0026gt;  3.4 删除镜像 docker rmi \u0026lt;镜像名称\u0026gt;  PS：对于存在容器的镜像需要先删除容器\n3.5 为镜像添加标签 docker tag \u0026lt;旧镜像名称\u0026gt; \u0026lt;新镜像名称\u0026gt;  PS：该命令会在原有的镜像上重新生成一个新的镜像名称对应该镜像\n3.6 拉取镜像 docker pull \u0026lt;镜像名称\u0026gt;  3.7 推送镜像 docker push \u0026lt;镜像名称\u0026gt;  4、容器操作 4.1 Docker 运行容器 基本命令：\ndocker run -参数 \u0026lt;镜像名称\u0026gt; \u0026lt;执行命令\u0026gt;   参数：\n -it：-i参数用设置容器中的STDIN是开启的。-t参数表示为创建的容器分配一个伪tty终端。 二者通常联合使用。\n \u0026ndash;name 容器名：用于为启动的容器设置一个容器名称。\n -d：将程序放在后台执行，用于创建守护式容器。\n \u0026ndash;restart：设置自动重启，可以设置什么情况下重启，例如\u0026ndash;restart=always，-restart=on-failure:5。\n -p：端口映射。例如：8000:80表示将容器的80端口映射到宿主机的8000端口。80表示将容器的80端口映射到宿主机的任意端口。\n -P：端口映射，将容器Dockerfile中EXPOSE指定的端口映射到宿主机的任意端口。\n -w：指定工作目录。\n -h：为容器设置HOST主机名称。\n \u0026ndash;entrypoint：强制指定启动程序。\n -v：卷映射。示例：/home/nianshi/logs:/logs表示将宿主机的/home/nianshi/logs目录挂载到容器的/logs目录下。\n \u0026ndash;link：容器链接。示例：redis:db表示将容器名称为redis的容器连接到新建的容器上，同时设置别名为db。此时在新容器中可以使用db来表示redis容器的地址。\n \u0026ndash;volumes-from：参数用于连接某个指定容器的卷，从而可以访问到指定容器中的所有的卷。示例：blog_demo表示新容器中挂载了blog_demo容器中所有的卷。\n \u0026ndash;rm：表示容器运行完成后自动删除。\n  镜像名称：\n此处镜像名称需要输入完成的镜像名称。\n镜像名称的格式如下：[Registry/][username/]简要镜像名称[:标签]\nPS：其中Registry默认为Docker Hub地址； 对于官方源，username不需要填写，否则必填；简要镜像名称必填；标签默认为latest。\n 执行命令：\n执行命令为启动容器时需要执行的操作。\n例如：/bin/bash\n  4.2 Docker 启动/停止/重启容器 启动一个尚未运行的容器：\ndocker start \u0026lt;容器名称/容器ID\u0026gt;  停止一个运行中的容器：\ndocker stop \u0026lt;容器名称/容器ID\u0026gt;  重启动一个容器：\ndocker restart \u0026lt;容器名称/容器ID\u0026gt;  4.3 进入容器 docker attach \u0026lt;容器名称/容器ID\u0026gt;  PS：它有一个缺点，只要这个连接终止，或者使用了exit命令，容器就会退出后台运行。\ndocker exec -it \u0026lt;容器名称/容器ID\u0026gt; /bin/bash  这个命令使用exit命令后，不会退出后台。\n4.4 已有镜像中运行命令/启动进程 docker exec -参数 \u0026lt;容器名称/容器ID\u0026gt; \u0026lt;执行命令\u0026gt;  4.5 查看容器 查看在运行容器列表：\ndocker ps  查看全部容器列表：\ndocker ps -a  查看容器的详细信息：\ndocker inspect \u0026lt;容器名称/容器ID\u0026gt;  查某容器日志：\ndocker logs \u0026lt;容器名称/容器ID\u0026gt;  PS：可以添加-f来监控日志文件，-t参数来增加时间戳。\n查看容器进程：\ndocker top \u0026lt;容器名称/容器ID\u0026gt;  查看容器端口：\ndocker port \u0026lt;容器名称/容器ID\u0026gt;  ","id":32,"section":"posts","summary":"Redis 常用命令，备查！ 1、测试 Docker 是否正常安装 docker run hello-world 2、Docker 状态信息查看 docker info 3、Docker 镜像管理 3.1 创建镜像 方法一：根据 Dockerfile 创建镜像 创建D","tags":["技术","docker"],"title":"Docker常用命令","uri":"https://rjguanwen.cn/2020/06/docker_01/","year":"2020"},{"content":" Redis 常用命令，备查！\n\u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\n一、管理命令 1 启动 Redis \u0026gt; redis-server [--port 6379]  如果命令参数过多，建议通过配置文件来启动 Redis。\n\u0026gt; redis-server [xx/xx/redis.conf]  2 连接 Redis \u0026gt; ./redis-cli [-h 127.0.0.1 -p 6379]  3 停止 Reids \u0026gt; redis-cli shutdown \u0026gt; kill redis-pid  以上两条命令，效果一样\n4 发送命令 给 Redis 发送命令有两种方式： 1、redis-cli 带参数运行\n\u0026gt; redis-cli \u0026lt;命令，如 shutdown\u0026gt;  2、redis-cli不带参数运行，先执行 redis-cli，进入命令行执行命令\n5 测试连通性 \u0026gt; ping  二、key 操作命令 1 获取所有键  语法：keys pattern\n\u0026gt; keys *   * 表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度O(n)，在生产环境不建议使用。\n   2 获取键总数  语法：dbsize - 获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度O(1)。\n 3 查询键是否存在  语法：exists key [key \u0026hellip;] - 可查询多个key，返回存在的个数。\n 4 删除键  语法：del key [key \u0026hellip;] - 可以删除多个key，返回删除成功的个数。\n 5 查询键类型  语法：type key\n 6 移动键  语法：move key db 如把 javastack 移到 2 号数据库：\n\u0026gt; move javastack 2 (integer) 1 \u0026gt; select 2 OK \u0026gt; keys * 1) \u0026quot;javastack\u0026quot;   7 查询 key 的生命周期（秒）  秒语法：ttl key 毫秒语法：pttl key\n \u0026gt; ttl javastack (integer) -1   -1: 永不过期。  8 设置过期时间  秒语法：expire key seconds 毫秒语法：pexpire key milliseconds\n 9 设置永不过期  语法：persist key\n 10 更改键名称  语法：rename key newkey\n 三、字符串操作命令 字符串是Redis中最基本的数据类型，单个数据能存储的最大空间是512M。\n1 存放键值  语法：set key value [EX seconds] [PX milliseconds] [NX|XX]\n nx: 如果 key 不存在则建立；\nxx: 如果 key 存在则修改其值；\n2 获取键值  语法：get key\n 3 值递增/递减 如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错。\n\u0026gt; 语法：incr key\n如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错。\n同样，递减使用decr、decrby命令。\n4 批量存放键值  语法：mset key value [key value \u0026hellip;]\n 5 批量获取键值  语法：mget key [key \u0026hellip;]\n Redis接收的是UTF-8的编码，如果是中文一个汉字将占3位返回。\n6 获取值长度  语法：strlen key\n 7 追加内容  语法：append key value\n 向键值尾部拼接字符串。\n8 获取部分字符  语法：getrange key start end\n 四、集合操作命令 集合类型和列表类型相似，只不过是集合是无序且不可重复的。\n集合 1 存储值  语法：sadd key member [member \u0026hellip;]\n\u0026gt; sadd langs java php c++ go ruby python kotlin java (integer) 7   2 获取元素  获取所有元素语法：smembers key\n随机获取元素语法：srandmember key count - 随机获取集合中 count 指定个数的元素\n 3 判断集合是否存在元素  语法：sismember key member\n 4 获取集合元素个数  语法：scard key\n 5 删除集合元素  语法：srem key member [member \u0026hellip;]\n 6 弹出元素  语法：spop key [count]\n 有序集合 和列表的区别：\n 列表使用链表实现，两头快，中间慢。有序集合是散列表和跳跃表实现的，即使读取中间的元素也比较快。\n 列表不能调整元素位置，有序集合能。\n 有序集合比列表更占内存。\n  1 存储值  语法：zadd key [NX|XX] [CH] [INCR] score member [score member \u0026hellip;]\n\u0026gt; zadd fooCounts 16011 tid 20023 huny 2893 nosy (integer) 3   2 获取元素分数  语法：zscore key member\n\u0026gt; zscore footCounts tid \u0026quot;16011\u0026quot;  获取指定范围排名语法：zrange key start stop [WITHSCORES]\n// 获取所有，没有分数 \u0026gt; zrange footCounts 0 -1 1) \u0026quot;nosy\u0026quot; 2) \u0026quot;tid\u0026quot; 3) \u0026quot;huny\u0026quot; // 获取所有及分数 \u0026gt; zrange footCounts 0 -1 Withscores 1) \u0026quot;nosy\u0026quot; 2) \u0026quot;2893\u0026quot; 3) \u0026quot;tid\u0026quot; 4) \u0026quot;16011\u0026quot; 5) \u0026quot;huny\u0026quot; 6) \u0026quot;20082\u0026quot;  获取指定分数范围排名语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count]\n 3 增加指定元素分数  zincrby key increment member\n 4 获取集合元素个数  语法：zcard key\n 5 获取指定范围分数个数  语法：zcount key min max\n 6 删除指定元素  语法：zrem key member [member \u0026hellip;]\n 7 获取元素排名  语法 zrank key member\n 五、列表操作命令 列表类型是一个有序的字段串列表，内部是使用双向链表实现，所有可以向两端操作元素，获取两端的数据速度快，通过索引到具体的行数比较慢。\n列表类型的元素是有序且可以重复的。\n1 存储值  左端存值语法：lpush key value [value \u0026hellip;] 右端存值语法：rpush key value [value \u0026hellip;] 索引存值语法：lset key index value\n 2 弹出元素  左侧弹出语法：lpop key 右侧弹出语法：rpop key\n 3 获取元素个数  语法：llen key\n 4 获取列表元素  两边获取语法：lrange key start stop\n\u0026gt; lpush users tom kitty land pony jack maddy (integer) 6 \u0026gt; lrange users 0 3 1) \u0026quot;maddy\u0026quot; 2) \u0026quot;jack\u0026quot; 3) \u0026quot;pony\u0026quot; 4) \u0026quot;land\u0026quot; // 获取所有 \u0026gt; lrange users 0 -1 1) \u0026quot;maddy\u0026quot; 2) \u0026quot;jack\u0026quot; 3) \u0026quot;pony\u0026quot; 4) \u0026quot;land\u0026quot; 5) \u0026quot;kitty\u0026quot; 6) \u0026quot;tom\u0026quot; // 从右端索引 \u0026gt; lrange users -3 -1 1) \u0026quot;land\u0026quot; 2) \u0026quot;kitty\u0026quot; 3) \u0026quot;tom\u0026quot;  索引获取语法：lindex key index\n\u0026gt; lindex list 2 \u0026quot;ketty\u0026quot; // 从右端获取 \u0026gt; lindex list -5 \u0026quot;sady\u0026quot;   5 删除元素  根据值删除语法：lrem key count value\n\u0026gt; lpush userids 111 222 111 222 222 333 222 222 (integer) 8 // count=0 删除所有 \u0026gt; lrem userids 0 111 (integer) 2 // count \u0026gt; 0 从左端删除前count个 \u0026gt; lrem userids 3 222 (integer) 3 // count \u0026lt; 0 从右端删除前count个 \u0026gt; lrem userids -3 222 (integer) 2  范围删除语法：ltrim key start stop\n// 只保留2-4之间的元素 \u0026gt; ltrim list 2 4 OK   六、散列操作命令 redis字符串类型键和值是字典结构形式，这里的散列类型其值也可以是字典结构。\n1 存放键值  单个语法：hset key field value\n\u0026gt; hset user name javastack (integer) 1  多个语法：hmset key field value [field value \u0026hellip;]\n\u0026gt; hmset user name javastack age 20 address china OK  不存在时语法：hsetnx key field value\n\u0026gt; hsetnx user tall 180 (integer) 0   2 获取字段值  单个语法：hget key field\n \u0026gt; hget user age \u0026quot;20\u0026quot;   多个语法：hmget key field [field \u0026hellip;]\n \u0026gt; hmget user name age address 1) \u0026quot;javastack\u0026quot; 2) \u0026quot;20\u0026quot; 3) \u0026quot;china\u0026quot;   获取所有键与值语法：hgetall key\n \u0026gt; hgetall user 1) \u0026quot;name\u0026quot; 2) \u0026quot;javastack\u0026quot; 3) \u0026quot;age\u0026quot; 4) \u0026quot;20\u0026quot; 5) \u0026quot;address\u0026quot; 6) \u0026quot;china\u0026quot;   获取所有字段语法：hkeys key\n \u0026gt; hkeys user 1) \u0026quot;name\u0026quot; 2) \u0026quot;address\u0026quot; 3) \u0026quot;tall\u0026quot; 4) \u0026quot;age\u0026quot;   获取所有值语法：hvals key\n \u0026gt; hvals user 1) \u0026quot;javastack\u0026quot; 2) \u0026quot;china\u0026quot; 3) \u0026quot;170\u0026quot; 4) \u0026quot;20\u0026quot;  3 判断字段是否存在  语法：hexists key field\n \u0026gt; hexists user address (integer) 1  4 获取字段数量  语法：hlen key\n \u0026gt; hlen user (integer) 4  5 递增/减  语法：hincrby key field increment\n \u0026gt; hincrby user tall -10 (integer) 170  6 删除字段  语法：hdel key field [filed \u0026hellip;]\n ","id":33,"section":"posts","summary":"Redis 常用命令，备查！ \u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢","tags":["技术","redis"],"title":"Redis 常用命令","uri":"https://rjguanwen.cn/2020/06/redis_01/","year":"2020"},{"content":" 什么是ADR ADR（Architecture Decision Records）即架构决策记录。\n架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求进行的选择设计。软件架构决策需要在软件质量属性、成本、时间以及其他各种因素之间，做出正确的权衡。架构决策记录（ADR） 是跟踪软件设计选择的一种方法，其应能向项目经理、架构师、开发人员及软件的其他利益相关者，清楚阐明选择何种解决方案以及为此做出的权衡。\n架构决策记录记啥？ 架构决策记录（ADR）首先要解决的基本问题：“我们做了什么决策？”、“为什么这样决策？”，稍次要的问题包括：“我们还考虑过哪些解决方案？”、“为什么没有采用？”等。\n架构决策记录的作用  可以作为和开发人员进行沟通的工具，说明应遵循的重要架构原则\n 当开发人员对架构背后的逻辑提出质疑时，使团队成员能够“就事论事”，提高效率。（如果事实表明你的决策站不住脚，便应虚心接受批评，改正架构）\n 向领导和利益相关者说明这样构建软件的确切原因（比如，采用某种较为昂贵的硬件或软件的必要性等）\n 要把项目移交给下任架构师时，保持架构设计的有序传承\n 如果相关条件发生变化，需要对决策重新评估时，它可以作为一个起点\n 架构决策记录也会倒逼架构师在进行架构决策时更严谨，有助于确保基础的扎实稳固\n  架构决策记录的组成部分 每个架构决策至少有 6 部分组成：标题、时间、状态（Status）、上下文（Context）、决策（Decision）、后果（Consequences）。\n 标题：按数字顺序编号，简要描述架构决策内容\n 时间：在标题下一行，记录架构决策做出的日期，如 日期：2020年2月28日\n 状态：表示本架构决策当前所处的状态，可选项包括：\n 提议：决策已被提出讨论，但是利益相关方尚未达成一致。\n 公认：决策已讨论通过并达成一致。\n 已取代：因条件变化，已有新的架构决策取代本决策。此时需要给出新决策链接。\n 已弃用：本架构决策已撤销，不再使用。\n  上下文：架构决策相关的背景及决策原因。本部分的语言应该是价值中立的，只用于描述事实\n 决策：本部分简洁明了的描述我们最终确定的架构决策\n 后果：本部分描述应用决策后产生的影响，所有的影响都应该列在这里，包括“积极的”、“中性的”与消极的”\n  其他关键问题  架构决策按照顺序和数字编号，不要打乱顺序。\n 已记录的架构决策不应该被删除，如果被取代掉或已不符合当前情况，请将其标记为 已取代 或 已弃用\n  一个架构决策记录示例 1. 使用 ssh key 替换用户名密码方式登录 日期: 2019年11月12日 状态： 公认 上下文： 当前我们使用的是用户名、密码方式进行服务器登录，存在以下问题 安全性问题，密码面临被破解的风险； 易用性问题，无法使用 config 记录密码，可以使用第三方软件解决，如，SecureCRT，ZOC7； 无法充分使用 local terminal，如 iTerm2； 参考: SSH: passwords or keys? https://lwn.net/Articles/369703/ Why is SSH key authentication better than password authentication? https://superuser.com/questions/303358/why-is-ssh-key-authentication-better-than-password-authentication Why is using an SSH key more secure than using passwords? https://security.stackexchange.com/questions/69407/why-is-using-an-ssh-key-more-secure-than-using-passwords 决策： 禁用用户名、密码登录，使用 ssh key 进行登录 后果： 团队成员使用新方式需要适应； key 的管理需要统一（需要引入堡垒机）。  ","id":34,"section":"posts","summary":"什么是ADR ADR（Architecture Decision Records）即架构决策记录。 架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求","tags":["技术"],"title":"架构决策记录（ADR）","uri":"https://rjguanwen.cn/2020/02/adr/","year":"2020"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，我们将使用前面章节中讲到的 Redis engine。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;首先，我们需要有一个处在运行状态的 Redis 服务器。然后，我们可以一次启动三个 Cetrifugofu 服务节点：\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;打开命令行窗口，启动第一个节点：\n centrifugo --config=config.json --port=8000 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;如果 Redis 和 Centrifugo 运行在同一台机器，并且使用了默认的端口号，上面命令中的 redis_host 与 redis_port 选项可以省略。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;然后打开一个新的命令行窗口，启动第二个节点：\n centrifugo --config=config.json --port=8001 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;此命令中，我们指定了一个新的端口 8001，以防与节点一出现端口冲突。如果你的两个节点不在一台机器上，则不存在该问题。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;接下来再次开启一个新的命令行窗口，启动第三个节点：\n centrifugo --config=config.json --port=8002 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;现在你已经拥有了三个 Centrifugo 实例，分别运行在 8000、8001、8002 端口，客户端可以选择连接任何一个实例。同样，你也可以发送 API 请求到任何一个节点。这三个节点通过 Redis 的 PUB/SUB 机制实现消息共享。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;多个节点之间的负载均衡可以通过 Nginx 实现。要非常注意的一点是，如果你的客户端使用了 SockJS 连接到 Centrifugo 节点，那么接下来的该客户端的请求只能路由到同一节点，因为该节点保存了客户端的会话信息。而使用 websocket 则不存在该问题。\nRedis 分片\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;从 V1.6.0 开始 Centrifugo 内置了对 Redis 分片的支持。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;该功能防止 Redis 在大型的 Centrifugo 应用中成为性能瓶颈。Redis 是单线程服务器，它速度非常快，但是当你的 Redis CPU 使用率接近 100% 的时候，分片可以帮助你的应用程序实现扩展。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;目前，Centrifugo 支持基于逗号的简单方法来配置 Redis 分片。\n示例一（基于本机运行的两个 Redis 分片来启动 Centrifugo）：\n centrifugo --config=config.json --engine=redis --redis_port=6379,6380  示例二（基于运行在不同主机上的 Reids 实例来启动 Centrifugo）：\n centrifugo --config=config.json --engine=redis --redis_host=192.168.1.34,192.168.1.35  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;启用分片后，Centrifugo 将使用一致性哈希算法在已配置的 Redis 实例上传播频道和历史/状态信息。\n","id":35,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，","tags":["技术","Centrifugo"],"title":"Centrifugo（九）使用 Redis 实现伸缩","uri":"https://rjguanwen.cn/2019/12/centrifugo_09/","year":"2019"},{"content":"Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本文主要描述如何针对不同的动作（actions）生成令牌及签名。如果你使用 Python，那么所有所需的方法都已经封装到 Cent 库中，你直接使用即可。针对 PHP、GO、Ruby、NodeJs等常用开发语言，同样有官方 HTTP API clients 提供，可以直接使用。\n","id":36,"section":"posts","summary":"Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026e","tags":["技术","Centrifugo"],"title":"Centrifugo（十）令牌和签名","uri":"https://rjguanwen.cn/2019/12/centrifugo_10/","year":"2019"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从他已订阅的频道中读取消息。在有些时候，这不是我们想要的。因此，我们需要连接检查机制。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 有一个选项 connection_lifetime。其默认值为 0，此时，连接检查机制处于关闭状态。当该选项设置的数值大于 0 时，连接检查机制开启，并且这个数值表示成功连接后，连接保持的时长（以秒为单位）。例如，将 connection_lifetime 设置为 60，表示连接保持时长为 60 秒。当连接时长到期时，Javascript 浏览器客户端将向应用程序后端发送 AJAX POST 请求。默认情况下，此请求发送到 URL /centrifuge/refresh。你可以使用 Javascript 客户端配置选项 refreshEndpoint 进行更改。应用服务器需要返回带有连接凭据的 JSON 作为响应。返回相应示例（Python）：\n to_return = { 'user': \u0026quot;USER ID\u0026quot;, 'timestamp': \u0026quot;CURRENT TIMESTAMP AS INTEGER\u0026quot;, 'info': \u0026quot;ADDITIONAL CONNECTION INFO\u0026quot;, 'token': \u0026quot;TOKEN BASED ON PARAMS ABOVE\u0026quot;, } return json.dumps(to_return)  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;你在响应中返回的连接凭据必须与页面初始化时的凭据一致，其中 timestamp 要使用当前的时间戳。然后，Javascript 客户端会将凭据发送到 Centrifugo 服务器，并刷新连接时长。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;如果你不想保持该连接，应用程序后端只需要向 AJAX POST 请求返回 403 响应即可。\n","id":37,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从","tags":["技术","Centrifugo"],"title":"Centrifugo（八）连接检查","uri":"https://rjguanwen.cn/2019/12/centrifugo_08/","year":"2019"},{"content":" 经常记不住 Git 命令，备查！\n本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n一般来说，日常使用只要记住下图 6 个命令即可。\n专用名词译名：\nWorkspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库  一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]  二、配置 Git 的配置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026quot;[NAME]\u0026quot; $ git config [--global] user.email \u0026quot;[EMAIL ADDRESS]\u0026quot;  三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]  四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...  五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]  六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]  七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\u0026quot;提交说明\u0026quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \u0026quot;@{0 day ago}\u0026quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog  八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all  九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop  十、其他 # 生成一个可供发布的压缩包 $ git archive  ","id":38,"section":"posts","summary":"经常记不住 Git 命令，备查！ 本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/gi","tags":["技术","GIT"],"title":"常用 Git 命令清单","uri":"https://rjguanwen.cn/2019/12/git_03/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。\n Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.rjguanwen.cn，那么 API 地址则是 https://centrifugo.rjguanwen.cn/api/。\n 当使用 HTTP API 时，你需要做的是向正确的地址发送正确构造的 POST 请求。\n API 请求是一个 POST application/json 请求，指令包含在请求体，并带有一个附加的header X-API-Sign。请求体是 JSON 结构，其中包含了你需要执行的指令，指令可以是单条也可以是多条。\n X-API-Sign 标头是基于 Centrifugo 密钥和要发送的 JSON 正文的 SHA-256 HMAC 字符串。该字符串主要用于 Centrifugo 对请求进行验证，以防假冒。在大多数情况下，你可以使用防火墙规则保护 Centrifugo API 端点，并且在 Centrifugo 启动时使用 --api_insecure 选项禁用验证检查。在此模式下，你使用 HTTP API 只需要发送 POST 请求，而不需要额外的 X-API-Sign 标头。\n 请求体是 JSON 对象，包括两个属性：method 和 params：\n# 一条指令 command = json.dumps({ \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;:{}} }) # 多条指令 command = json.dumps([ { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;1\u0026quot;}} }, { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;2\u0026quot;}} }, ])  Centrifugo 已经提供了一些编程语言的官方 API client（API libraries）以方便调用 HTTP API。但是，你也可以不使用官方提供的 API client，而是自己编写程序发送请求，这样做也并不麻烦，而且可以减少你的应用程序的依赖。以 Python（使用 requests 库发送请求）为例：\nimport json import requests from cent.core import generate_api_sign commands = [ { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;docs\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;1\u0026quot;}} } ] encoded_data = json.dumps(commands) # 使用官方库中的方法来生成标识 sign = generate_api_sign('very-long-secret-key', encoded_data) headers = {'Content-type': 'application/json', 'X-API-Sign': sign} r = requests.post(\u0026quot;https://centrifugo.rjguanwen.cn/api/, data=encoded_data, headers=headers) print r.json()   \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在上面的代码中，我们使用了官方提供的 Python 语言的 Cent 库中的方法来生成标识（sign）。你也可以自己构建标识。在上例中，commands 是一个数组，可以包含多条指令。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;我们可用的指令包括：publish、broadcast、unsubscribe、presence、history、disconnect、channels、stats、node。\npublish \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;publish 指令用来向频道发送消息。publish 方法的 params 是一个 JSON 对象，至少包含两个 KEY ：channel 和 data。从version 0.2.0之后，可以选择将客户端ID client 包含在 publish 指令中。\n{ \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;hello\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;long-unique-client-id\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot; }  broadcast \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;与 publish 基本类似，不过可以同时发布一条消息到多个渠道。\n{ \u0026quot;method\u0026quot;: \u0026quot;broadcast\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channels\u0026quot;: [\u0026quot;CHANNEL_1\u0026quot;, \u0026quot;CHANNEL_2\u0026quot;], \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;Hello\u0026quot; } } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;broadcast 指令同样可以包含 client 参数。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本指令会将消息发送到所有指定队列直到第一个错误发生。当错误发生时，错误信息会以响应的方式返回，并且停止消息的继续发布。当使用 Redis API 时，错误信息无法返回，而是会记录日志。\nunsubscribe \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;unsubscribe 用来从渠道取消用户的订阅。params 包括两个 KEY：channel、user。\n \u0026quot;method\u0026quot;: \u0026quot;unsubscribe\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot;, \u0026quot;user\u0026quot;: \u0026quot;USER ID\u0026quot; }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;unsubscribe\u0026quot; }  disconnect \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;disconnect 指令用来通过 ID 断开用户连接。params 包含一个 KEY：user。\n{ \u0026quot;method\u0026quot;: \u0026quot;disconnect\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;USER ID\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;disconnect\u0026quot; }  presence \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;presence 指令用来获取渠道的状态信息（当前订阅本渠道的所有客户端）。params 包含一个 KEY：channel。\n{ \u0026quot;method\u0026quot;: \u0026quot;presence\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;e5ee0ab0-fde1-4543-6f36-13f2201adeac\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;e5ee0ab0-fde1-4543-6f36-13f2201adeac\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } } } }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;presence\u0026quot; }  history \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;history 指令用来获取渠道的历史信息（发送到本渠道的最近的消息列表）。params 包含一个 KEY：channel。\n{ \u0026quot;method\u0026quot;: \u0026quot;history\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: [ { \u0026quot;uid\u0026quot;: \u0026quot;8c5dca2e-1846-42e4-449e-682f615c4977\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;1445536974\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;world\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot; }, { \u0026quot;uid\u0026quot;: \u0026quot;63ecba35-e9df-4dc6-4b72-a22f9c9f486f\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;1445536969\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;hello\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot; } ] }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;history\u0026quot; }  channels \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;channels 指令用来获取活动渠道列表（拥有至少一个订阅者）。\n{ \u0026quot;method\u0026quot;: \u0026quot;channels\u0026quot;, \u0026quot;params\u0026quot;: {} }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;: [ \u0026quot;$public:chat\u0026quot;, \u0026quot;news\u0026quot;, \u0026quot;notifications\u0026quot; ] }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;channels\u0026quot; }  stats \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;stats 指令用来获取正在运行的 Centrifugo 节点的统计信息。\n \u0026quot;method\u0026quot;: \u0026quot;stats\u0026quot;, \u0026quot;params\u0026quot;: {}  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;: { \u0026quot;nodes\u0026quot;: [ { \u0026quot;uid\u0026quot;: \u0026quot;6045438c-1b65-4b86-79ee-0c35367f29a9\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;MacAir.local_8000\u0026quot;, \u0026quot;num_goroutine\u0026quot;: 21, \u0026quot;num_clients\u0026quot;: 0, \u0026quot;num_unique_clients\u0026quot;: 0, \u0026quot;num_channels\u0026quot;: 0, \u0026quot;started_at\u0026quot;: 1445536564, \u0026quot;gomaxprocs\u0026quot;: 1, \u0026quot;num_cpu\u0026quot;: 4, \u0026quot;num_msg_published\u0026quot;: 0, \u0026quot;num_msg_queued\u0026quot;: 0, \u0026quot;num_msg_sent\u0026quot;: 0, \u0026quot;num_api_requests\u0026quot;: 0, \u0026quot;num_client_requests\u0026quot;: 0, \u0026quot;bytes_client_in\u0026quot;: 0, \u0026quot;bytes_client_out\u0026quot;: 0, \u0026quot;memory_sys\u0026quot;: 7444728, \u0026quot;cpu_usage\u0026quot;: 0 } ], \u0026quot;metrics_interval\u0026quot;: 60 } }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;stats\u0026quot; }  node \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;node 指令用来获取单个 Centrifugo 节点的信息。\n{ \u0026quot;method\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;params\u0026quot;: {} }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;:{ \u0026quot;uid\u0026quot;:\u0026quot;c3ceab87-8060-4c25-9cb4-94eb9db7899a\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;MacAir.local_8000\u0026quot;, \u0026quot;num_goroutine\u0026quot;:14, \u0026quot;num_clients\u0026quot;:0, \u0026quot;num_unique_clients\u0026quot;:0, \u0026quot;num_channels\u0026quot;:0, \u0026quot;started_at\u0026quot;:1455450238, \u0026quot;gomaxprocs\u0026quot;:4, \u0026quot;num_cpu\u0026quot;:4, \u0026quot;num_msg_published\u0026quot;:0, \u0026quot;num_msg_queued\u0026quot;:0, \u0026quot;num_msg_sent\u0026quot;:0, \u0026quot;num_api_requests\u0026quot;:3, \u0026quot;num_client_requests\u0026quot;:0, \u0026quot;bytes_client_in\u0026quot;:0, \u0026quot;bytes_client_out\u0026quot;:0, \u0026quot;memory_sys\u0026quot;:0, \u0026quot;cpu_usage\u0026quot;:0 } }, \u0026quot;error\u0026quot;:null, \u0026quot;method\u0026quot;:\u0026quot;node\u0026quot; }  ","id":39,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。 Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.","tags":["技术","Centrifugo"],"title":"Centrifugo（七）Server HTTP API","uri":"https://rjguanwen.cn/2019/12/centrifugo_07/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Memory 引擎只支持一个 Centrifugo 节点，而 Redis 引擎支持多节点部署。可以通过配置文件中的 engine 属性来设置 Centrifugo 使用的引擎，也可以在启动命令中通过 engine 参数指定：\ncentrifugo --config=config.json --engine=redis  也可以在配置文件中指定：\n{ ... \u0026quot;engine\u0026quot;: \u0026quot;redis\u0026quot; }  Memory engine 只支持一个节点，所有信息存储在服务器内存中。\n 优点\n 速度快\n 简单，不需要安装 Redis\n  缺点\n 无法扩展节点\n   Redis engine \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;支持 Centrifugo 在多服务器伸缩部署，使用 Redis 作为消息路由，状态信息及历史数据保存在 Redis 内存数据库中，内部节点之间的通讯通过 Redis 的发布/订阅机制来进行通信。同时，此模式支持 API 命令排队。\nRedis 最低版本要求为 v3.2.0\n与 Redis 引擎相关的配置选项如下：\n redis_host (string, default \u0026quot;127.0.0.1\u0026quot;)\n redis_port (int, default 6379)\n redis_url (string, default \u0026quot;\u0026quot;): optional Redis connection URL\n redis_password (string, default \u0026quot;\u0026quot;)\n redis_db (int, default 0): number of Redis db to use\n redis_tls (boolean, default false): enable Redis TLS connection (new in v2.0.2)\n redis_tls_skip_verify (boolean, default false): disable Redis TLS host verification (new in v2.0.2)\n redis_sentinels (string, default \u0026quot;\u0026quot;): 以逗号分隔的 Sentinels for HA 列表\n redis_mastr_name (string, default \u0026quot;\u0026quot;): name of Redis master Sentinel monitors\n redis_prefix (string, default \u0026quot;centrifugo\u0026quot;): 用于 Redis 中的频道（channels）与键（keys）的自定义前缀\n redis_sequence_ttl (int, default 0): 设置 Redis 引擎中序列数据的过期时间，以秒为单位。Sequence meta key in Redis is a HASH that contains current sequence number in channel and epoch value. 默认情况下，频道的序列数据是永不过期的。尽管在某下情况下（例如当频道只创建了很短一段时间，之后就不再使用），创建的序列元数据会被保存在内存中，而实际上并没有用。从长远来看，这也可以认为是一种内存泄漏。将本选项设置为一个合适的值，将有助于改善这种状况\n  以上这些选项均可以在配置文件中设置，其中的部分可以在启动命令行参数中直接设置 。\n关于选项 redis_url，该选项用于设置 Redis 的连接字符串，格式为 redis://:password@hostname:port/db。当 --redis_url 参数生效时，--redis_host、--redis_port、--redis_password、--redis_db 参数会被替代掉，不再生效。\nKeyDB engine \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo Redis engine 可与 KeyDB 无缝协作，KeyDB 服务器与 Reids 兼容，并且提供其他一些附加功能。此功能为实验功能，不保证未来版本仍然与 KeyDB 兼容。\n\n// \u0026mdash;\u0026ndash; 以下为老版本内容，未验证是否在新版本仍适用 \u0026mdash;\u0026mdash;-\n --redis_api enable Redis API listener (Redis engine) --redis_api_num_shards int Number of shards for redis API queue (Redis engine) --redis_db string redis database (Redis engine) (default \u0026quot;0\u0026quot;) --redis_host string redis host (Redis engine) (default \u0026quot;127.0.0.1\u0026quot;) --redis_master_name string Name of Redis master Sentinel monitors (Redis engine) --redis_password string redis auth password (Redis engine) --redis_pool int Redis pool size (Redis engine) (default 256) --redis_port string redis port (Redis engine) (default \u0026quot;6379\u0026quot;) --redis_sentinels string Comma separated list of Sentinels (Redis engine) --redis_url string redis connection URL in format redis://:password@hostname:port/db (Redis engine)  说明：\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;1. 当 --redis_url 参数生效时，--redis_host、--redis_port、--redis_password、--redis_db 参数会被替代掉，不再生效。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;2. --redis_api_num_shards 参数必须与 --redis_api 参数配合使用。它将创建 N 个分片队列。该参数主要用于超高并发的消息发布。通过对 API 队列分片降低单队列的压力，提升消息发布效率。如果 --redis_api_num_shards 配置为 5，则将产生 5 个 API 队列分片：\ncentrifugo.api.0 centrifugo.api.1 centrifugo.api.2 centrifugo.api.3 centrifugo.api.4  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当使用此参数时，在客户端侧，你必须指定要将消息发布到哪个 API 队列。为了保证频道中消息的顺序，需要注意在客户端中要将消息按顺序推送到同一 API 队列的同一频道中。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;要想使 Centrifugo 支持通过 Redis engine API listener 发布消息，可以在启动时使用 --redis_api 参数：\n centrifugo --config=config.json --engin=redis --redis_api  如此启动后，可以直接通过 Redis 客户端来发布消息，示例代码（Python）:\nimport redis import json client = redis.Redis() command = { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;events\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;enent\u0026quot;: \u0026quot;message\u0026quot;} } } client.rpush(\u0026quot;centrifugo.api\u0026quot;, json.dumps(command))  RPUSH 命令允许在一个请求中将多条消息推入队列。\n注意：我们通过 RPUSH 将消息推送到了 centrifugo.api，这是 API 队列的默认名称，Centrifugo 实时对其监控。事实上，在 Redis 中，这是一个列表结构。此处，你推送过来的指令会被 Centrifugo 及时处理，但是并不会给客户端响应。如果需要获取响应，那只能使用 HTTP API。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;publish 是最常用的 Centrifugo 指令，Redis_API 的主要目的是降低高频率发布时的 HTTP 开销。同时，也方便各种类型的语言使用 Centrifugo，而不需要依赖 HTTP API client。\n","id":40,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Me","tags":["技术","Centrifugo"],"title":"Centrifugo（六）引擎（Engines）","uri":"https://rjguanwen.cn/2019/12/centrifugo_06/","year":"2019"},{"content":" 1、创建本地仓库  cd 到相应文件夹\n 仓库初始化：\ngit init  将文件添加到仓库：\ngit add .  提交文件到仓库：\ngit commit -m \u0026quot;xxxxxxx\u0026quot;  2、关联 github 仓库 添加远程仓库：\ngit remote add origin https://github.com/rjguanwen/xxxx.git  合并本地内容与远程内容：\ngit pull --rebase origin master  3、上传本地内容 git push -u origin master   ","id":41,"section":"posts","summary":"1、创建本地仓库 cd 到相应文件夹 仓库初始化： git init 将文件添加到仓库： git add . 提交文件到仓库： git commit -m \u0026quot;xxxxxxx\u0026quot; 2、关联 github 仓库 添加远程仓库： git remote add origin https://github.com/rjguanwen/xxxx.git 合并本地","tags":["技术","GIT"],"title":"上传本地文件到git","uri":"https://rjguanwen.cn/2019/12/git_02/","year":"2019"},{"content":" 一、下载安装程序 \u0026ensp;\u0026ensp;Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方便的编译为各个平台的执行程序。Centrifugo 安装首先根据操作系统获取最新版本的安装程序（lastest release）。\n二、生成配置文件 \u0026ensp;\u0026ensp;Centrifugo 运行需要依赖配置文件，最小化的配置文件可以通过命令自动生成：\n./centrifugo genconfig  以上命令，会在当前目录生成一个 config.json 文件，其中包含自动生成的 secret key，你可以根据自己的喜好对其进行修改。\n三、运行 Centerfugo ./centrifugo --config=config.json  四、检查配置文件 ./centrifugo checkconfig --config=config.json  当配置文件出现问题时，可以使用该命令检查。\n五、Linux 安装包及 Docker 镜像 \u0026ensp;\u0026ensp;参考 RPM and DEB packages 及 Docker image\n","id":42,"section":"posts","summary":"一、下载安装程序 \u0026ensp;\u0026ensp;Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方","tags":["技术","Centrifugo"],"title":"Centrifugo（三）安装与启动","uri":"https://rjguanwen.cn/2019/12/centrifugo_03/","year":"2019"},{"content":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。\n基本运行框架：\nCentrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifugo。当然，也可以只有客户端和 Centrifugo。基本使用流程如下：\n 下载并安装\n下载并安装Centrifugo，推荐使用 docker 方式。安装教程\n 配置运行\n创建基础配置文件，设置 token_hmac_secret_key(or token_rsa_public_key) 和 api_key，然后运行Centrifugo。配置文件（config.json）可以通过命令自动创建：\n./centrifugo genconfig  关键配置项\n在后端应用程序配置文件中设置三个变量：Centrifugo secret、Centrifugo API Key 以及 Centrifugo API address。Centrifugo API address 默认为 http://localhost:8000/api。Centrifugo secret 和 Centrifugo API Key 是关键信息，不能泄露到客户端。\n 连接到 Centrifugo\n根据客户端语言下载相应的客户端库（支持的客户端库列表）。客户端库中有连接到 Centrifugo 的方法。在连接时，客户端需要提供令牌（Token JWT）。令牌的生成应该在应用程序后端进行，然后提供给客户端，可以考虑在页面模板上下文中传递令牌给客户端或者提供令牌获取服务供已登录的客户端调用。令牌的生成需要依赖 Centrifugo secret。 客户端库一般都有 setToken 方法供使用。注意：对于 RSA 令牌，需要使用私钥生成 JWT。（JWT生成方法）\nCentrifugo v2.3.0 之后，可以不使用 JWT 进行连接认证，参见 proxying to backend\n 频道订阅\n客户端连接到 Centrifugo 后，即可根据需要订阅相关的频道（Channel）。所有的客户端库都提供了处理所订阅频道（Channel）消息的方法。\n 消息推送\n以上完成后，当用户打开应用程序的相关页面时，客户端会成功连接到 Centrifugo 并订阅一个或多个频道。如果你想向订阅特定频道的用户发送实时消息，例如：有人发布了新评论、部分商品打折促销、某个业务按钮被按下等，可以通过 Centrifugo HTTP API 来完成，官方针对不同的编程语言提供了一些 API 库（API libraries），使用这些库可以方便的发布消息到指定的频道（Channel）。当然，你也可以根据API 描述编写自己的 API 库。Centrifugo 也支持 GRPC API。发布到频道的消息会被投递到订阅相应频道的客户端。\n 生产环境安装包\n为了方便在生产环境中安装 Centrifugo，官方提供了 Docker 镜像、rpm 包以及 deb 包。\n 监控\n不用忘记对 Centrifugo 设置进行监控。参考资料\n 详细参考资料地址。\n  ","id":43,"section":"posts","summary":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。 基本运行框架： Centrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifu","tags":["技术","Centrifugo"],"title":"Centrifugo（二）基本使用","uri":"https://rjguanwen.cn/2019/12/centrifugo_02/","year":"2019"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到本频道的消息、用户订阅/取消订阅的消息等等。同样，客户端也需要订阅频道来获取频道的状态（presence）和历史消息。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道的生命周期比较短暂，不需要显式的去声明。当第一个客户端进行订阅时，Centrifugo 会自动创建相应频道。当最后一个客户端取消订阅时，频道会立即自动被销毁。\n 频道的命名规则\n  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道以字符串为标识，由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$），默认最大长度为255，如需修改可以通过配置文件中的 channel_max_length 参数进行调整。\n以下几个符号是 Centrifugo 的内部保留符号：\n : - 命名空间分隔符\n $ - 私有频道前缀\n # - 用户频道分隔符\n * - 保留字符\n \u0026amp; - 保留字符\n / - 保留字符\n  命名空间分隔符（:）：如果频道名称为 public:chat，该频道的配置信息将使用 public 命名空间的配置参数设置。\n私有频道前缀（$）：如果频道名称以 $ 开头，则意味着该频道为私有频道。订阅私有频道必须通过应用程序后端签名。\n用户频道分隔符（#）：该字符用于创建用户专属频道，而无需向后端Web应用程序发送POST请求。例如，频道名 news#42，表示只有 ID 为 42 的用户可以订阅该频道。客户端在连接 Centrifugo 时需要提供 Token，其中包含了 user ID，因此 Centrifugo 清楚每个客户端的 user ID。另外，用户频道可以支持多个 user ID，user ID 之间通过逗号分隔，例如 dialog#42,43。此种类型的频道适用于固定用户，例如用户个人消息通道、确定用户之间的对话通道，一旦需要动态用户访问频道，此频道类型就不合适了。\n","id":44,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到","tags":["技术","Centrifugo"],"title":"Centrifugo（五）频道（Channel）","uri":"https://rjguanwen.cn/2019/12/centrifugo_05/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过 ./centrifugo -h 命令，可以查看所有的可用选型，如下：\n Centrifugo – real-time messaging server Usage: [flags] [command] Available Commands: checkconfig Check configuration file genconfig Generate simple configuration file to start with help Help about any command version Centrifugo version information Flags: -a, --address string interface address to listen on 服务的地址 --admin enable admin web interface 是否开启admin的管理界面 --admin_insecure use insecure admin mode – no auth required for admin socket admin安全验证, 节点: /, 可直接访问admin管理界面, 默认为false, 登录admin需要admin_password, 反之可直接登录 --api_insecure use insecure API mode 后台推送安全验证, 节点: /api. 默认为 false, 此时访问节点需要api_key. 当设置为 true 后, 任何人都将可以访问此节点 --client_insecure start in insecure client mode 客户端是否需要安全验证, 默认为false, 客户端必须拥有 JWT token 才能访问 -c, --config string path to config file (default \u0026quot;config.json\u0026quot;) --debug enable debug endpoints 是否开启dubug节点, 开启后可访问 /debug/pprof/ 查看一些Centrifugo的网络状态 -e, --engine string engine to use: memory or redis (default \u0026quot;memory\u0026quot;) 消息存储引擎, 默认为内存, 部署多个实例会造成数据不同步, 因此推荐使用 redis --grpc_api enable GRPC API server 是否开启grpc api, 默认使用 http_api -h, --help help for this command --internal_port string custom port for internal endpoints 开启自定义默认端口, 默认为8000, 开启额外的端口为admin访问 --log_file string optional log file - if not specified logs go to STDOUT log输出文件 --log_level string set the log level: debug, info, error, fatal or none (default \u0026quot;info\u0026quot;) log级别 -n, --name string unique node name 命名空间名称, 此空间下的属性会覆盖common部分, 但不会继承 --pid_file string optional path to create PID file -p, --port string port to bind HTTP server to (default \u0026quot;8000\u0026quot;) 服务端口号 --prometheus enable Prometheus metrics endpoint --redis_db int Redis database (Redis engine) --redis_host string Redis host (Redis engine) (default \u0026quot;127.0.0.1\u0026quot;) --redis_master_name string name of Redis master Sentinel monitors (Redis engine) --redis_password string Redis auth password (Redis engine) --redis_port string Redis port (Redis engine) (default \u0026quot;6379\u0026quot;) --redis_sentinels string comma-separated list of Sentinel addresses (Redis engine) --redis_tls enable Redis TLS connection --redis_tls_skip_verify disable Redis TLS host verification --redis_url string Redis connection URL in format redis://:password@hostname:port/db (Redis engine) --tls enable TLS, requires an X509 certificate and a key file --tls_cert string path to an X509 certificate file --tls_key string path to an X509 certificate key  注意：所有的命令行选项都可以用同样的名字在配置文件中进行设置。此外，所有的可用选项也都可以设置到环境变量中，格式为 CENTRIFUGO_\u0026lt;OPTION_NAME\u0026gt;。\nversion centrifugo version  JSON file Centrifugo 启动时依赖配置文件。最简单的配置文件如下：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; }  必须的两个选项为 token_hmac_secret_key 和 api_key。token_hmac_secret_key 用来检查 JWT 签名。api_key 用于 Centrifugo API 端点授权。在生产环境你应该将这两个参数设置的足够复杂并且避免外泄。唯二的需要知道这两个参数值的只有 Centrifugo 自身和你的应用程序后端。该值被用来生成客户端连接令牌、调用 API 以及订阅私有频道。\nTOML file Centrifugo 同样支持 TOML 格式的配置文件：\ncentrifugo --config=config.toml  config.toml 示例：\ntoken_hmac_secret_key = \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot; api_key = \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; log_level = \u0026quot;debug\u0026quot;  YAML file Centrifugo 同样支持 TOML 格式的配置文件，config.yaml：\ntoken_hmac_secret_key: \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot; api_key: \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; log_level: debug  checkconfig command Centrifugo 有专门的命令用来检查配置文件：\ncentrifugo checkconfig --config=config.json  genconfig command centrifugo genconfig -c config.json  该命令会生成最小化的配置文件。\nImportant options 运行 Centrifugo 时可以配置一些最重要的选项：\n- address - 将 Centrifugo 绑定到特定的接口地址（默认为 \u0026quot;\u0026quot;）\n- port - Centrifugo 的绑定端口（默认为 8000）\n- engine - Centrifugo 使用的引擎：memory 或者 redis（默认为 memory） 注意：命令行参数优先级要大于配置文件选项。\nChannel options 频道（channel）是一个实体，客户端可以订阅发布到相应频道的消息。下面几个选项可以控制频道的一些行为：\n publish：允许客户端直接发布消息到频道，而不经过应用程序后端。一般情况下，消息都是由应用程序后端通过 Centrifugo API 发布到 Centrifugo 服务器的。这个参数适用于没有后端或者 demo 的快速构建。需要注意的一点是客户端只有成功订阅了频道之后才能发布消息到该频道。本参数默认值为 false。\n subscribe_to_publish：当 publish 选项启用后，客户端可以发布消息到频道中而无需订阅。使用此选项，客户端会在发布到频道之前自动检查是否已订阅该频道。\n anonymous：该参数允许匿名访问（在连接参数中使用空字符串作为 user ID，JWT token 中 sub 为空）。通常情况下，应用程序的用户都需要登录认证，因此客户端建立连接时可以使用用户名作为唯一标识。如果你需要提供公共的实时消息服务，你可以在相应的频道上开启本参数。本参数默认值为 false。\n presence：是否开启 presence 信息，presence 为当前订阅本频道的客户端信息。本参数默认是为 false，即不开启。\n presence_disable_for_client：（v2.2.3 之后版本有效）presence 在客户端不可用。默认值为 false，即同时允许客户端和服务端 API 访问 presence 信息。\n join_leave：当有用户订阅/取消订阅频道时，是否发送相关信息到频道中。本参数默认值为 false。\n history_size：频道历史消息数量。因为 Centrifugo 将所有的消息存储在内存中，因此限制每个频道保留的历史消息数量是非常重要的。本参数默认值为 0，这意味着频道不会保留历史消息。启用本参数后，Centrifugo 会为命名空间中的每条频道保留指定数量的历史消息，直到消息过期，关于消息过期详见参数 history_lifetime。\n history_lifetime：频道历史消息的过期时间，单位为秒。本参数默认值为 0，这意味着频道不会保留历史消息。如果要保留历史消息，需要同时配置 history_size 与 history_lifetime，并设置合理的参数值。\n history_recover：是否恢复丢失的消息。如果开启本参数，当客户端重新连接时（如因网络原因断线重连），Centrifugo 将试图重新恢复丢失的消息。本参数默认值为 false。这个参数的启用要配合历史消息相关参数（history_size 和 histroy_lifetime），毕竟消息的恢复依靠的是频道历史消息记录。请注意，并非所有实时事件消息都需要开启此功能，因此在需要时请慎重考虑。启用此选项后，你的应用程序需要考虑消息去重。\n history_disable_for_client：（v2.2.3 之后版本有效）历史消息在客户端不可用。默认为 false，即历史消息在客户端与服务端均可用。该参数是否启用不会影响历史消息恢复机制。\n  参数配置示例：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;my-secret-key\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;secret-api-key\u0026quot;, \u0026quot;anonymous\u0026quot;: true, \u0026quot;publish\u0026quot;: true, \u0026quot;subscribe_to_publish\u0026quot;: true, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 300, \u0026quot;history_recover\u0026quot;: true }   namespaces：namespaces 是可选参数，如果设置的话，需要设置成 namespace 数组的形式。通过 namespaces 可以针对 namespace 下的频道配置自定义参数。每个 namespace 都有自己的 name，并且拥有上面所有的针对频道的参数。name 必须唯一，并且由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$）。\n  namespaces 相关配置文件示例：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;very-long-secret-key\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;secret-api-key\u0026quot;, \u0026quot;anonymous\u0026quot;: true, \u0026quot;publish\u0026quot;: true, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 30, \u0026quot;namespaces\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;public\u0026quot;, \u0026quot;publish\u0026quot;: true, \u0026quot;anonymous\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 300, \u0026quot;history_recover\u0026quot;: true }, { \u0026quot;name\u0026quot;: \u0026quot;gossips\u0026quot;, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true } ]  }\n在以上配置下：\n\u0026ensp;\u0026ensp;- 频道 news 将使用全局参数配置。\n\u0026ensp;\u0026ensp;- 频道 public:news 将使用 public 命名空间的参数配置。\n\u0026ensp;\u0026ensp;- 频道 gossips:news 将使用 gossips 命名空间的参数配置。\n注意：频道（channel）相关的选项在命名空间（namespaces）中不存在继承关系。例如，你在配置文件的顶层配置了 presence: true，在命名空间中，频道的 presence 选项不会继承 true，你必须在命名空间中显式的启用。\nAdvanced configuration Centrifugo 还提供了更多的配置选项，一般情况下，你不需要配置他们，使用默认值即可。\n client_channel_limit\nDefault: 128\n设置单个客户端可以拥有的不同频道订阅的最大数量。\n channel_max_length\nDefault: 255 设置频道名称的最大长度。\n client_user_connection_limit\nDefault: 0\n同一用户（不包含匿名用户）连接到 Centrifugo 节点的最大连接数。默认值 0 表示不限制。\n client_request_max_size\nDefault: 65536\n客户端请求的最大允许长度，按字节计。\n client_queue_max_size\nDefault: 10485760\n客户端消息队列的最大大小，以字节计。默认大小为 10mb。（超出长度后缓慢的读取连接会被关闭？）\n client_anonymous\nDefault: false\n是否允许客户端匿名连接。如果设置为 true，则所有客户端可以在没有 JWT 令牌的情况下连接到 Centrifugo。在这种情况下，没有令牌的连接会被视为匿名（user ID 为空），并且只能订阅开启了 anonymous 选项的频道。\n sockjs_heartbeat_delay\nDefault: 25\nSockJS 心跳检测时间间隔，单位为秒。\n websocket_compression\nDefault: fasle 是否开启 websocket 压缩。\n gomaxprocs\nDefault: 0\n默认情况下，Centrifugo 会在所有可用 CPU 内核上执行，本选项可以用来限制 Centrifugo 同时可利用的 CPU 内核数。\n  Advanced endpoint configuration 启动 Centrifugo 后，你会有几个可用的端点（endpoint），如果你没有提供额外的选项，你默认会有 3 个端点。\n Default endpoints\n  主端点是原生的 Websocket 端口，用来支持纯 Websocket 协议的客户端连接：ws://localhost:8000/connection/websocket\nSockJS 端点，用来服务使用 SockJS library 连接的客户端：http://localhost:8000/connection/sockjs\n最后，API 端点，用来发布消息到频道以及执行其他可用的 API 指令：http://localhost:8000/api\n所有的端点默认使用 8000 端口，可以通过 port 选项修改：\n{ \u0026quot;port\u0026quot;: 9000 }  在生产环境中，你的域名将替代上面 URL 中的 localhost。如果你的 Centrifugo 服务器位于代理或者负载均衡服务器之后，则 URL 中可能没有端口号。\n Admin endpoints 启用管理端点：\n{ ... \u0026quot;admin\u0026quot;: true, \u0026quot;admin_password\u0026quot;: \u0026quot;\u0026lt;password\u0026gt;\u0026quot;, \u0026quot;admin_secret\u0026quot;: \u0026quot;\u0026lt;secret\u0026gt;\u0026quot; }  以上配置，使管理端点可用：http://localhost:8000\n通过上面的地址，你可以看到管理界面，通过上面配置的 admin_password 登录。\n Debug endpoints 当 Centrifugo 以 debug 模式启动时，debug 端点将可用。\n{ ... \u0026quot;debug\u0026quot;: true }  端点 URL: http://localhost:8000/debug/pprof/\n通过上面的地址，你可以看到 Centrifugo 实例的内部状态信息，这些信息在故障排除时会非常有用。\n Healthcheck endpoint 使用 health 选项（默认值为 false）来启用健康检查端点，该端点路径为 /health。同样，也可以在启动命令通过标记来启用健康检查端点：\n./centrifugo -c config.json --health  Custom internal ports 我们强烈建议，不要将 API、admin、debug 以及 prometheus 端点暴露到互联网，这些端点被视为内部的：\n API 端点（/api）: 针对 HTTP API 请求\n Admin web interface endpoints（/, /admin/auth, /admin/api）: used by web interface\n Prometheus endpoint(/metrics): 用于以 Prometheus 格式公开服务器指标\n Healthcheck endpoint(/health): 用来进行健康检查\n Debug endpoints(/debug/pprof): 用于检测服务器内部状态\n   这些内部端点，最好使用防火墙保护起来。\n可以通过 internal_port 选项来自定义内部端点的端口：\n{ ... \u0026quot;internal_port\u0026quot;: 9000 }   Disable default endpoints 以下选项在 v2.4.0 版本后有效：websocket_disable、sockjs_disable、api_disable，这些选项默认值均为 true。\n Customize handler endpoinds\n从 Centrifugo v2.2.5 开始，可以自定义 HTTP 处理程序端点，有如下几个选项可用：\n admin_handler_prefix（默认值为 \u0026quot;\u0026quot;）: 控制台 URL 前缀。\n websocket_handler_prefix（默认值为 /connection/websocket）: WebSocket URL前缀。\n sockjs_handler_prefix（默认值为 /connection/sockjs）: SockJS URL 前缀。\n api_handler_prefix（默认值为 /api）: HTTP API URL 前缀。\n prometheus_handler_prefix（默认值为 /metrics）: Prometheus URL 前缀。\n health_handler_prefix（默认值为 /health）: 健康检查 URL 前缀。\n   \n// \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nother options 下面几个参数在新版本中是否仍可使用，未验证\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;connection_lifetime 参数用来设置客户端连接的过期时间，单位为秒。如果该参数设置为0，表示该客户端连接永不过期。\n{ \u0026quot;secret\u0026quot;: \u0026quot;very-long-secret-key\u0026quot;, \u0026quot;connect_lifetime\u0026quot;: 0 }  \n频道（Channel）相关的选项：\nwatch：Centrifugo 会同时发生消息到 admin channel，这些消息可以在 admin 管理界面的 messages tab 下查看。这个参数要慎用，特别是针对消息发布频率比较高的频道，以免超出 admin client 的处理能力。本参数默认值为 fasle。\nhistory_drop_inactive：是否丢弃不活跃的历史消息。本参数可以大幅降低资源消耗（内存、消息传播次数）。简单来说，该参数开启后，Centrifugo 会主动丢弃不需要的历史消息。本参数默认值为 false。\n\n","id":45,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过 ./centrifugo -h 命令，可以查看所有的可用选型，","tags":["技术","Centrifugo"],"title":"Centrifugo（四）配置文件说明","uri":"https://rjguanwen.cn/2019/12/centrifugo_04/","year":"2019"},{"content":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。\n 提供基于频道的发布/订阅（PUB/SUB）模式。\n 容易和现有系统集成– 不改变已有后端情况下为系统提供实时通信能力。\n HTTP API 和已有后端通信 . API clients for Python, Ruby, PHP, Go, NodeJS。\n 浏览器可以通过SockJS或者纯粹Websocket协议和centrifugal通信。 提供 iOS和Android平台SDK。\n 采用Redis实现分布式部署，也支持使用Memory引擎单机简单部署。\n SHA-256 HMAC连接认证和隐私保护。\n 多种类型的频道 – 私有, 用户限制，客户端限制。\n 通过名字空间灵活配置频道。\n 支持即时消息和历史消息。\n 支持用户加入/离开消息。\n 网络重连后可以恢复消息。\n 内置管理界面，提供多种计量(Metrics)。\n 可用于WebRTC信令服务器。\n 多种部署手段(docker 镜像, RPM/DEB 包, Nginx 配置, TLS certificates)。\n MIT license。\n  基本运行框架：\n​ Centrifugo 作为独立服务器运行，可以处理来自应用程序用户的持久连接。应用的前端和后端可以基于任何语言进行开发。你的客户端使用应用程序后端提供的令牌(Token JWT)连接到 Centrifugo，并订阅频道（Channel）。当有事件发生时，后端应用可以使用 Centrifugo 的 API 发布消息到相关 Channel。随后，消息会被投递到所有订阅本 Channel 的客户端。\n项目地址：https://github.com/centrifugal/centrifugo\n","id":46,"section":"posts","summary":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。 提供基于频道的发布/订阅（PUB/SUB）模式。 容易和现有系统集成– 不改变已有后端情况下为系统","tags":["技术","Centrifugo"],"title":"Centrifugo（一）简介","uri":"https://rjguanwen.cn/2019/12/centrifugo_01/","year":"2019"},{"content":"摘抄并总结几条个人认为对提升自我帮助较大的好习惯，希望能坚持！\n\u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\n 心情糟糕时认真清理房间，心情莫名就开始清爽起来。\n 晨起刷牙时问问自己，如果要过好这一天，有什么可改良创造之处。\n 出差、旅行，记得带上一双跑鞋，一身运动服，去陌生城市的清晨跑个步，或许收获新的灵感。\n 睡前半小时远离手机和任何电子设备。\n 戒糖，戒所有含糖饮料，将可口可乐改为零度可乐等无糖甜味饮料。\n 当出现负面情绪和自我否定时，想办法转移自己的负面情绪，听增强自信的音乐，或者看励志书籍/电源。\n 误解或伤害过他人，一定要专门去道歉和解释。\n 每天问问自己，最重要的人，最重要的事情，最重要的目标，到底是什么；对那些不重要的人、事、物，尽可能少分配精力。\n 给人第二次机会，但不要给第三次。圣经上说过：凡第二次犯错者，必有第三次。 受人恩惠后除了说声谢谢，再赠送一件小礼品，可以结识到更亲密的关系。\n 建立自己的日常事项，比如日常写日记，日常有氧健身半小时，用恒定不变的习惯，抵抗人生的无常。会建立自信，缓解焦虑。\n 坚持阅读，家里准备着可以读的书，保证每天有一定的阅读时间，和利用碎片化时间阅读。\n 坚持记账，让你对自己的收入和消费情况充分了解，更有利于帮助你纠正不良消费习惯，管理好自己的财物状况。\n 吃饭不要吃太饱，八分饱更健康。\n 早睡早起，感觉精力充沛的时间更多。\n 洗手间内、公司走廊上不要和别人过多交流。\n 对方正在说话的时候不要插嘴。\n 正式去别人家里一定不要空手去！无论你们关系有多好！\n 使用积极语言： 当你以积极的语言开始陈述，对方也会摆出积极的姿态倾听你的话语。如果你没有自信，不妨抛开带有感情色彩的开场白，平缓地开始叙述。如果因为多余的客气话和谦虚反而让对方认为你没有能力，那就得不偿失了。\n 遇事少抱怨！万事健康第一！\n 宁可鱼死网破，也绝不降低原则与底限。\n 坚持反省： 每天晚上进行一次对自己今天所做事情的冥想，不管做的好还是不好，都去总结分析其缘由。 坚持运动： 无论你多么优秀、多么地与众不同，你都有责任为自己的身体负责。\n 不要说脏话，戒掉口头禅！\n  ","id":47,"section":"posts","summary":"摘抄并总结几条个人认为对提升自我帮助较大的好习惯，希望能坚持！ \u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen","tags":["个人"],"title":"坚持好习惯","uri":"https://rjguanwen.cn/2019/11/good_habits/","year":"2019"},{"content":"数据传输加密流程：\n","id":48,"section":"posts","summary":"数据传输加密流程：","tags":["技术"],"title":"数据加解传输过程","uri":"https://rjguanwen.cn/2019/11/data_translet_safely/","year":"2019"},{"content":"简单记录 go mod 的使用方式：\n 代理配置\n$env:GOPROXY = \u0026quot;https://goproxy.io\u0026quot; 或使用 goproxy.cn\n 初始化\ngo mod init ***，***为你要创建的mod名字，直接为工程名即可\n 自动下载依赖\ngo run *****.go，在执行前会首先查找并下载安装依赖\n 更新旧的 package import 方式，内部依赖也需要增加 mod 名\npackage main import ( api \u0026quot;mymod/api\u0026quot; // mymod 是初始化的 mod 名 \u0026quot;github.com/labstack/echo\u0026quot; ) func main() { e := echo.New() e.GET(\u0026quot;/\u0026quot;, api.MyAPI) e.Logger.Fatal(e.Start(\u0026quot;:1234\u0026quot;)) }  使用 replace 替换无法直接获取的 package\nreplace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u0026gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a )  检查并升级 package\ngo list -m -u all\ngo get -u need-upgrade-package 或者 go get -u\n  常用的命令如下：\n   命令 功能     download 下载依赖包   edit 编辑 go.mod   graph 打印模块依赖图   init 初始化 mod   tidy 拉取缺少的模块，移除不用的模块   vendor 将依赖复制到 vendor 下   verify 验证依赖是否正确   why 解释为什么需要依赖    ","id":49,"section":"posts","summary":"简单记录 go mod 的使用方式： 代理配置 $env:GOPROXY = \u0026quot;https://goproxy.io\u0026quot; 或使用 goproxy.cn 初始化 go mod init ***，***为你要创建的mod名字，直接为工程名即可 自动下载依赖 go run *****.","tags":["技术","GOLANG"],"title":"gomod使用记录","uri":"https://rjguanwen.cn/2019/11/gomod_use/","year":"2019"},{"content":"简单记录 govendor 的使用方式：\n 安装\ngo get -u -v github.com/kardianos/govendor\n 初始化 vendor 目录\ngovendor init\n 添加依赖包到 vendor 目录\ngovendor add +external 或 govendor add +e\n 从 $GOPATH 更新依赖包到 vendor 目录\ngovendor update +vendor\n 删除依赖包\ngovendor remove +vendor\n  常用的命令如下：\n   命令 功能     init 初始化 vendor 目录   list 列出所有依赖包   add 添加包到 vendor 目录   add PKG_PATH 添加指定依赖包到 vendor 目录   update 从 $GOPATH 更新依赖包到 vendor 目录   remove 从 vendor 管理中删除依赖   status 列出 vendor 管理的各个包的状态   fetch 添加或更新包到 vendor 目录   sync 同步，基于已存在的 vendor.json 拉取依赖包   get 类似 go get ，拉取依赖包到 vendor 目录    可用的 Status Types 如下：\n+local (l) packages in your project\n+external (e) referenced packages in GOPATH but not in current project\n+vendor (v) packages in the vendor folder\n+std (s) packages in the standard library\n+excluded (x) external packages explicitly excluded from vendoring\n+unused (u) packages in the vendor folder, but unused\n+missing (m) referenced packages but not found\n+program (p) package is a main package\n+outside +external +missing\n+all +all packages\n注意事项：\n使用 vendor 后，请配置 .gitignore 文件：\n/vendor/* !/vendor/vendor.json  ","id":50,"section":"posts","summary":"简单记录 govendor 的使用方式： 安装 go get -u -v github.com/kardianos/govendor 初始化 vendor 目录 govendor init 添加依赖包到 vendor 目录 govendor add +external 或 govendor add +e 从 $GOPATH 更新依赖包到 vendor 目录 govendor update +vendor 删除依赖包 govendor remove +vendor 常用的命令如","tags":["技术","GOLANG"],"title":"govendor使用记录","uri":"https://rjguanwen.cn/2019/11/govendor_use/","year":"2019"},{"content":" pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull，此时在较新的git版本上会报错。因为git认为两个仓库可能不是同一个，报错是为了防止开发者上传错误。\n解决办法： 在 pull 命令的最后增加--allow-unrelated-histories\n","id":51,"section":"posts","summary":"pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull","tags":["技术","GIT"],"title":"git错误解决","uri":"https://rjguanwen.cn/2019/11/git_01/","year":"2019"},{"content":" 技术的发展非常迅速，对新技术的探索与应用和  ","id":52,"section":"posts","summary":"技术的发展非常迅速，对新技术的探索与应用和","tags":["杂感随笔"],"title":"关于产品与技术的一些想法","uri":"https://rjguanwen.cn/2019/11/any_01/","year":"2019"},{"content":" 读书不是为了雄辩与驳斥，也不是为了轻信与盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们是在重新整理自己的偏见。\n 用一套程序保证问题会摆在桌面上，同时确保问题根源会得到剖析，这样才能实现持续的改进。\n “勤劳的人会发自内心的看不起懒惰的人”，这是一种心理效应。\n  ","id":53,"section":"posts","summary":"读书不是为了雄辩与驳斥，也不是为了轻信与盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们是在重新整理自己的偏见。 用一套程序保证问","tags":["句子"],"title":"杂句摘抄","uri":"https://rjguanwen.cn/2019/11/somewords_01/","year":"2019"},{"content":" 苦昼短 【唐】李贺\n飞光飞光，劝尔一杯酒。\n吾不识青天高，黄地厚。\n唯见月寒日暖，来煎人寿。\n食熊则肥，食蛙则瘦。\n神君何在？太一安有？\n天东有若木，下置衔烛龙。\n吾将斩龙足，嚼龙肉，使之朝不得回，夜不得伏。\n自然老者不死，少者不哭。\n何为服黄金、吞白玉？\n谁似任公子，云中骑碧驴？\n刘彻茂陵多滞骨，嬴政梓棺费鲍鱼。\n","id":54,"section":"posts","summary":"苦昼短 【唐】李贺 飞光飞光，劝尔一杯酒。 吾不识青天高，黄地厚。 唯见月寒日暖，来煎人寿。 食熊则肥，食蛙则瘦。 神君何在？太一安有？ 天东有若木，下置","tags":["诗词"],"title":"《苦昼短》","uri":"https://rjguanwen.cn/2019/11/art-1/","year":"2019"}],"tags":[{"title":"Centrifugo","uri":"https://rjguanwen.cn/tags/centrifugo/"},{"title":"docker","uri":"https://rjguanwen.cn/tags/docker/"},{"title":"gin","uri":"https://rjguanwen.cn/tags/gin/"},{"title":"GIT","uri":"https://rjguanwen.cn/tags/git/"},{"title":"golang","uri":"https://rjguanwen.cn/tags/golang/"},{"title":"Ignite","uri":"https://rjguanwen.cn/tags/ignite/"},{"title":"python","uri":"https://rjguanwen.cn/tags/python/"},{"title":"rasa","uri":"https://rjguanwen.cn/tags/rasa/"},{"title":"redis","uri":"https://rjguanwen.cn/tags/redis/"},{"title":"Superset","uri":"https://rjguanwen.cn/tags/superset/"},{"title":"个人","uri":"https://rjguanwen.cn/tags/%E4%B8%AA%E4%BA%BA/"},{"title":"古文","uri":"https://rjguanwen.cn/tags/%E5%8F%A4%E6%96%87/"},{"title":"句子","uri":"https://rjguanwen.cn/tags/%E5%8F%A5%E5%AD%90/"},{"title":"小品文","uri":"https://rjguanwen.cn/tags/%E5%B0%8F%E5%93%81%E6%96%87/"},{"title":"开发框架","uri":"https://rjguanwen.cn/tags/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"title":"技术","uri":"https://rjguanwen.cn/tags/%E6%8A%80%E6%9C%AF/"},{"title":"杂七杂八","uri":"https://rjguanwen.cn/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"杂感随笔","uri":"https://rjguanwen.cn/tags/%E6%9D%82%E6%84%9F%E9%9A%8F%E7%AC%94/"},{"title":"现代诗","uri":"https://rjguanwen.cn/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"},{"title":"诗词","uri":"https://rjguanwen.cn/tags/%E8%AF%97%E8%AF%8D/"},{"title":"读书","uri":"https://rjguanwen.cn/tags/%E8%AF%BB%E4%B9%A6/"}]}