{"categories":[{"title":"Centrifugo","uri":"https://rjguanwen.cn/categories/centrifugo/"},{"title":"docker","uri":"https://rjguanwen.cn/categories/docker/"},{"title":"gin","uri":"https://rjguanwen.cn/categories/gin/"},{"title":"GIT","uri":"https://rjguanwen.cn/categories/git/"},{"title":"GOLANG","uri":"https://rjguanwen.cn/categories/golang/"},{"title":"redis","uri":"https://rjguanwen.cn/categories/redis/"},{"title":"杂七杂八","uri":"https://rjguanwen.cn/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"系统架构","uri":"https://rjguanwen.cn/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"title":"诗词","uri":"https://rjguanwen.cn/categories/%E8%AF%97%E8%AF%8D/"}],"posts":[{"content":" Gin 使基于 go 语言的一个 web 框架，接口简洁，封装比较优雅，性能表现很好。\nGin 特性  快速：路由不使用反射，基于Radix树，内存占用少。\n 中间件：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。中间件机制极大地提高了框架的可扩展性。\n 异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。\n JSON：Gin可以解析并验证请求的JSON。这个特性对Restful API的开发尤其有用。\n 路由分组：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。\n 渲染内置：原生支持JSON，XML和HTML的渲染。\n  Quickstart  安装 Gin 前，首先要安装 Go，并做好各种设置。Go 版本要求 1.9 以上。\n 下载并安装 Gin。\n$ go get -u github.com/gin-gonic/gin  在代码中引入：\nimport \u0026quot;github.com/gin-gonic/gin\u0026quot;  如果需要使用类似 http.StatusOK 的常量，则需引入 net/http。\nimport \u0026quot;net/http\u0026quot;  示例代码：\npackage main import \u0026quot;github.com/gin-gonic/gin\u0026quot; func main() { r := gin.Default() r.GET(\u0026quot;/ping\u0026quot;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026quot;message\u0026quot;: \u0026quot;pong\u0026quot;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 }   ","id":0,"section":"posts","summary":"Gin 使基于 go 语言的一个 web 框架，接口简洁，封装比较优雅，性能表现很好。 Gin 特性 快速：路由不使用反射，基于Radix树，内存占用少。 中间件：HTTP","tags":["技术","gin","golang","开发框架"],"title":"Gin Quickstart","uri":"https://rjguanwen.cn/2020/06/gin_01/","year":"2020"},{"content":"","id":1,"section":"posts","summary":"","tags":["技术","gin","golang","开发框架"],"title":"Gin Quickstart","uri":"https://rjguanwen.cn/2020/06/gin_02/","year":"2020"},{"content":" Redis 常用命令，备查！\n1、测试 Docker 是否正常安装 docker run hello-world  2、Docker 状态信息查看 docker info  3、Docker 镜像管理 3.1 创建镜像 方法一：根据 Dockerfile 创建镜像  创建Dockerfile文件及其相关依赖文件\n 切换到Dockerfile文件所在目录，执行如下命令：\ndocker build -t \u0026lt;镜像名称\u0026gt; .   方法二：根据已有镜像实例化后进行交互式环境修改后保存  根据已有镜像实例化容器，记录容器ID，并进入交互式命令行\ndocker run -it \u0026lt;已有镜像名称\u0026gt; /bin/bash  在交互式命令行执行相关操作后退出交互式命令行\n 执行如下命令创建镜像\ndocker commit \u0026lt;容器ID\u0026gt; \u0026lt;镜像名称\u0026gt;   3.2 查看镜像 docker images  3.3 查看某个镜像详情 docker inspect \u0026lt;镜像名称\u0026gt;  3.4 删除镜像 docker rmi \u0026lt;镜像名称\u0026gt;  PS：对于存在容器的镜像需要先删除容器\n3.5 为镜像添加标签 docker tag \u0026lt;旧镜像名称\u0026gt; \u0026lt;新镜像名称\u0026gt;  PS：该命令会在原有的镜像上重新生成一个新的镜像名称对应该镜像\n3.6 拉取镜像 docker pull \u0026lt;镜像名称\u0026gt;  3.7 推送镜像 docker push \u0026lt;镜像名称\u0026gt;  4、容器操作 4.1 Docker 运行容器 基本命令：\ndocker run -参数 \u0026lt;镜像名称\u0026gt; \u0026lt;执行命令\u0026gt;   参数：\n -it：-i参数用设置容器中的STDIN是开启的。-t参数表示为创建的容器分配一个伪tty终端。 二者通常联合使用。\n \u0026ndash;name 容器名：用于为启动的容器设置一个容器名称。\n -d：将程序放在后台执行，用于创建守护式容器。\n \u0026ndash;restart：设置自动重启，可以设置什么情况下重启，例如\u0026ndash;restart=always，-restart=on-failure:5。\n -p：端口映射。例如：8000:80表示将容器的80端口映射到宿主机的8000端口。80表示将容器的80端口映射到宿主机的任意端口。\n -P：端口映射，将容器Dockerfile中EXPOSE指定的端口映射到宿主机的任意端口。\n -w：指定工作目录。\n -h：为容器设置HOST主机名称。\n \u0026ndash;entrypoint：强制指定启动程序。\n -v：卷映射。示例：/home/nianshi/logs:/logs表示将宿主机的/home/nianshi/logs目录挂载到容器的/logs目录下。\n \u0026ndash;link：容器链接。示例：redis:db表示将容器名称为redis的容器连接到新建的容器上，同时设置别名为db。此时在新容器中可以使用db来表示redis容器的地址。\n \u0026ndash;volumes-from：参数用于连接某个指定容器的卷，从而可以访问到指定容器中的所有的卷。示例：blog_demo表示新容器中挂载了blog_demo容器中所有的卷。\n \u0026ndash;rm：表示容器运行完成后自动删除。\n  镜像名称：\n此处镜像名称需要输入完成的镜像名称。\n镜像名称的格式如下：[Registry/][username/]简要镜像名称[:标签]\nPS：其中Registry默认为Docker Hub地址； 对于官方源，username不需要填写，否则必填；简要镜像名称必填；标签默认为latest。\n 执行命令：\n执行命令为启动容器时需要执行的操作。\n例如：/bin/bash\n  4.2 Docker 启动/停止/重启容器 启动一个尚未运行的容器：\ndocker start \u0026lt;容器名称/容器ID\u0026gt;  停止一个运行中的容器：\ndocker stop \u0026lt;容器名称/容器ID\u0026gt;  重启动一个容器：\ndocker restart \u0026lt;容器名称/容器ID\u0026gt;  4.3 进入容器 docker attach \u0026lt;容器名称/容器ID\u0026gt;  PS：它有一个缺点，只要这个连接终止，或者使用了exit命令，容器就会退出后台运行。\ndocker exec -it \u0026lt;容器名称/容器ID\u0026gt; /bin/bash  这个命令使用exit命令后，不会退出后台。\n4.4 已有镜像中运行命令/启动进程 docker exec -参数 \u0026lt;容器名称/容器ID\u0026gt; \u0026lt;执行命令\u0026gt;  4.5 查看容器 查看在运行容器列表：\ndocker ps  查看全部容器列表：\ndocker ps -a  查看容器的详细信息：\ndocker inspect \u0026lt;容器名称/容器ID\u0026gt;  查某容器日志：\ndocker logs \u0026lt;容器名称/容器ID\u0026gt;  PS：可以添加-f来监控日志文件，-t参数来增加时间戳。\n查看容器进程：\ndocker top \u0026lt;容器名称/容器ID\u0026gt;  查看容器端口：\ndocker port \u0026lt;容器名称/容器ID\u0026gt;  ","id":2,"section":"posts","summary":"Redis 常用命令，备查！ 1、测试 Docker 是否正常安装 docker run hello-world 2、Docker 状态信息查看 docker info 3、Docker 镜像管理 3.1 创建镜像 方法一：根据 Dockerfile 创建镜像 创建D","tags":["技术","docker"],"title":"Docker常用命令","uri":"https://rjguanwen.cn/2020/06/docker_01/","year":"2020"},{"content":" Redis 常用命令，备查！\n\u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\n一、管理命令 1 启动 Redis \u0026gt; redis-server [--port 6379]  如果命令参数过多，建议通过配置文件来启动 Redis。\n\u0026gt; redis-server [xx/xx/redis.conf]  2 连接 Redis \u0026gt; ./redis-cli [-h 127.0.0.1 -p 6379]  3 停止 Reids \u0026gt; redis-cli shutdown \u0026gt; kill redis-pid  以上两条命令，效果一样\n4 发送命令 给 Redis 发送命令有两种方式： 1、redis-cli 带参数运行\n\u0026gt; redis-cli \u0026lt;命令，如 shutdown\u0026gt;  2、redis-cli不带参数运行，先执行 redis-cli，进入命令行执行命令\n5 测试连通性 \u0026gt; ping  二、key 操作命令 1 获取所有键  语法：keys pattern\n\u0026gt; keys *   * 表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度O(n)，在生产环境不建议使用。\n   2 获取键总数  语法：dbsize - 获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度O(1)。\n 3 查询键是否存在  语法：exists key [key \u0026hellip;] - 可查询多个key，返回存在的个数。\n 4 删除键  语法：del key [key \u0026hellip;] - 可以删除多个key，返回删除成功的个数。\n 5 查询键类型  语法：type key\n 6 移动键  语法：move key db 如把 javastack 移到 2 号数据库：\n\u0026gt; move javastack 2 (integer) 1 \u0026gt; select 2 OK \u0026gt; keys * 1) \u0026quot;javastack\u0026quot;   7 查询 key 的生命周期（秒）  秒语法：ttl key 毫秒语法：pttl key\n \u0026gt; ttl javastack (integer) -1   -1: 永不过期。  8 设置过期时间  秒语法：expire key seconds 毫秒语法：pexpire key milliseconds\n 9 设置永不过期  语法：persist key\n 10 更改键名称  语法：rename key newkey\n 三、字符串操作命令 字符串是Redis中最基本的数据类型，单个数据能存储的最大空间是512M。\n1 存放键值  语法：set key value [EX seconds] [PX milliseconds] [NX|XX]\n nx: 如果 key 不存在则建立；\nxx: 如果 key 存在则修改其值；\n2 获取键值  语法：get key\n 3 值递增/递减 如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错。\n\u0026gt; 语法：incr key\n如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错。\n同样，递减使用decr、decrby命令。\n4 批量存放键值  语法：mset key value [key value \u0026hellip;]\n 5 批量获取键值  语法：mget key [key \u0026hellip;]\n Redis接收的是UTF-8的编码，如果是中文一个汉字将占3位返回。\n6 获取值长度  语法：strlen key\n 7 追加内容  语法：append key value\n 向键值尾部拼接字符串。\n8 获取部分字符  语法：getrange key start end\n 四、集合操作命令 集合类型和列表类型相似，只不过是集合是无序且不可重复的。\n集合 1 存储值  语法：sadd key member [member \u0026hellip;]\n\u0026gt; sadd langs java php c++ go ruby python kotlin java (integer) 7   2 获取元素  获取所有元素语法：smembers key\n随机获取元素语法：srandmember key count - 随机获取集合中 count 指定个数的元素\n 3 判断集合是否存在元素  语法：sismember key member\n 4 获取集合元素个数  语法：scard key\n 5 删除集合元素  语法：srem key member [member \u0026hellip;]\n 6 弹出元素  语法：spop key [count]\n 有序集合 和列表的区别：\n 列表使用链表实现，两头快，中间慢。有序集合是散列表和跳跃表实现的，即使读取中间的元素也比较快。\n 列表不能调整元素位置，有序集合能。\n 有序集合比列表更占内存。\n  1 存储值  语法：zadd key [NX|XX] [CH] [INCR] score member [score member \u0026hellip;]\n\u0026gt; zadd fooCounts 16011 tid 20023 huny 2893 nosy (integer) 3   2 获取元素分数  语法：zscore key member\n\u0026gt; zscore footCounts tid \u0026quot;16011\u0026quot;  获取指定范围排名语法：zrange key start stop [WITHSCORES]\n// 获取所有，没有分数 \u0026gt; zrange footCounts 0 -1 1) \u0026quot;nosy\u0026quot; 2) \u0026quot;tid\u0026quot; 3) \u0026quot;huny\u0026quot; // 获取所有及分数 \u0026gt; zrange footCounts 0 -1 Withscores 1) \u0026quot;nosy\u0026quot; 2) \u0026quot;2893\u0026quot; 3) \u0026quot;tid\u0026quot; 4) \u0026quot;16011\u0026quot; 5) \u0026quot;huny\u0026quot; 6) \u0026quot;20082\u0026quot;  获取指定分数范围排名语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count]\n 3 增加指定元素分数  zincrby key increment member\n 4 获取集合元素个数  语法：zcard key\n 5 获取指定范围分数个数  语法：zcount key min max\n 6 删除指定元素  语法：zrem key member [member \u0026hellip;]\n 7 获取元素排名  语法 zrank key member\n 五、列表操作命令 列表类型是一个有序的字段串列表，内部是使用双向链表实现，所有可以向两端操作元素，获取两端的数据速度快，通过索引到具体的行数比较慢。\n列表类型的元素是有序且可以重复的。\n1 存储值  左端存值语法：lpush key value [value \u0026hellip;] 右端存值语法：rpush key value [value \u0026hellip;] 索引存值语法：lset key index value\n 2 弹出元素  左侧弹出语法：lpop key 右侧弹出语法：rpop key\n 3 获取元素个数  语法：llen key\n 4 获取列表元素  两边获取语法：lrange key start stop\n\u0026gt; lpush users tom kitty land pony jack maddy (integer) 6 \u0026gt; lrange users 0 3 1) \u0026quot;maddy\u0026quot; 2) \u0026quot;jack\u0026quot; 3) \u0026quot;pony\u0026quot; 4) \u0026quot;land\u0026quot; // 获取所有 \u0026gt; lrange users 0 -1 1) \u0026quot;maddy\u0026quot; 2) \u0026quot;jack\u0026quot; 3) \u0026quot;pony\u0026quot; 4) \u0026quot;land\u0026quot; 5) \u0026quot;kitty\u0026quot; 6) \u0026quot;tom\u0026quot; // 从右端索引 \u0026gt; lrange users -3 -1 1) \u0026quot;land\u0026quot; 2) \u0026quot;kitty\u0026quot; 3) \u0026quot;tom\u0026quot;  索引获取语法：lindex key index\n\u0026gt; lindex list 2 \u0026quot;ketty\u0026quot; // 从右端获取 \u0026gt; lindex list -5 \u0026quot;sady\u0026quot;   5 删除元素  根据值删除语法：lrem key count value\n\u0026gt; lpush userids 111 222 111 222 222 333 222 222 (integer) 8 // count=0 删除所有 \u0026gt; lrem userids 0 111 (integer) 2 // count \u0026gt; 0 从左端删除前count个 \u0026gt; lrem userids 3 222 (integer) 3 // count \u0026lt; 0 从右端删除前count个 \u0026gt; lrem userids -3 222 (integer) 2  范围删除语法：ltrim key start stop\n// 只保留2-4之间的元素 \u0026gt; ltrim list 2 4 OK   六、散列操作命令 redis字符串类型键和值是字典结构形式，这里的散列类型其值也可以是字典结构。\n1 存放键值  单个语法：hset key field value\n\u0026gt; hset user name javastack (integer) 1  多个语法：hmset key field value [field value \u0026hellip;]\n\u0026gt; hmset user name javastack age 20 address china OK  不存在时语法：hsetnx key field value\n\u0026gt; hsetnx user tall 180 (integer) 0   2 获取字段值  单个语法：hget key field\n \u0026gt; hget user age \u0026quot;20\u0026quot;   多个语法：hmget key field [field \u0026hellip;]\n \u0026gt; hmget user name age address 1) \u0026quot;javastack\u0026quot; 2) \u0026quot;20\u0026quot; 3) \u0026quot;china\u0026quot;   获取所有键与值语法：hgetall key\n \u0026gt; hgetall user 1) \u0026quot;name\u0026quot; 2) \u0026quot;javastack\u0026quot; 3) \u0026quot;age\u0026quot; 4) \u0026quot;20\u0026quot; 5) \u0026quot;address\u0026quot; 6) \u0026quot;china\u0026quot;   获取所有字段语法：hkeys key\n \u0026gt; hkeys user 1) \u0026quot;name\u0026quot; 2) \u0026quot;address\u0026quot; 3) \u0026quot;tall\u0026quot; 4) \u0026quot;age\u0026quot;   获取所有值语法：hvals key\n \u0026gt; hvals user 1) \u0026quot;javastack\u0026quot; 2) \u0026quot;china\u0026quot; 3) \u0026quot;170\u0026quot; 4) \u0026quot;20\u0026quot;  3 判断字段是否存在  语法：hexists key field\n \u0026gt; hexists user address (integer) 1  4 获取字段数量  语法：hlen key\n \u0026gt; hlen user (integer) 4  5 递增/减  语法：hincrby key field increment\n \u0026gt; hincrby user tall -10 (integer) 170  6 删除字段  语法：hdel key field [filed \u0026hellip;]\n ","id":3,"section":"posts","summary":"Redis 常用命令，备查！ \u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢","tags":["技术","redis"],"title":"Redis 常用命令","uri":"https://rjguanwen.cn/2020/06/redis_01/","year":"2020"},{"content":" 什么是ADR ADR（Architecture Decision Records）即架构决策记录。\n架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求进行的选择设计。软件架构决策需要在软件质量属性、成本、时间以及其他各种因素之间，做出正确的权衡。架构决策记录（ADR） 是跟踪软件设计选择的一种方法，其应能向项目经理、架构师、开发人员及软件的其他利益相关者，清楚阐明选择何种解决方案以及为此做出的权衡。\n架构决策记录记啥？ 架构决策记录（ADR）首先要解决的基本问题：“我们做了什么决策？”、“为什么这样决策？”，稍次要的问题包括：“我们还考虑过哪些解决方案？”、“为什么没有采用？”等。\n架构决策记录的作用  可以作为和开发人员进行沟通的工具，说明应遵循的重要架构原则\n 当开发人员对架构背后的逻辑提出质疑时，使团队成员能够“就事论事”，提高效率。（如果事实表明你的决策站不住脚，便应虚心接受批评，改正架构）\n 向领导和利益相关者说明这样构建软件的确切原因（比如，采用某种较为昂贵的硬件或软件的必要性等）\n 要把项目移交给下任架构师时，保持架构设计的有序传承\n 如果相关条件发生变化，需要对决策重新评估时，它可以作为一个起点\n 架构决策记录也会倒逼架构师在进行架构决策时更严谨，有助于确保基础的扎实稳固\n  架构决策记录的组成部分 每个架构决策至少有 6 部分组成：标题、时间、状态（Status）、上下文（Context）、决策（Decision）、后果（Consequences）。\n 标题：按数字顺序编号，简要描述架构决策内容\n 时间：在标题下一行，记录架构决策做出的日期，如 日期：2020年2月28日\n 状态：表示本架构决策当前所处的状态，可选项包括：\n 提议：决策已被提出讨论，但是利益相关方尚未达成一致。\n 公认：决策已讨论通过并达成一致。\n 已取代：因条件变化，已有新的架构决策取代本决策。此时需要给出新决策链接。\n 已弃用：本架构决策已撤销，不再使用。\n  上下文：架构决策相关的背景及决策原因。本部分的语言应该是价值中立的，只用于描述事实\n 决策：本部分简洁明了的描述我们最终确定的架构决策\n 后果：本部分描述应用决策后产生的影响，所有的影响都应该列在这里，包括“积极的”、“中性的”与消极的”\n  其他关键问题  架构决策按照顺序和数字编号，不要打乱顺序。\n 已记录的架构决策不应该被删除，如果被取代掉或已不符合当前情况，请将其标记为 已取代 或 已弃用\n  一个架构决策记录示例 1. 使用 ssh key 替换用户名密码方式登录 日期: 2019年11月12日 状态： 公认 上下文： 当前我们使用的是用户名、密码方式进行服务器登录，存在以下问题 安全性问题，密码面临被破解的风险； 易用性问题，无法使用 config 记录密码，可以使用第三方软件解决，如，SecureCRT，ZOC7； 无法充分使用 local terminal，如 iTerm2； 参考: SSH: passwords or keys? https://lwn.net/Articles/369703/ Why is SSH key authentication better than password authentication? https://superuser.com/questions/303358/why-is-ssh-key-authentication-better-than-password-authentication Why is using an SSH key more secure than using passwords? https://security.stackexchange.com/questions/69407/why-is-using-an-ssh-key-more-secure-than-using-passwords 决策： 禁用用户名、密码登录，使用 ssh key 进行登录 后果： 团队成员使用新方式需要适应； key 的管理需要统一（需要引入堡垒机）。  ","id":4,"section":"posts","summary":"什么是ADR ADR（Architecture Decision Records）即架构决策记录。 架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求","tags":["技术"],"title":"架构决策记录（ADR）","uri":"https://rjguanwen.cn/2020/02/adr/","year":"2020"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，我们将使用前面章节中讲到的 Redis engine。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;首先，我们需要有一个处在运行状态的 Redis 服务器。然后，我们可以一次启动三个 Cetrifugofu 服务节点：\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;打开命令行窗口，启动第一个节点：\n centrifugo --config=config.json --port=8000 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;如果 Redis 和 Centrifugo 运行在同一台机器，并且使用了默认的端口号，上面命令中的 redis_host 与 redis_port 选项可以省略。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;然后打开一个新的命令行窗口，启动第二个节点：\n centrifugo --config=config.json --port=8001 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;此命令中，我们指定了一个新的端口 8001，以防与节点一出现端口冲突。如果你的两个节点不在一台机器上，则不存在该问题。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;接下来再次开启一个新的命令行窗口，启动第三个节点：\n centrifugo --config=config.json --port=8002 --engine=redis --redis_host=127.0.0.1 --redis_port=6379  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;现在你已经拥有了三个 Centrifugo 实例，分别运行在 8000、8001、8002 端口，客户端可以选择连接任何一个实例。同样，你也可以发送 API 请求到任何一个节点。这三个节点通过 Redis 的 PUB/SUB 机制实现消息共享。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;多个节点之间的负载均衡可以通过 Nginx 实现。要非常注意的一点是，如果你的客户端使用了 SockJS 连接到 Centrifugo 节点，那么接下来的该客户端的请求只能路由到同一节点，因为该节点保存了客户端的会话信息。而使用 websocket 则不存在该问题。\nRedis 分片\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;从 V1.6.0 开始 Centrifugo 内置了对 Redis 分片的支持。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;该功能防止 Redis 在大型的 Centrifugo 应用中成为性能瓶颈。Redis 是单线程服务器，它速度非常快，但是当你的 Redis CPU 使用率接近 100% 的时候，分片可以帮助你的应用程序实现扩展。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;目前，Centrifugo 支持基于逗号的简单方法来配置 Redis 分片。\n示例一（基于本机运行的两个 Redis 分片来启动 Centrifugo）：\n centrifugo --config=config.json --engine=redis --redis_port=6379,6380  示例二（基于运行在不同主机上的 Reids 实例来启动 Centrifugo）：\n centrifugo --config=config.json --engine=redis --redis_host=192.168.1.34,192.168.1.35  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;启用分片后，Centrifugo 将使用一致性哈希算法在已配置的 Redis 实例上传播频道和历史/状态信息。\nKeyDB engine\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo Redis engine 可与 KeyDB 无缝协作，KeyDB 服务器与 Reids 兼容，并且提供其他一些附加功能。此功能为实验功能，不保证未来版本仍然与 KeyDB 兼容。\n","id":5,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 服务器支持多节点部署，并支持对客户端请求的负载均衡。本文中，我们将启动三个 Centrifugo 服务节点来进行演示，这些节点通过 Redis 互相连接。为了达到这个目的，","tags":["技术","Centrifugo"],"title":"Centrifugo（九）使用 Redis 实现伸缩","uri":"https://rjguanwen.cn/2019/12/centrifugo_09/","year":"2019"},{"content":"Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本文主要描述如何针对不同的动作（actions）生成令牌及签名。如果你使用 Python，那么所有所需的方法都已经封装到 Cent 库中，你直接使用即可。针对 PHP、GO、Ruby、NodeJs等常用开发语言，同样有官方 HTTP API clients 提供，可以直接使用。\n","id":6,"section":"posts","summary":"Centrifugo 使用具有 SHA-256 摘要算法的 HMAC（Hash-based Message Authentication Code）来创建连接令牌以及对数据进行签名。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026e","tags":["技术","Centrifugo"],"title":"Centrifugo（十）令牌和签名","uri":"https://rjguanwen.cn/2019/12/centrifugo_10/","year":"2019"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从他已订阅的频道中读取消息。在有些时候，这不是我们想要的。因此，我们需要连接检查机制。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 有一个选项 connection_lifetime。其默认值为 0，此时，连接检查机制处于关闭状态。当该选项设置的数值大于 0 时，连接检查机制开启，并且这个数值表示成功连接后，连接保持的时长（以秒为单位）。例如，将 connection_lifetime 设置为 60，表示连接保持时长为 60 秒。当连接时长到期时，Javascript 浏览器客户端将向应用程序后端发送 AJAX POST 请求。默认情况下，此请求发送到 URL /centrifuge/refresh。你可以使用 Javascript 客户端配置选项 refreshEndpoint 进行更改。应用服务器需要返回带有连接凭据的 JSON 作为响应。返回相应示例（Python）：\n to_return = { 'user': \u0026quot;USER ID\u0026quot;, 'timestamp': \u0026quot;CURRENT TIMESTAMP AS INTEGER\u0026quot;, 'info': \u0026quot;ADDITIONAL CONNECTION INFO\u0026quot;, 'token': \u0026quot;TOKEN BASED ON PARAMS ABOVE\u0026quot;, } return json.dumps(to_return)  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;你在响应中返回的连接凭据必须与页面初始化时的凭据一致，其中 timestamp 要使用当前的时间戳。然后，Javascript 客户端会将凭据发送到 Centrifugo 服务器，并刷新连接时长。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;如果你不想保持该连接，应用程序后端只需要向 AJAX POST 请求返回 403 响应即可。\n","id":7,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当客户端使用适当的凭据连接到 Centrifugo 后，连接是一直存在的，哪怕你在应用程序中禁止了该用户，他也能从","tags":["技术","Centrifugo"],"title":"Centrifugo（八）连接检查","uri":"https://rjguanwen.cn/2019/12/centrifugo_08/","year":"2019"},{"content":" 经常记不住 Git 命令，备查！\n本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n一般来说，日常使用只要记住下图 6 个命令即可。\n专用名词译名：\nWorkspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库  一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]  二、配置 Git 的配置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026quot;[NAME]\u0026quot; $ git config [--global] user.email \u0026quot;[EMAIL ADDRESS]\u0026quot;  三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]  四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...  五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]  六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]  七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\u0026quot;提交说明\u0026quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \u0026quot;@{0 day ago}\u0026quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog  八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all  九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop  十、其他 # 生成一个可供发布的压缩包 $ git archive  ","id":8,"section":"posts","summary":"经常记不住 Git 命令，备查！ 本篇博客是转发的别人的，原文地址：http://www.ruanyifeng.com/blog/2015/12/gi","tags":["技术","GIT"],"title":"常用 Git 命令清单","uri":"https://rjguanwen.cn/2019/12/git_03/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。\n Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.rjguanwen.cn，那么 API 地址则是 https://centrifugo.rjguanwen.cn/api/。\n 当使用 HTTP API 时，你需要做的是向正确的地址发送正确构造的 POST 请求。\n API 请求是一个 POST application/json 请求，指令包含在请求体，并带有一个附加的header X-API-Sign。请求体是 JSON 结构，其中包含了你需要执行的指令，指令可以是单条也可以是多条。\n X-API-Sign 标头是基于 Centrifugo 密钥和要发送的 JSON 正文的 SHA-256 HMAC 字符串。该字符串主要用于 Centrifugo 对请求进行验证，以防假冒。在大多数情况下，你可以使用防火墙规则保护 Centrifugo API 端点，并且在 Centrifugo 启动时使用 --api_insecure 选项禁用验证检查。在此模式下，你使用 HTTP API 只需要发送 POST 请求，而不需要额外的 X-API-Sign 标头。\n 请求体是 JSON 对象，包括两个属性：method 和 params：\n# 一条指令 command = json.dumps({ \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;:{}} }) # 多条指令 command = json.dumps([ { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;1\u0026quot;}} }, { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;news\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;2\u0026quot;}} }, ])  Centrifugo 已经提供了一些编程语言的官方 API client（API libraries）以方便调用 HTTP API。但是，你也可以不使用官方提供的 API client，而是自己编写程序发送请求，这样做也并不麻烦，而且可以减少你的应用程序的依赖。以 Python（使用 requests 库发送请求）为例：\nimport json import requests from cent.core import generate_api_sign commands = [ { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;channel\u0026quot;: \u0026quot;docs\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;content\u0026quot;: \u0026quot;1\u0026quot;}} } ] encoded_data = json.dumps(commands) # 使用官方库中的方法来生成标识 sign = generate_api_sign('very-long-secret-key', encoded_data) headers = {'Content-type': 'application/json', 'X-API-Sign': sign} r = requests.post(\u0026quot;https://centrifugo.rjguanwen.cn/api/, data=encoded_data, headers=headers) print r.json()   \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在上面的代码中，我们使用了官方提供的 Python 语言的 Cent 库中的方法来生成标识（sign）。你也可以自己构建标识。在上例中，commands 是一个数组，可以包含多条指令。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;我们可用的指令包括：publish、broadcast、unsubscribe、presence、history、disconnect、channels、stats、node。\npublish \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;publish 指令用来向频道发送消息。publish 方法的 params 是一个 JSON 对象，至少包含两个 KEY ：channel 和 data。从version 0.2.0之后，可以选择将客户端ID client 包含在 publish 指令中。\n{ \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;hello\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;long-unique-client-id\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot; }  broadcast \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;与 publish 基本类似，不过可以同时发布一条消息到多个渠道。\n{ \u0026quot;method\u0026quot;: \u0026quot;broadcast\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channels\u0026quot;: [\u0026quot;CHANNEL_1\u0026quot;, \u0026quot;CHANNEL_2\u0026quot;], \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;Hello\u0026quot; } } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;broadcast 指令同样可以包含 client 参数。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本指令会将消息发送到所有指定队列直到第一个错误发生。当错误发生时，错误信息会以响应的方式返回，并且停止消息的继续发布。当使用 Redis API 时，错误信息无法返回，而是会记录日志。\nunsubscribe \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;unsubscribe 用来从渠道取消用户的订阅。params 包括两个 KEY：channel、user。\n \u0026quot;method\u0026quot;: \u0026quot;unsubscribe\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot;, \u0026quot;user\u0026quot;: \u0026quot;USER ID\u0026quot; }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;unsubscribe\u0026quot; }  disconnect \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;disconnect 指令用来通过 ID 断开用户连接。params 包含一个 KEY：user。\n{ \u0026quot;method\u0026quot;: \u0026quot;disconnect\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;USER ID\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: null, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;disconnect\u0026quot; }  presence \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;presence 指令用来获取渠道的状态信息（当前订阅本渠道的所有客户端）。params 包含一个 KEY：channel。\n{ \u0026quot;method\u0026quot;: \u0026quot;presence\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;e5ee0ab0-fde1-4543-6f36-13f2201adeac\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;e5ee0ab0-fde1-4543-6f36-13f2201adeac\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } } } }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;presence\u0026quot; }  history \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;history 指令用来获取渠道的历史信息（发送到本渠道的最近的消息列表）。params 包含一个 KEY：channel。\n{ \u0026quot;method\u0026quot;: \u0026quot;history\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;CHANNEL NAME\u0026quot; } }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: [ { \u0026quot;uid\u0026quot;: \u0026quot;8c5dca2e-1846-42e4-449e-682f615c4977\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;1445536974\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;world\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot; }, { \u0026quot;uid\u0026quot;: \u0026quot;63ecba35-e9df-4dc6-4b72-a22f9c9f486f\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;1445536969\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;user\u0026quot;: \u0026quot;2694\u0026quot;, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot;, \u0026quot;default_info\u0026quot;: { \u0026quot;first_name\u0026quot;: \u0026quot;Alexandr\u0026quot;, \u0026quot;last_name\u0026quot;: \u0026quot;Emelin\u0026quot; }, \u0026quot;channel_info\u0026quot;: { \u0026quot;channel_extra_info_example\u0026quot;: \u0026quot;you can add additional JSON data when authorizing\u0026quot; } }, \u0026quot;channel\u0026quot;: \u0026quot;$public:chat\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;input\u0026quot;: \u0026quot;hello\u0026quot; }, \u0026quot;client\u0026quot;: \u0026quot;a1c2f99d-fdaf-4e00-5f73-fc8a6bb7d239\u0026quot; } ] }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;history\u0026quot; }  channels \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;channels 指令用来获取活动渠道列表（拥有至少一个订阅者）。\n{ \u0026quot;method\u0026quot;: \u0026quot;channels\u0026quot;, \u0026quot;params\u0026quot;: {} }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;: [ \u0026quot;$public:chat\u0026quot;, \u0026quot;news\u0026quot;, \u0026quot;notifications\u0026quot; ] }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;channels\u0026quot; }  stats \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;stats 指令用来获取正在运行的 Centrifugo 节点的统计信息。\n \u0026quot;method\u0026quot;: \u0026quot;stats\u0026quot;, \u0026quot;params\u0026quot;: {}  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;: { \u0026quot;nodes\u0026quot;: [ { \u0026quot;uid\u0026quot;: \u0026quot;6045438c-1b65-4b86-79ee-0c35367f29a9\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;MacAir.local_8000\u0026quot;, \u0026quot;num_goroutine\u0026quot;: 21, \u0026quot;num_clients\u0026quot;: 0, \u0026quot;num_unique_clients\u0026quot;: 0, \u0026quot;num_channels\u0026quot;: 0, \u0026quot;started_at\u0026quot;: 1445536564, \u0026quot;gomaxprocs\u0026quot;: 1, \u0026quot;num_cpu\u0026quot;: 4, \u0026quot;num_msg_published\u0026quot;: 0, \u0026quot;num_msg_queued\u0026quot;: 0, \u0026quot;num_msg_sent\u0026quot;: 0, \u0026quot;num_api_requests\u0026quot;: 0, \u0026quot;num_client_requests\u0026quot;: 0, \u0026quot;bytes_client_in\u0026quot;: 0, \u0026quot;bytes_client_out\u0026quot;: 0, \u0026quot;memory_sys\u0026quot;: 7444728, \u0026quot;cpu_usage\u0026quot;: 0 } ], \u0026quot;metrics_interval\u0026quot;: 60 } }, \u0026quot;error\u0026quot;: null, \u0026quot;method\u0026quot;: \u0026quot;stats\u0026quot; }  node \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;node 指令用来获取单个 Centrifugo 节点的信息。\n{ \u0026quot;method\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;params\u0026quot;: {} }  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;响应示例：\n{ \u0026quot;body\u0026quot;: { \u0026quot;data\u0026quot;:{ \u0026quot;uid\u0026quot;:\u0026quot;c3ceab87-8060-4c25-9cb4-94eb9db7899a\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;MacAir.local_8000\u0026quot;, \u0026quot;num_goroutine\u0026quot;:14, \u0026quot;num_clients\u0026quot;:0, \u0026quot;num_unique_clients\u0026quot;:0, \u0026quot;num_channels\u0026quot;:0, \u0026quot;started_at\u0026quot;:1455450238, \u0026quot;gomaxprocs\u0026quot;:4, \u0026quot;num_cpu\u0026quot;:4, \u0026quot;num_msg_published\u0026quot;:0, \u0026quot;num_msg_queued\u0026quot;:0, \u0026quot;num_msg_sent\u0026quot;:0, \u0026quot;num_api_requests\u0026quot;:3, \u0026quot;num_client_requests\u0026quot;:0, \u0026quot;bytes_client_in\u0026quot;:0, \u0026quot;bytes_client_out\u0026quot;:0, \u0026quot;memory_sys\u0026quot;:0, \u0026quot;cpu_usage\u0026quot;:0 } }, \u0026quot;error\u0026quot;:null, \u0026quot;method\u0026quot;:\u0026quot;node\u0026quot; }  ","id":9,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;HTTP API 是最常用的向 Centrifugo 发送指令的一种方式。本文专门讲解 HTTP API。 Centrifugo API 的 url 为 /api/。如果你的 Centrifugo 服务域名是 https://centrifugo.","tags":["技术","Centrifugo"],"title":"Centrifugo（七）Server API","uri":"https://rjguanwen.cn/2019/12/centrifugo_07/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Memory 引擎只支持一个 Centrifugo 节点，而 Redis 引擎支持多节点部署。可以通过配置文件中的 engine 属性来设置 Centrifugo 使用的引擎，也可以在启动命令中通过 engine 参数指定：\ncentrifugo --config=config.json --engine=redis  也可以在配置文件中指定：\n{ ... \u0026quot;engine\u0026quot;: \u0026quot;redis\u0026quot; }  Memory engine 只支持一个节点，所有信息存储在服务器内存中。\n 优点\n 速度快\n 简单，不需要安装 Redis\n  缺点\n 无法扩展节点\n   Redis engine \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;支持 Centrifugo 在多服务器伸缩部署，使用 Redis 作为消息路由，状态信息及历史数据保存在 Redis 内存数据库中，内部节点之间的通讯通过 Redis 的发布/订阅机制来进行通信。同时，此模式支持 API 命令排队。\nRedis 最低版本要求为 v3.2.0\n与 Redis 引擎相关的配置选项如下：\n redis_host (string, default \u0026quot;127.0.0.1\u0026quot;)\n redis_port (int, default 6379)\n redis_url (string, default \u0026quot;\u0026quot;): optional Redis connection URL\n redis_password (string, default \u0026quot;\u0026quot;)\n redis_db (int, default 0): number of Redis db to use\n redis_tls (boolean, default false): enable Redis TLS connection (new in v2.0.2)\n redis_tls_skip_verify (boolean, default false): disable Redis TLS host verification (new in v2.0.2)\n redis_sentinels (string, default \u0026quot;\u0026quot;): 以逗号分隔的 Sentinels for HA 列表\n redis_mastr_name (string, default \u0026quot;\u0026quot;): name of Redis master Sentinel monitors\n redis_prefix (string, default \u0026quot;centrifugo\u0026quot;): 用于 Redis 中的频道（channels）与键（keys）的自定义前缀\n redis_sequence_ttl (int, default 0): 设置 Redis 引擎中序列数据的过期时间，以秒为单位。Sequence meta key in Redis is a HASH that contains current sequence number in channel and epoch value. 默认情况下，频道的序列数据是永不过期的。尽管在某下情况下（例如当频道只创建了很短一段时间，之后就不再使用），创建的序列元数据会被保存在内存中，而实际上并没有用。从长远来看，这也可以认为是一种内存泄漏。将本选项设置为一个合适的值，将有助于改善这种状况\n  以上这些选项均可以在配置文件中设置，其中的部分可以在启动命令行参数中直接设置 。\n关于选项 redis_url，该选项用于设置 Redis 的连接字符串，格式为 redis://:password@hostname:port/db。当 --redis_url 参数生效时，--redis_host、--redis_port、--redis_password、--redis_db 参数会被替代掉，不再生效。\n\n// \u0026mdash;\u0026ndash; 以下为老版本内容，未验证是否在新版本仍适用 \u0026mdash;\u0026mdash;-\n --redis_api enable Redis API listener (Redis engine) --redis_api_num_shards int Number of shards for redis API queue (Redis engine) --redis_db string redis database (Redis engine) (default \u0026quot;0\u0026quot;) --redis_host string redis host (Redis engine) (default \u0026quot;127.0.0.1\u0026quot;) --redis_master_name string Name of Redis master Sentinel monitors (Redis engine) --redis_password string redis auth password (Redis engine) --redis_pool int Redis pool size (Redis engine) (default 256) --redis_port string redis port (Redis engine) (default \u0026quot;6379\u0026quot;) --redis_sentinels string Comma separated list of Sentinels (Redis engine) --redis_url string redis connection URL in format redis://:password@hostname:port/db (Redis engine)  说明：\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;1. 当 --redis_url 参数生效时，--redis_host、--redis_port、--redis_password、--redis_db 参数会被替代掉，不再生效。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;2. --redis_api_num_shards 参数必须与 --redis_api 参数配合使用。它将创建 N 个分片队列。该参数主要用于超高并发的消息发布。通过对 API 队列分片降低单队列的压力，提升消息发布效率。如果 --redis_api_num_shards 配置为 5，则将产生 5 个 API 队列分片：\ncentrifugo.api.0 centrifugo.api.1 centrifugo.api.2 centrifugo.api.3 centrifugo.api.4  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;当使用此参数时，在客户端侧，你必须指定要将消息发布到哪个 API 队列。为了保证频道中消息的顺序，需要注意在客户端中要将消息按顺序推送到同一 API 队列的同一频道中。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;要想使 Centrifugo 支持通过 Redis engine API listener 发布消息，可以在启动时使用 --redis_api 参数：\n centrifugo --config=config.json --engin=redis --redis_api  如此启动后，可以直接通过 Redis 客户端来发布消息，示例代码（Python）:\nimport redis import json client = redis.Redis() command = { \u0026quot;method\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;events\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;enent\u0026quot;: \u0026quot;message\u0026quot;} } } client.rpush(\u0026quot;centrifugo.api\u0026quot;, json.dumps(command))  RPUSH 命令允许在一个请求中将多条消息推入队列。\n注意：我们通过 RPUSH 将消息推送到了 centrifugo.api，这是 API 队列的默认名称，Centrifugo 实时对其监控。事实上，在 Redis 中，这是一个列表结构。此处，你推送过来的指令会被 Centrifugo 及时处理，但是并不会给客户端响应。如果需要获取响应，那只能使用 HTTP API。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;publish 是最常用的 Centrifugo 指令，Redis_API 的主要目的是降低高频率发布时的 HTTP 开销。同时，也方便各种类型的语言使用 Centrifugo，而不需要依赖 HTTP API client。\n","id":10,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 引擎负责如何发布消息、处理订阅、状态及历史数据的保存及恢复等。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 可选的引擎为 Memory 和 Redis，默认使用 Memory。两者最大的不同在于，Me","tags":["技术","Centrifugo"],"title":"Centrifugo（六）引擎（Engines）","uri":"https://rjguanwen.cn/2019/12/centrifugo_06/","year":"2019"},{"content":" 1、创建本地仓库  cd 到相应文件夹\n 仓库初始化：\ngit init  将文件添加到仓库：\ngit add .  提交文件到仓库：\ngit commit -m \u0026quot;xxxxxxx\u0026quot;  2、关联 github 仓库 添加远程仓库：\ngit remote add origin https://github.com/rjguanwen/xxxx.git  合并本地内容与远程内容：\ngit pull --rebase origin master  3、上传本地内容 git push -u origin master   ","id":11,"section":"posts","summary":"1、创建本地仓库 cd 到相应文件夹 仓库初始化： git init 将文件添加到仓库： git add . 提交文件到仓库： git commit -m \u0026quot;xxxxxxx\u0026quot; 2、关联 github 仓库 添加远程仓库： git remote add origin https://github.com/rjguanwen/xxxx.git 合并本地","tags":["技术","GIT"],"title":"上传本地文件到git","uri":"https://rjguanwen.cn/2019/12/git_02/","year":"2019"},{"content":" 一、下载安装程序 \u0026ensp;\u0026ensp;Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方便的编译为各个平台的执行程序。Centrifugo 安装首先根据操作系统获取最新版本的安装程序（lastest release）。\n二、生成配置文件 \u0026ensp;\u0026ensp;Centrifugo 运行需要依赖配置文件，最小化的配置文件可以通过命令自动生成：\n./centrifugo genconfig  以上命令，会在当前目录生成一个 config.json 文件，其中包含自动生成的 secret key，你可以根据自己的喜好对其进行修改。\n三、运行 Centerfugo ./centrifugo --config=config.json  四、检查配置文件 ./centrifugo checkconfig --config=config.json  当配置文件出现问题时，可以使用该命令检查。\n五、Linux 安装包及 Docker 镜像 \u0026ensp;\u0026ensp;参考 RPM and DEB packages 及 Docker image\n","id":12,"section":"posts","summary":"一、下载安装程序 \u0026ensp;\u0026ensp;Centrifugo 使用 Go 语言开发，GO 语言可以将应用程序编译为单一的二进制执行文件，并且具备交叉编译的能力。因此，Centrifugo 可以方","tags":["技术","Centrifugo"],"title":"Centrifugo（三）安装与启动","uri":"https://rjguanwen.cn/2019/12/centrifugo_03/","year":"2019"},{"content":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。\n基本运行框架：\nCentrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifugo。当然，也可以只有客户端和 Centrifugo。基本使用流程如下：\n 下载并安装\n下载并安装Centrifugo，推荐使用 docker 方式。安装教程\n 配置运行\n创建基础配置文件，设置 token_hmac_secret_key(or token_rsa_public_key) 和 api_key，然后运行Centrifugo。配置文件（config.json）可以通过命令自动创建：\n./centrifugo genconfig  关键配置项\n在后端应用程序配置文件中设置三个变量：Centrifugo secret、Centrifugo API Key 以及 Centrifugo API address。Centrifugo API address 默认为 http://localhost:8000/api。Centrifugo secret 和 Centrifugo API Key 是关键信息，不能泄露到客户端。\n 连接到 Centrifugo\n根据客户端语言下载相应的客户端库（支持的客户端库列表）。客户端库中有连接到 Centrifugo 的方法。在连接时，客户端需要提供令牌（Token JWT）。令牌的生成应该在应用程序后端进行，然后提供给客户端，可以考虑在页面模板上下文中传递令牌给客户端或者提供令牌获取服务供已登录的客户端调用。令牌的生成需要依赖 Centrifugo secret。 客户端库一般都有 setToken 方法供使用。注意：对于 RSA 令牌，需要使用私钥生成 JWT。（JWT生成方法）\nCentrifugo v2.3.0 之后，可以不使用 JWT 进行连接认证，参见 proxying to backend\n 频道订阅\n客户端连接到 Centrifugo 后，即可根据需要订阅相关的频道（Channel）。所有的客户端库都提供了处理所订阅频道（Channel）消息的方法。\n 消息推送\n以上完成后，当用户打开应用程序的相关页面时，客户端会成功连接到 Centrifugo 并订阅一个或多个频道。如果你想向订阅特定频道的用户发送实时消息，例如：有人发布了新评论、部分商品打折促销、某个业务按钮被按下等，可以通过 Centrifugo HTTP API 来完成，官方针对不同的编程语言提供了一些 API 库（API libraries），使用这些库可以方便的发布消息到指定的频道（Channel）。当然，你也可以根据API 描述编写自己的 API 库。Centrifugo 也支持 GRPC API。发布到频道的消息会被投递到订阅相应频道的客户端。\n 生产环境安装包\n为了方便在生产环境中安装 Centrifugo，官方提供了 Docker 镜像、rpm 包以及 deb 包。\n 监控\n不用忘记对 Centrifugo 设置进行监控。参考资料\n 详细参考资料地址。\n  ","id":13,"section":"posts","summary":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。 基本运行框架： Centrifugo 的使用场景一般涉及三个部分：客户端（前端）、应用程序（后端）和 Centrifu","tags":["技术","Centrifugo"],"title":"Centrifugo（二）基本使用","uri":"https://rjguanwen.cn/2019/12/centrifugo_02/","year":"2019"},{"content":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到本频道的消息、用户订阅/取消订阅的消息等等。同样，客户端也需要订阅频道来获取频道的状态（presence）和历史消息。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道的生命周期比较短暂，不需要显式的去声明。当第一个客户端进行订阅时，Centrifugo 会自动创建相应频道。当最后一个客户端取消订阅时，频道会立即自动被销毁。\n 频道的命名规则\n  \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道以字符串为标识，由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$），默认最大长度为255，如需修改可以通过配置文件中的 channel_max_length 参数进行调整。\n以下几个符号是 Centrifugo 的内部保留符号：\n : - 命名空间分隔符\n $ - 私有频道前缀\n # - 用户频道分隔符\n * - 保留字符\n \u0026amp; - 保留字符\n / - 保留字符\n  命名空间分隔符（:）：如果频道名称为 public:chat，该频道的配置信息将使用 public 命名空间的配置参数设置。\n私有频道前缀（$）：如果频道名称以 $ 开头，则意味着该频道为私有频道。订阅私有频道必须通过应用程序后端签名。\n用户频道分隔符（#）：该字符用于创建用户专属频道，而无需向后端Web应用程序发送POST请求。例如，频道名 news#42，表示只有 ID 为 42 的用户可以订阅该频道。客户端在连接 Centrifugo 时需要提供 Token，其中包含了 user ID，因此 Centrifugo 清楚每个客户端的 user ID。另外，用户频道可以支持多个 user ID，user ID 之间通过逗号分隔，例如 dialog#42,43。此种类型的频道适用于固定用户，例如用户个人消息通道、确定用户之间的对话通道，一旦需要动态用户访问频道，此频道类型就不合适了。\n","id":14,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;频道（Channel）是消息发布的通道。客户端通过订阅频道来接收与频道相关的事件，包括发布到","tags":["技术","Centrifugo"],"title":"Centrifugo（五）频道（Channel）","uri":"https://rjguanwen.cn/2019/12/centrifugo_05/","year":"2019"},{"content":" \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过 ./centrifugo -h 命令，可以查看所有的可用选型，如下：\n Centrifugo – real-time messaging server Usage: [flags] [command] Available Commands: checkconfig Check configuration file genconfig Generate simple configuration file to start with help Help about any command version Centrifugo version information Flags: -a, --address string interface address to listen on 服务的地址 --admin enable admin web interface 是否开启admin的管理界面 --admin_insecure use insecure admin mode – no auth required for admin socket admin安全验证, 节点: /, 可直接访问admin管理界面, 默认为false, 登录admin需要admin_password, 反之可直接登录 --api_insecure use insecure API mode 后台推送安全验证, 节点: /api. 默认为 false, 此时访问节点需要api_key. 当设置为 true 后, 任何人都将可以访问此节点 --client_insecure start in insecure client mode 客户端是否需要安全验证, 默认为false, 客户端必须拥有 JWT token 才能访问 -c, --config string path to config file (default \u0026quot;config.json\u0026quot;) --debug enable debug endpoints 是否开启dubug节点, 开启后可访问 /debug/pprof/ 查看一些Centrifugo的网络状态 -e, --engine string engine to use: memory or redis (default \u0026quot;memory\u0026quot;) 消息存储引擎, 默认为内存, 部署多个实例会造成数据不同步, 因此推荐使用 redis --grpc_api enable GRPC API server 是否开启grpc api, 默认使用 http_api -h, --help help for this command --internal_port string custom port for internal endpoints 开启自定义默认端口, 默认为8000, 开启额外的端口为admin访问 --log_file string optional log file - if not specified logs go to STDOUT log输出文件 --log_level string set the log level: debug, info, error, fatal or none (default \u0026quot;info\u0026quot;) log级别 -n, --name string unique node name 命名空间名称, 此空间下的属性会覆盖common部分, 但不会继承 --pid_file string optional path to create PID file -p, --port string port to bind HTTP server to (default \u0026quot;8000\u0026quot;) 服务端口号 --prometheus enable Prometheus metrics endpoint --redis_db int Redis database (Redis engine) --redis_host string Redis host (Redis engine) (default \u0026quot;127.0.0.1\u0026quot;) --redis_master_name string name of Redis master Sentinel monitors (Redis engine) --redis_password string Redis auth password (Redis engine) --redis_port string Redis port (Redis engine) (default \u0026quot;6379\u0026quot;) --redis_sentinels string comma-separated list of Sentinel addresses (Redis engine) --redis_tls enable Redis TLS connection --redis_tls_skip_verify disable Redis TLS host verification --redis_url string Redis connection URL in format redis://:password@hostname:port/db (Redis engine) --tls enable TLS, requires an X509 certificate and a key file --tls_cert string path to an X509 certificate file --tls_key string path to an X509 certificate key  注意：所有的命令行选项都可以用同样的名字在配置文件中进行设置。此外，所有的可用选项也都可以设置到环境变量中，格式为 CENTRIFUGO_\u0026lt;OPTION_NAME\u0026gt;。\nversion centrifugo version  JSON file Centrifugo 启动时依赖配置文件。最简单的配置文件如下：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; }  必须的两个选项为 token_hmac_secret_key 和 api_key。token_hmac_secret_key 用来检查 JWT 签名。api_key 用于 Centrifugo API 端点授权。在生产环境你应该将这两个参数设置的足够复杂并且避免外泄。唯二的需要知道这两个参数值的只有 Centrifugo 自身和你的应用程序后端。该值被用来生成客户端连接令牌、调用 API 以及订阅私有频道。\nTOML file Centrifugo 同样支持 TOML 格式的配置文件：\ncentrifugo --config=config.toml  config.toml 示例：\ntoken_hmac_secret_key = \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot; api_key = \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; log_level = \u0026quot;debug\u0026quot;  YAML file Centrifugo 同样支持 TOML 格式的配置文件，config.yaml：\ntoken_hmac_secret_key: \u0026quot;\u0026lt;YOUR-SECRET-STRING-HERE\u0026gt;\u0026quot; api_key: \u0026quot;\u0026lt;YOUR-API-KEY-HERE\u0026gt;\u0026quot; log_level: debug  checkconfig command Centrifugo 有专门的命令用来检查配置文件：\ncentrifugo checkconfig --config=config.json  genconfig command centrifugo genconfig -c config.json  该命令会生成最小化的配置文件。\nImportant options 运行 Centrifugo 时可以配置一些最重要的选项：\n- address - 将 Centrifugo 绑定到特定的接口地址（默认为 \u0026quot;\u0026quot;）\n- port - Centrifugo 的绑定端口（默认为 8000）\n- engine - Centrifugo 使用的引擎：memory 或者 redis（默认为 memory） 注意：命令行参数优先级要大于配置文件选项。\nChannel options 频道（channel）是一个实体，客户端可以订阅发布到相应频道的消息。下面几个选项可以控制频道的一些行为：\n publish：允许客户端直接发布消息到频道，而不经过应用程序后端。一般情况下，消息都是由应用程序后端通过 Centrifugo API 发布到 Centrifugo 服务器的。这个参数适用于没有后端或者 demo 的快速构建。需要注意的一点是客户端只有成功订阅了频道之后才能发布消息到该频道。本参数默认值为 false。\n subscribe_to_publish：当 publish 选项启用后，客户端可以发布消息到频道中而无需订阅。使用此选项，客户端会在发布到频道之前自动检查是否已订阅该频道。\n anonymous：该参数允许匿名访问（在连接参数中使用空字符串作为 user ID，JWT token 中 sub 为空）。通常情况下，应用程序的用户都需要登录认证，因此客户端建立连接时可以使用用户名作为唯一标识。如果你需要提供公共的实时消息服务，你可以在相应的频道上开启本参数。本参数默认值为 false。\n presence：是否开启 presence 信息，presence 为当前订阅本频道的客户端信息。本参数默认是为 false，即不开启。\n presence_disable_for_client：（v2.2.3 之后版本有效）presence 在客户端不可用。默认值为 false，即同时允许客户端和服务端 API 访问 presence 信息。\n join_leave：当有用户订阅/取消订阅频道时，是否发送相关信息到频道中。本参数默认值为 false。\n history_size：频道历史消息数量。因为 Centrifugo 将所有的消息存储在内存中，因此限制每个频道保留的历史消息数量是非常重要的。本参数默认值为 0，这意味着频道不会保留历史消息。启用本参数后，Centrifugo 会为命名空间中的每条频道保留指定数量的历史消息，直到消息过期，关于消息过期详见参数 history_lifetime。\n history_lifetime：频道历史消息的过期时间，单位为秒。本参数默认值为 0，这意味着频道不会保留历史消息。如果要保留历史消息，需要同时配置 history_size 与 history_lifetime，并设置合理的参数值。\n history_recover：是否恢复丢失的消息。如果开启本参数，当客户端重新连接时（如因网络原因断线重连），Centrifugo 将试图重新恢复丢失的消息。本参数默认值为 false。这个参数的启用要配合历史消息相关参数（history_size 和 histroy_lifetime），毕竟消息的恢复依靠的是频道历史消息记录。请注意，并非所有实时事件消息都需要开启此功能，因此在需要时请慎重考虑。启用此选项后，你的应用程序需要考虑消息去重。\n history_disable_for_client：（v2.2.3 之后版本有效）历史消息在客户端不可用。默认为 false，即历史消息在客户端与服务端均可用。该参数是否启用不会影响历史消息恢复机制。\n  参数配置示例：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;my-secret-key\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;secret-api-key\u0026quot;, \u0026quot;anonymous\u0026quot;: true, \u0026quot;publish\u0026quot;: true, \u0026quot;subscribe_to_publish\u0026quot;: true, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 300, \u0026quot;history_recover\u0026quot;: true }   namespaces：namespaces 是可选参数，如果设置的话，需要设置成 namespace 数组的形式。通过 namespaces 可以针对 namespace 下的频道配置自定义参数。每个 namespace 都有自己的 name，并且拥有上面所有的针对频道的参数。name 必须唯一，并且由字母、数字、下划线或连接符组成，长度必须大于2（^[-azA-Z0-9_]{2,}$）。\n  namespaces 相关配置文件示例：\n{ \u0026quot;token_hmac_secret_key\u0026quot;: \u0026quot;very-long-secret-key\u0026quot;, \u0026quot;api_key\u0026quot;: \u0026quot;secret-api-key\u0026quot;, \u0026quot;anonymous\u0026quot;: true, \u0026quot;publish\u0026quot;: true, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 30, \u0026quot;namespaces\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;public\u0026quot;, \u0026quot;publish\u0026quot;: true, \u0026quot;anonymous\u0026quot;: true, \u0026quot;history_size\u0026quot;: 10, \u0026quot;history_lifetime\u0026quot;: 300, \u0026quot;history_recover\u0026quot;: true }, { \u0026quot;name\u0026quot;: \u0026quot;gossips\u0026quot;, \u0026quot;presence\u0026quot;: true, \u0026quot;join_leave\u0026quot;: true } ]  }\n在以上配置下：\n\u0026ensp;\u0026ensp;- 频道 news 将使用全局参数配置。\n\u0026ensp;\u0026ensp;- 频道 public:news 将使用 public 命名空间的参数配置。\n\u0026ensp;\u0026ensp;- 频道 gossips:news 将使用 gossips 命名空间的参数配置。\n注意：频道（channel）相关的选项在命名空间（namespaces）中不存在继承关系。例如，你在配置文件的顶层配置了 presence: true，在命名空间中，频道的 presence 选项不会继承 true，你必须在命名空间中显式的启用。\nAdvanced configuration Centrifugo 还提供了更多的配置选项，一般情况下，你不需要配置他们，使用默认值即可。\n client_channel_limit\nDefault: 128\n设置单个客户端可以拥有的不同频道订阅的最大数量。\n channel_max_length\nDefault: 255 设置频道名称的最大长度。\n client_user_connection_limit\nDefault: 0\n同一用户（不包含匿名用户）连接到 Centrifugo 节点的最大连接数。默认值 0 表示不限制。\n client_request_max_size\nDefault: 65536\n客户端请求的最大允许长度，按字节计。\n client_queue_max_size\nDefault: 10485760\n客户端消息队列的最大大小，以字节计。默认大小为 10mb。（超出长度后缓慢的读取连接会被关闭？）\n client_anonymous\nDefault: false\n是否允许客户端匿名连接。如果设置为 true，则所有客户端可以在没有 JWT 令牌的情况下连接到 Centrifugo。在这种情况下，没有令牌的连接会被视为匿名（user ID 为空），并且只能订阅开启了 anonymous 选项的频道。\n sockjs_heartbeat_delay\nDefault: 25\nSockJS 心跳检测时间间隔，单位为秒。\n websocket_compression\nDefault: fasle 是否开启 websocket 压缩。\n gomaxprocs\nDefault: 0\n默认情况下，Centrifugo 会在所有可用 CPU 内核上执行，本选项可以用来限制 Centrifugo 同时可利用的 CPU 内核数。\n  Advanced endpoint configuration 启动 Centrifugo 后，你会有几个可用的端点（endpoint），如果你没有提供额外的选项，你默认会有 3 个端点。\n Default endpoints\n  主端点是原生的 Websocket 端口，用来支持纯 Websocket 协议的客户端连接：ws://localhost:8000/connection/websocket\nSockJS 端点，用来服务使用 SockJS library 连接的客户端：http://localhost:8000/connection/sockjs\n最后，API 端点，用来发布消息到频道以及执行其他可用的 API 指令：http://localhost:8000/api\n所有的端点默认使用 8000 端口，可以通过 port 选项修改：\n{ \u0026quot;port\u0026quot;: 9000 }  在生产环境中，你的域名将替代上面 URL 中的 localhost。如果你的 Centrifugo 服务器位于代理或者负载均衡服务器之后，则 URL 中可能没有端口号。\n Admin endpoints 启用管理端点：\n{ ... \u0026quot;admin\u0026quot;: true, \u0026quot;admin_password\u0026quot;: \u0026quot;\u0026lt;password\u0026gt;\u0026quot;, \u0026quot;admin_secret\u0026quot;: \u0026quot;\u0026lt;secret\u0026gt;\u0026quot; }  以上配置，使管理端点可用：http://localhost:8000\n通过上面的地址，你可以看到管理界面，通过上面配置的 admin_password 登录。\n Debug endpoints 当 Centrifugo 以 debug 模式启动时，debug 端点将可用。\n{ ... \u0026quot;debug\u0026quot;: true }  端点 URL: http://localhost:8000/debug/pprof/\n通过上面的地址，你可以看到 Centrifugo 实例的内部状态信息，这些信息在故障排除时会非常有用。\n Healthcheck endpoint 使用 health 选项（默认值为 false）来启用健康检查端点，该端点路径为 /health。同样，也可以在启动命令通过标记来启用健康检查端点：\n./centrifugo -c config.json --health  Custom internal ports 我们强烈建议，不要将 API、admin、debug 以及 prometheus 端点暴露到互联网，这些端点被视为内部的：\n API 端点（/api）: 针对 HTTP API 请求\n Admin web interface endpoints（/, /admin/auth, /admin/api）: used by web interface\n Prometheus endpoint(/metrics): 用于以 Prometheus 格式公开服务器指标\n Healthcheck endpoint(/health): 用来进行健康检查\n Debug endpoints(/debug/pprof): 用于检测服务器内部状态\n   这些内部端点，最好使用防火墙保护起来。\n可以通过 internal_port 选项来自定义内部端点的端口：\n{ ... \u0026quot;internal_port\u0026quot;: 9000 }   Disable default endpoints 以下选项在 v2.4.0 版本后有效：websocket_disable、sockjs_disable、api_disable，这些选项默认值均为 true。\n Customize handler endpoinds\n从 Centrifugo v2.2.5 开始，可以自定义 HTTP 处理程序端点，有如下几个选项可用：\n admin_handler_prefix（默认值为 \u0026quot;\u0026quot;）: 控制台 URL 前缀。\n websocket_handler_prefix（默认值为 /connection/websocket）: WebSocket URL前缀。\n sockjs_handler_prefix（默认值为 /connection/sockjs）: SockJS URL 前缀。\n api_handler_prefix（默认值为 /api）: HTTP API URL 前缀。\n prometheus_handler_prefix（默认值为 /metrics）: Prometheus URL 前缀。\n health_handler_prefix（默认值为 /health）: 健康检查 URL 前缀。\n   \n// \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nother options 下面几个参数在新版本中是否仍可使用，未验证\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;connection_lifetime 参数用来设置客户端连接的过期时间，单位为秒。如果该参数设置为0，表示该客户端连接永不过期。\n{ \u0026quot;secret\u0026quot;: \u0026quot;very-long-secret-key\u0026quot;, \u0026quot;connect_lifetime\u0026quot;: 0 }  \n频道（Channel）相关的选项：\nwatch：Centrifugo 会同时发生消息到 admin channel，这些消息可以在 admin 管理界面的 messages tab 下查看。这个参数要慎用，特别是针对消息发布频率比较高的频道，以免超出 admin client 的处理能力。本参数默认值为 fasle。\nhistory_drop_inactive：是否丢弃不活跃的历史消息。本参数可以大幅降低资源消耗（内存、消息传播次数）。简单来说，该参数开启后，Centrifugo 会主动丢弃不需要的历史消息。本参数默认值为 false。\n\n","id":15,"section":"posts","summary":"\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;Centrifugo 支持 JSON、TOML和YAML三种格式的配置文件。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过 ./centrifugo -h 命令，可以查看所有的可用选型，","tags":["技术","Centrifugo"],"title":"Centrifugo（四）配置文件说明","uri":"https://rjguanwen.cn/2019/12/centrifugo_04/","year":"2019"},{"content":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。\n 提供基于频道的发布/订阅（PUB/SUB）模式。\n 容易和现有系统集成– 不改变已有后端情况下为系统提供实时通信能力。\n HTTP API 和已有后端通信 . API clients for Python, Ruby, PHP, Go, NodeJS。\n 浏览器可以通过SockJS或者纯粹Websocket协议和centrifugal通信。 提供 iOS和Android平台SDK。\n 采用Redis实现分布式部署，也支持使用Memory引擎单机简单部署。\n SHA-256 HMAC连接认证和隐私保护。\n 多种类型的频道 – 私有, 用户限制，客户端限制。\n 通过名字空间灵活配置频道。\n 支持即时消息和历史消息。\n 支持用户加入/离开消息。\n 网络重连后可以恢复消息。\n 内置管理界面，提供多种计量(Metrics)。\n 可用于WebRTC信令服务器。\n 多种部署手段(docker 镜像, RPM/DEB 包, Nginx 配置, TLS certificates)。\n MIT license。\n  基本运行框架：\n​ Centrifugo 作为独立服务器运行，可以处理来自应用程序用户的持久连接。应用的前端和后端可以基于任何语言进行开发。你的客户端使用应用程序后端提供的令牌(Token JWT)连接到 Centrifugo，并订阅频道（Channel）。当有事件发生时，后端应用可以使用 Centrifugo 的 API 发布消息到相关 Channel。随后，消息会被投递到所有订阅本 Channel 的客户端。\n项目地址：https://github.com/centrifugal/centrifugo\n","id":16,"section":"posts","summary":"Centrifugo 是一个用 Golang 实现的基于 Websocket 或者 SockJS 的实时通信平台。 提供基于频道的发布/订阅（PUB/SUB）模式。 容易和现有系统集成– 不改变已有后端情况下为系统","tags":["技术","Centrifugo"],"title":"Centrifugo（一）简介","uri":"https://rjguanwen.cn/2019/12/centrifugo_01/","year":"2019"},{"content":"摘抄并总结几条个人认为对提升自我帮助较大的好习惯，希望能坚持！\n\u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\n 心情糟糕时认真清理房间，心情莫名就开始清爽起来。\n 晨起刷牙时问问自己，如果要过好这一天，有什么可改良创造之处。\n 出差、旅行，记得带上一双跑鞋，一身运动服，去陌生城市的清晨跑个步，或许收获新的灵感。\n 睡前半小时远离手机和任何电子设备。\n 戒糖，戒所有含糖饮料，将可口可乐改为零度可乐等无糖甜味饮料。\n 当出现负面情绪和自我否定时，想办法转移自己的负面情绪，听增强自信的音乐，或者看励志书籍/电源。\n 误解或伤害过他人，一定要专门去道歉和解释。\n 每天问问自己，最重要的人，最重要的事情，最重要的目标，到底是什么；对那些不重要的人、事、物，尽可能少分配精力。\n 给人第二次机会，但不要给第三次。圣经上说过：凡第二次犯错者，必有第三次。 受人恩惠后除了说声谢谢，再赠送一件小礼品，可以结识到更亲密的关系。\n 建立自己的日常事项，比如日常写日记，日常有氧健身半小时，用恒定不变的习惯，抵抗人生的无常。会建立自信，缓解焦虑。\n 坚持阅读，家里准备着可以读的书，保证每天有一定的阅读时间，和利用碎片化时间阅读。\n 坚持记账，让你对自己的收入和消费情况充分了解，更有利于帮助你纠正不良消费习惯，管理好自己的财物状况。\n 吃饭不要吃太饱，八分饱更健康。\n 早睡早起，感觉精力充沛的时间更多。\n 洗手间内、公司走廊上不要和别人过多交流。\n 对方正在说话的时候不要插嘴。\n 正式去别人家里一定不要空手去！无论你们关系有多好！\n 使用积极语言： 当你以积极的语言开始陈述，对方也会摆出积极的姿态倾听你的话语。如果你没有自信，不妨抛开带有感情色彩的开场白，平缓地开始叙述。如果因为多余的客气话和谦虚反而让对方认为你没有能力，那就得不偿失了。\n 遇事少抱怨！万事健康第一！\n 宁可鱼死网破，也绝不降低原则与底限。\n 坚持反省： 每天晚上进行一次对自己今天所做事情的冥想，不管做的好还是不好，都去总结分析其缘由。 坚持运动： 无论你多么优秀、多么地与众不同，你都有责任为自己的身体负责。\n 不要说脏话，戒掉口头禅！\n  ","id":17,"section":"posts","summary":"摘抄并总结几条个人认为对提升自我帮助较大的好习惯，希望能坚持！ \u0026lt;部分内容摘抄自网络，如有侵权，预先道歉，请及时联系（rjguanwen","tags":["个人"],"title":"坚持好习惯","uri":"https://rjguanwen.cn/2019/11/good_habits/","year":"2019"},{"content":"数据传输加密流程：\n","id":18,"section":"posts","summary":"数据传输加密流程：","tags":["技术"],"title":"数据加解传输过程","uri":"https://rjguanwen.cn/2019/11/data_translet_safely/","year":"2019"},{"content":"简单记录 go mod 的使用方式：\n 代理配置\n$env:GOPROXY = \u0026quot;https://goproxy.io\u0026quot; 或使用 goproxy.cn\n 初始化\ngo mod init ***，***为你要创建的mod名字，直接为工程名即可\n 自动下载依赖\ngo run *****.go，在执行前会首先查找并下载安装依赖\n 更新旧的 package import 方式，内部依赖也需要增加 mod 名\npackage main import ( api \u0026quot;mymod/api\u0026quot; // mymod 是初始化的 mod 名 \u0026quot;github.com/labstack/echo\u0026quot; ) func main() { e := echo.New() e.GET(\u0026quot;/\u0026quot;, api.MyAPI) e.Logger.Fatal(e.Start(\u0026quot;:1234\u0026quot;)) }  使用 replace 替换无法直接获取的 package\nreplace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u0026gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a )  检查并升级 package\ngo list -m -u all\ngo get -u need-upgrade-package 或者 go get -u\n  常用的命令如下：\n   命令 功能     download 下载依赖包   edit 编辑 go.mod   graph 打印模块依赖图   init 初始化 mod   tidy 拉取缺少的模块，移除不用的模块   vendor 将依赖复制到 vendor 下   verify 验证依赖是否正确   why 解释为什么需要依赖    ","id":19,"section":"posts","summary":"简单记录 go mod 的使用方式： 代理配置 $env:GOPROXY = \u0026quot;https://goproxy.io\u0026quot; 或使用 goproxy.cn 初始化 go mod init ***，***为你要创建的mod名字，直接为工程名即可 自动下载依赖 go run *****.","tags":["技术","GOLANG"],"title":"gomod使用记录","uri":"https://rjguanwen.cn/2019/11/gomod_use/","year":"2019"},{"content":"简单记录 govendor 的使用方式：\n 安装\ngo get -u -v github.com/kardianos/govendor\n 初始化 vendor 目录\ngovendor init\n 添加依赖包到 vendor 目录\ngovendor add +external 或 govendor add +e\n 从 $GOPATH 更新依赖包到 vendor 目录\ngovendor update +vendor\n 删除依赖包\ngovendor remove +vendor\n  常用的命令如下：\n   命令 功能     init 初始化 vendor 目录   list 列出所有依赖包   add 添加包到 vendor 目录   add PKG_PATH 添加指定依赖包到 vendor 目录   update 从 $GOPATH 更新依赖包到 vendor 目录   remove 从 vendor 管理中删除依赖   status 列出 vendor 管理的各个包的状态   fetch 添加或更新包到 vendor 目录   sync 同步，基于已存在的 vendor.json 拉取依赖包   get 类似 go get ，拉取依赖包到 vendor 目录    可用的 Status Types 如下：\n+local (l) packages in your project\n+external (e) referenced packages in GOPATH but not in current project\n+vendor (v) packages in the vendor folder\n+std (s) packages in the standard library\n+excluded (x) external packages explicitly excluded from vendoring\n+unused (u) packages in the vendor folder, but unused\n+missing (m) referenced packages but not found\n+program (p) package is a main package\n+outside +external +missing\n+all +all packages\n注意事项：\n使用 vendor 后，请配置 .gitignore 文件：\n/vendor/* !/vendor/vendor.json  ","id":20,"section":"posts","summary":"简单记录 govendor 的使用方式： 安装 go get -u -v github.com/kardianos/govendor 初始化 vendor 目录 govendor init 添加依赖包到 vendor 目录 govendor add +external 或 govendor add +e 从 $GOPATH 更新依赖包到 vendor 目录 govendor update +vendor 删除依赖包 govendor remove +vendor 常用的命令如","tags":["技术","GOLANG"],"title":"govendor使用记录","uri":"https://rjguanwen.cn/2019/11/govendor_use/","year":"2019"},{"content":" pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull，此时在较新的git版本上会报错。因为git认为两个仓库可能不是同一个，报错是为了防止开发者上传错误。\n解决办法： 在 pull 命令的最后增加--allow-unrelated-histories\n","id":21,"section":"posts","summary":"pull仓库时：refusing to merge unrelated histories 问题原因： 在远端已经建立好了仓库，在本地又 init 了一个仓库，然后使用 git remote add origin xxxxx 添加远端，之后进行pull","tags":["技术","GIT"],"title":"git错误解决","uri":"https://rjguanwen.cn/2019/11/git_01/","year":"2019"},{"content":" 技术的发展非常迅速，对新技术的探索与应用和  ","id":22,"section":"posts","summary":"技术的发展非常迅速，对新技术的探索与应用和","tags":["杂感随笔"],"title":"关于产品与技术的一些想法","uri":"https://rjguanwen.cn/2019/11/any_01/","year":"2019"},{"content":"1.读书不是为了雄辩与驳斥，也不是为了轻信与盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们是在重新整理自己的偏见。\n2.用一套程序保证问题会摆在桌面上，同时确保问题根源会得到剖析，这样才能实现持续的改进。\n3.\n","id":23,"section":"posts","summary":"1.读书不是为了雄辩与驳斥，也不是为了轻信与盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们是在重新整理自己的偏见。 2.用一套程","tags":["句子"],"title":"杂句摘抄","uri":"https://rjguanwen.cn/2019/11/somewords_01/","year":"2019"},{"content":"苦昼短\n【唐】李贺\n飞光飞光，劝尔一杯酒。\n吾不识青天高，黄地厚。\n唯见月寒日暖，来煎人寿。\n食熊则肥，食蛙则瘦。\n神君何在？太一安有？\n天东有若木，下置衔烛龙。\n吾将斩龙足，嚼龙肉，使之朝不得回，夜不得伏。\n自然老者不死，少者不哭。\n何为服黄金、吞白玉？\n谁似任公子，云中骑碧驴？\n刘彻茂陵多滞骨，嬴政梓棺费鲍鱼。\n","id":24,"section":"posts","summary":"苦昼短 【唐】李贺 飞光飞光，劝尔一杯酒。 吾不识青天高，黄地厚。 唯见月寒日暖，来煎人寿。 食熊则肥，食蛙则瘦。 神君何在？太一安有？ 天东有若木，下置","tags":["光阴","诗词"],"title":"苦昼短","uri":"https://rjguanwen.cn/2019/11/art-1/","year":"2019"},{"content":" \u0026lt;部分内容借鉴自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt;\nGo 文件操作总结 1、基本操作 1.1 创建文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { newFile, err := os.Create(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } newFile.Close() }  1.2 Truncate文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main(){ // 裁剪一个文件到100个字节。 // 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。 // 如果文件本来超过100个字节，则超过的字节会被抛弃。 // 这样我们总是得到精确的100个字节的文件。 // 传入0则会清空文件。 err := os.Truncate(\u0026quot;example_1.txt\u0026quot;, 100) if err != nil { log.Fatal(err) } }  1.3 获取文件信息 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main(){ fi, err := os.Stat(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;文件名：\u0026quot;,fi.Name()) fmt.Println(\u0026quot;文件大小：\u0026quot;, fi.Size()) fmt.Println(\u0026quot;权限：\u0026quot;, fi.Mode()) fmt.Println(\u0026quot;最后修改时间：\u0026quot;, fi.ModTime()) fmt.Println(\u0026quot;是否文件夹：\u0026quot;, fi.IsDir()) fmt.Println(\u0026quot;系统信息：\u0026quot;, fi.Sys()) }  1.4 重命名和移动 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 在 windows 下，通过 Rename 将文件跨卷移动，会报错 // 当文件 open 后，未 close 时，Rename 方法貌似不起作用， // 并且也不会报错，需要注意 oldPath := \u0026quot;example_1.txt\u0026quot; newPath := \u0026quot;example_4.txt\u0026quot; err := os.Rename(oldPath, newPath) if err != nil { log.Fatal(err) } }  1.5 删除文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { err := os.Remove(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } }  1.6 打开和关闭文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 以只读方式打开文件 file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } file.Close() // 第二个参数为打开文件时的属性，可以多个组合使用 // 第三个参数为权限模式 file, err = os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_APPEND, 0666) if err != nil { log.Fatal(err) } file.Close() // 以下为可组合使用的文件属性 //os.O_RDONLY\t// 只读 //os.O_WRONLY\t// 只写 //os.O_RDWR\t// 读写 //os.O_APPEND\t// 向文件中添加 //os.O_CREATE\t// 如果文件不存在则先创建 //os.O_TRUNC\t// 文件打开时裁剪文件 //os.O_EXCL\t// //os.O_SYNC\t// 以同步I/O方式打开 }  1.7 检查文件是否存在 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) func main() { _, err := os.Stat(\u0026quot;example_2.txt\u0026quot;) fileExist := err == nil || os.IsExist(err) fmt.Println(fileExist) }  1.8 检查读写权限 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 测试写权限，如果文件是只读或者其他原因导致不具备写入权限，则返回 error file, err := os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_WRONLY, 0666) if err != nil { if os.IsPermission(err) { log.Println(\u0026quot;错误：无写入权限！\u0026quot;) } } file.Close() // 测试读权限 file, err = os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_RDONLY, 0666) if err != nil { if os.IsPermission(err) { log.Println(\u0026quot;错误：无读取权限！\u0026quot;) } } file.Close() }  1.9 改变权限、拥有者、时间戳 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;time\u0026quot; ) func main() { // 使用 Linux 风格改变文件权限 err := os.Chmod(\u0026quot;example_1.txt\u0026quot;, 0777) if err != nil { log.Println(err) } // 改变文件所有者 (not supported by windows) err = os.Chown(\u0026quot;example_1.txt\u0026quot;, os.Getuid(), os.Getgid()) if err != nil { log.Println(err) } // 改变时间戳 oneDaysFromNow := time.Now().Add(24 * time.Hour) lastAccessTime := oneDaysFromNow lastModifyTime := oneDaysFromNow err = os.Chtimes(\u0026quot;example_1.txt\u0026quot;, lastAccessTime, lastModifyTime) if err != nil { log.Println(err) } }  1.10 硬链接与软链接 一个普通的文件是一个指向硬盘的inode的地方。\n硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。\nsymbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。\npackage main import ( \u0026quot;os\u0026quot; \u0026quot;log\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { // 创建一个硬链接。 // 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。 // 删除和重命名不会影响另一个。 err := os.Link(\u0026quot;original.txt\u0026quot;, \u0026quot;original_also.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;creating sym\u0026quot;) // Create a symlink err = os.Symlink(\u0026quot;original.txt\u0026quot;, \u0026quot;original_sym.txt\u0026quot;) if err != nil { log.Fatal(err) } // Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。 // Symlink在Windows中不工作。 fileInfo, err := os.Lstat(\u0026quot;original_sym.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;Link info: %+v\u0026quot;, fileInfo) //改变软链接的拥有者不会影响原始文件。 err = os.Lchown(\u0026quot;original_sym.txt\u0026quot;, os.Getuid(), os.Getgid()) if err != nil { log.Fatal(err) } }  2、读写文件 2.1 复制文件 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { //打开文件 oFile, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer oFile.Close() // 创建新文件 nFile, err := os.Create(\u0026quot;example_copy.txt\u0026quot;) if err != nil { log.Fatalln(err) } defer nFile.Close() // 从源文件复制字节到目标文件 bytesWritten, err := io.Copy(nFile, oFile) if err != nil { log.Fatalln(err) } log.Printf(\u0026quot;已复制 %d 字节。\u0026quot;, bytesWritten) err = nFile.Sync() if err != nil { log.Fatal(err) } }  2.2 跳转到文件指定位置（Seek） package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, _ := os.Open(\u0026quot;example_1.txt\u0026quot;) defer file.Close() // 偏离位置，可以是正数也可以是负数 var offset int64 = 5 // offset 的初始位置，即相对那个位置进行偏移 // 0 ：文件开始位置 os.SEEK_SET // 1 ：当前位置 os.SEEK_CUR // 2 ：文件结尾位置 os.SEEK_END var whence int = 0 newPosition, err := file.Seek(offset, whence) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;向前移动 5：\u0026quot;, newPosition) // 从当前位置回退 3 个字节 newPosition, err = file.Seek(-3, os.SEEK_CUR) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;向后移动 2：\u0026quot;, newPosition) // 获取当前位置 currentPosition, err := file.Seek(0, 1) fmt.Println(\u0026quot;当前位置：\u0026quot;, currentPosition) // 转到文件开始处 newPosition, err = file.Seek(0, 0) if err != nil { log.Fatal(err) } //fmt.Println(newPosition) }  2.3 写文件 package main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 以可写方式打开文件 file, err := os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_WRONLY | os.O_TRUNC | os.O_CREATE, 0666, ) if err != nil { log.Fatal(err) } defer file.Close() byteSlice := []byte(\u0026quot;Hello!\\n\u0026quot;) bytesWriteen, err := file.Write(byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;写入 %d 个字节. \\n\u0026quot;, bytesWriteen) }  2.4 快写文件 ioutil 包有一个方法 WriteFile() 可以处理创建/打开文件、写字节切片和关闭文件一些列的操作。如果你需要简洁快速地写字节切片到文件中，可以使用它。\npackage main import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; ) func main() { err := ioutil.WriteFile(\u0026quot;example_1.txt\u0026quot;, []byte(\u0026quot;Hi, world!\\n\u0026quot;), 0666) if err != nil { log.Fatal(err) } }  2.5 使用缓存写 bufio 包提供了带缓存功能的writer，你可以在写字节到硬盘前使用内存缓存。当你处理很多数据时会很有用，因为它可以节省操作硬盘 I/O 的时间，大大提升性能并减少硬盘磨损。\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.OpenFile(\u0026quot;example_1.txt\u0026quot;, os.O_WRONLY, 0666) if err != nil { log.Fatal(err) } defer file.Close() // 创建 buffered writer bufferedWriter := bufio.NewWriter(file) // 写字节到 buffer bytesWritten, err := bufferedWriter.Write([]byte{65, 66, 67},) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;写入字节数：%d \\n\u0026quot;, bytesWritten) // 写字符串到 buffer bytesWritten, err = bufferedWriter.WriteString(\u0026quot;Hello, buffer!\\n\u0026quot;) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;写入字节数：%d \\n\u0026quot;, bytesWritten) // 检查缓存中的字节数 unflushedBufferSize := bufferedWriter.Buffered() log.Printf(\u0026quot;缓存的字节数：%d \\n\u0026quot;, unflushedBufferSize) // 还有多少字节可用（未使用的缓存大小） bytesAvailable := bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存1：%d \\n\u0026quot;, bytesAvailable) // 写缓存到硬盘 bufferedWriter.Flush() bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存2：%d \\n\u0026quot;, bytesAvailable) // 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer // 当你想将缓存传给另外一个writer时有用 bufferedWriter.Reset(bufferedWriter) bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存3：%d \\n\u0026quot;, bytesAvailable) // 重新设置缓存的大小 // 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。 // 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存， // 而是writer的原始大小的缓存，默认是4096。 // 它的功能主要还是为了扩容。 bufferedWriter = bufio.NewWriterSize( bufferedWriter, 8000, ) // resize 后检查缓存大小 bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存4：%d \\n\u0026quot;, bytesAvailable) // 设置 resize 值小于当前缓存大小，此时是不起作用的 bufferedWriter = bufio.NewWriterSize( bufferedWriter, 800, ) bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026quot;可用缓存5：%d \\n\u0026quot;, bytesAvailable) }  2.6 读取最多 N 个字节 os.File 提供了文件操作的基本功能，而 io、ioutil、bufio 提供了额外的辅助函数。\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 以只读模式打开文件 file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer file.Close() // 从文件中读取指定长度的字节数据 byteSlice := make([]byte, 20) bytesRead, err := file.Read(byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的字节数据长度：%d\\n\u0026quot;, bytesRead) log.Printf(\u0026quot;读取到的数据：%s \\n\u0026quot;, byteSlice) }  2.7 读取正好 N 个字节 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } // file.Read()可以读取一个小文件到大的byte slice中， // 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误 byteSlice := make([]byte, 5) numBytesRead, err := io.ReadFull(file, byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的字节数: %d\\n\u0026quot;, numBytesRead) log.Printf(\u0026quot;读取到的数据: %s\\n\u0026quot;, byteSlice) }  2.8 读取至少 N 个字节 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 打开文件，只读 file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } byteSlice := make([]byte, 512) minBytes := 18 // io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留 numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的字节数: %d\\n\u0026quot;, numBytesRead) log.Printf(\u0026quot;读取到的数据: %s\\n\u0026quot;, byteSlice) }  2.9 读取全部字节 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } // os.File.Read(), io.ReadFull() 和 // io.ReadAtLeast() 在读取之前都需要一个固定大小的byte slice。 // 但ioutil.ReadAll()会读取reader(这个例子中是file)的每一个字节，然后把字节slice返回。 data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取到的数据（十六进制）: %x\\n\u0026quot;, data) fmt.Printf(\u0026quot;读取到的数据（字符串）: %s\\n\u0026quot;, data) fmt.Println(\u0026quot;读取到的数据长度:\u0026quot;, len(data)) }  2.10 快读到内存 package main import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; ) func main() { // 直接读取，省略掉文件打开与关闭操作 data, err := ioutil.ReadFile(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;读取到的数据：%s \\n\u0026quot;, data) }  2.11 使用缓存读 缓存 reader 会把一些内容缓存在内存中，它提供了比 os.File 和 io.Reader 更多的函数，缺省的缓存大小是 4096，最小缓存是 16。\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) // 使用缓存读 func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } bufferedReader := bufio.NewReader(file) // 读取字节，当前指针不变 byteSlice := make([]byte, 5) byteSlice, err = bufferedReader.Peek(5) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取 5 个字节：%s \\n\u0026quot;, byteSlice) // 读取，指针同时移动 numBytesRead, err := bufferedReader.Read(byteSlice) if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取 %d 个字节：%s \\n\u0026quot;, numBytesRead, byteSlice) // 读取一个字节，如果不成功会返回 error myByte, err := bufferedReader.ReadByte() if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取一个字节：%c \\n\u0026quot;, myByte) // 读取到分隔符，包含分隔符 dataBytes, err := bufferedReader.ReadBytes('\\n') if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取字节：%s \\n\u0026quot;, dataBytes) // 读取到分隔符，包含分隔符，返回字符串 dataString, err := bufferedReader.ReadString('\\n') if err != nil { log.Fatal(err) } fmt.Printf(\u0026quot;读取字符串：%s \\n\u0026quot;, dataString) }  2.12 使用 scanner Scanner 是 bufio 包下的类型，在处理文件中以分隔符分隔的文本时很有用。\n通常我们使用换行符作为分隔符将文件内容分成多行。在 CSV 文件中，逗号一般作为一行内不同元素之间的分隔符。\nos.File 文件可以被包装成 bufio.Scanner，它就像一个缓存 reader。\n我们会调用 Scan() 方法去读取下一个分隔符，使用 Text() 或者 Bytes() 获取读取的数据。\n分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。\n如果没有定制的 SplitFunc 提供，缺省的 ScanLines 会使用 newLine 字符作为分隔符，其他的分隔函数还包括 ScanRunes 和 ScanWords，皆在 bufio 包中。\n/ To define your own split function, match this fingerprint type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error) // Returning (0, nil, nil) will tell the scanner // to scan again, but with a bigger buffer because // it wasn't enough data to reach the delimiter  下面的例子，为一个文件创建 bufio.Scanner，并按照单词和单行读取：\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } scanner := bufio.NewScanner(file) // 缺省的分隔函数是 buffio.ScanLines，我们这里使用 ScanWords。 // 也可以定制一个 SplitFunc 类型的分隔函数 scanner.Split(bufio.ScanWords) // scan 下一个 token。 success := scanner.Scan() if success == false { // 出现错误或者 EOF err = scanner.Err() if err == nil { log.Println(\u0026quot;读取完成，到达文件末尾！\u0026quot;) } else { log.Fatal(err) } } fmt.Println(\u0026quot;读取到第一个单词：\u0026quot;, scanner.Text()) //再次调用 scanner.Scan() 发下下一个 token //------ file.Close() file2, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer file2.Close() // 尝试按行读取 scannerLines := bufio.NewScanner(file2) scannerLines.Split(bufio.ScanLines) for { success2 := scannerLines.Scan() if success2 == false { // 出现错误或者 EOF err = scannerLines.Err() if err == nil { log.Println(\u0026quot;读取完成，到达文件末尾！\u0026quot;) } else { log.Fatal(err) } break } else { fmt.Printf(\u0026quot;读取到行：\u0026lt;%s\u0026gt;\\n\u0026quot;, scannerLines.Text()) } } }  3、压缩 3.1 打包（zip）文件 package main import ( \u0026quot;archive/zip\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) // 标准库支持zip 及 tar 格式打包 func main() { outFile, err := os.Create(\u0026quot;example_1.zip\u0026quot;) if err != nil { log.Fatal(err) } defer outFile.Close() // 创建 zip writer zipWriter := zip.NewWriter(outFile) // 往打包文件中写入文件及数据。 // 此处我们直接硬编码。你可以遍历文件夹，将其下的文件及内容写入。 var filesToArchive = []struct{ Name, Body string } { {\u0026quot;test1.txt\u0026quot;, \u0026quot;Hello, everyone!\u0026quot;}, {\u0026quot;test2.txt\u0026quot;, \u0026quot;\\x61\\x62\\x63\\n\u0026quot;}, } // 将要打包的内容写入打包文件 for _, file := range filesToArchive { fileWriter, err := zipWriter.Create(file.Name) if err != nil { log.Fatal(err) } _, err = fileWriter.Write([]byte(file.Body)) if err != nil { log.Fatal(err) } } // 清理 err = zipWriter.Close() if err != nil { log.Fatal(err) } }  3.2 抽取（unzip）文件 package main import ( \u0026quot;archive/zip\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;path/filepath\u0026quot; ) func main() { zipReader, err := zip.OpenReader(\u0026quot;example_1.zip\u0026quot;) if err != nil { log.Fatal(err) } defer zipReader.Close() // 遍历打包文件中的每一个文件/文件夹 for _, file := range zipReader.Reader.File { zippedFile, err := file.Open() if err != nil { log.Fatal(err) } defer zippedFile.Close() // 指定抽取的文件名 targetDir := \u0026quot;temp\u0026quot; extractedFilePath := filepath.Join(targetDir, file.Name) // 抽取项目或者创建文件夹 if file.FileInfo().IsDir() { // 创建文件夹并设置其权限与文件一致 log.Println(\u0026quot;创建文件夹：\u0026quot;, extractedFilePath) os.MkdirAll(extractedFilePath, file.Mode()) } else { // 抽取正常的文件 log.Println(\u0026quot;抽取文件：\u0026quot;, file.Name) outputFile, err := os.OpenFile( extractedFilePath, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, file.Mode(), ) if err != nil { log.Fatal(err) } defer outputFile.Close() // 通过 io.Copy 复制文件内容 _, err = io.Copy(outputFile, zippedFile) if err != nil { log.Fatal(err) } } } }  3.3 压缩文件 package main import ( \u0026quot;compress/gzip\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) // 压缩文件，本例使用 gzip 压缩格式，标准库还支持zlib, bz2, flate, lzw func main() { outputFile, err := os.Create(\u0026quot;example.txt.gz\u0026quot;) if err != nil { log.Fatal(err) } gzipWriter := gzip.NewWriter(outputFile) defer gzipWriter.Close() // 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。 // 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。 _, err = gzipWriter.Write([]byte(\u0026quot;我是数据数据数据!\\n\u0026quot;)) if err != nil { log.Fatal(err) } log.Println(\u0026quot;压缩数据已写入文件。\u0026quot;) }  3.4 解压缩文件 package main import ( \u0026quot;compress/gzip\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 打开一个gzip文件。 // 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容， // 它的内容不是一个文件，而是一个内存流 gzipFile, err := os.Open(\u0026quot;example.txt.gz\u0026quot;) if err != nil { log.Fatal(err) } gzipReader, err := gzip.NewReader(gzipFile) if err != nil { log.Fatal(err) } defer gzipReader.Close() // 解压缩到一个 writer,它是一个 file writer outfileWriter, err := os.Create(\u0026quot;example_unzipped.txt\u0026quot;) if err != nil { log.Fatal(err) } defer outfileWriter.Close() // 复制内容 _, err = io.Copy(outfileWriter, gzipReader) if err != nil { log.Fatal(err) } }  4、其他 4.1 临时文件和目录 ioutil 提供了两个函数：TempDir() 和 TempFile()。\n使用完毕后，调用者负责删除这些临时文件和文件夹。\n有一个好处是，当你传递一个空字符串作为文件夹名的时候，它会在操作系统的临时文件夹中创建这些项目（/tmp on Linux）。\nos.TempDir() 返回当前操作系统的临时文件夹。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { // 在系统临时文件夹中创建一个临时文件夹 tempDirPath, err := ioutil.TempDir(\u0026quot;\u0026quot;, \u0026quot;myTempDir\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;临时文件夹已创建:\u0026quot;, tempDirPath) // 在临时文件夹中创建临时文件 tempFile, err := ioutil.TempFile(tempDirPath, \u0026quot;myTempFile.txt\u0026quot;) if err != nil { log.Fatal(err) } fmt.Println(\u0026quot;临时文件已创建:\u0026quot;, tempFile.Name()) // ... 做一些操作 ... // 关闭文件 err = tempFile.Close() if err != nil { log.Fatal(err) } // 删除我们创建的资源 err = os.Remove(tempFile.Name()) if err != nil { log.Fatal(err) } err = os.Remove(tempDirPath) if err != nil { log.Fatal(err) } }  4.2 通过 HTTP 下载文件 package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; ) func main() { newFile, err := os.Create(\u0026quot;good_habits.html\u0026quot;) if err != nil { log.Fatal(err) } defer newFile.Close() url := \u0026quot;https://rjguanwen.cn/2019/11/good_habits/\u0026quot; response, err := http.Get(url) defer response.Body.Close() // 将HTTP response Body中的内容写入到文件 // Body满足reader接口，因此我们可以使用ioutil.Copy numBytesWritten, err := io.Copy(newFile, response.Body) if err != nil { log.Fatal(err) } log.Printf(\u0026quot;Downloaded %d byte file.\\n\u0026quot;, numBytesWritten) }  4.3 哈希和摘要 package main import ( \u0026quot;crypto/md5\u0026quot; \u0026quot;crypto/sha1\u0026quot; \u0026quot;crypto/sha256\u0026quot; \u0026quot;crypto/sha512\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; ) func main() { // 得到文件内容 data, err := ioutil.ReadFile(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } // 计算Hash fmt.Printf(\u0026quot;Md5: %x\\n\\n\u0026quot;, md5.Sum(data)) fmt.Printf(\u0026quot;Sha1: %x\\n\\n\u0026quot;, sha1.Sum(data)) fmt.Printf(\u0026quot;Sha256: %x\\n\\n\u0026quot;, sha256.Sum256(data)) fmt.Printf(\u0026quot;Sha512: %x\\n\\n\u0026quot;, sha512.Sum512(data)) }  上面的例子复制了整个文件内容到内存中，传递给 hash 函数。\n另一个方式是创建一个 hash writer，使用 Write、 WriteString、Copy 将数据传给它。\npackage main import ( \u0026quot;crypto/md5\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { file, err := os.Open(\u0026quot;example_1.txt\u0026quot;) if err != nil { log.Fatal(err) } defer file.Close() //创建一个新的 hasher,满足 writer 接口 hasher := md5.New() _, err = io.Copy(hasher, file) if err != nil { log.Fatal(err) } // 计算 hash 并打印结果。 // 传递 nil 作为参数，因为我们不通参数传递数据，而是通过 writer 接口。 sum := hasher.Sum(nil) fmt.Printf(\u0026quot;Md5 checksum: %x\\n\u0026quot;, sum) }  ","id":25,"section":"posts","summary":"\u0026lt;部分内容借鉴自网络，如有侵权，预先道歉，请及时联系（rjguanwen001@163.com），我会尽快删除，谢谢！\u0026gt; Go 文件操","tags":["技术","GOLANG"],"title":"Go 文件操作","uri":"https://rjguanwen.cn/1/01/go_file/","year":"0001"}],"tags":[{"title":"Centrifugo","uri":"https://rjguanwen.cn/tags/centrifugo/"},{"title":"docker","uri":"https://rjguanwen.cn/tags/docker/"},{"title":"gin","uri":"https://rjguanwen.cn/tags/gin/"},{"title":"GIT","uri":"https://rjguanwen.cn/tags/git/"},{"title":"golang","uri":"https://rjguanwen.cn/tags/golang/"},{"title":"redis","uri":"https://rjguanwen.cn/tags/redis/"},{"title":"个人","uri":"https://rjguanwen.cn/tags/%E4%B8%AA%E4%BA%BA/"},{"title":"光阴","uri":"https://rjguanwen.cn/tags/%E5%85%89%E9%98%B4/"},{"title":"句子","uri":"https://rjguanwen.cn/tags/%E5%8F%A5%E5%AD%90/"},{"title":"开发框架","uri":"https://rjguanwen.cn/tags/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"title":"技术","uri":"https://rjguanwen.cn/tags/%E6%8A%80%E6%9C%AF/"},{"title":"杂感随笔","uri":"https://rjguanwen.cn/tags/%E6%9D%82%E6%84%9F%E9%9A%8F%E7%AC%94/"},{"title":"诗词","uri":"https://rjguanwen.cn/tags/%E8%AF%97%E8%AF%8D/"}]}